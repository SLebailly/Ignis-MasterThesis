struct Technique {
    on_hit:              fn (Ray, i32, Hit, RayPayload, SurfaceElement, Material) -> Option[Color],
    on_miss:             fn (Ray, i32, RayPayload) -> Option[Color],
    on_shadow:           fn (Ray, i32, Hit, &mut RndState, RayPayload, SurfaceElement, Material) -> Option[(Ray, Color)],
    on_bounce:           fn (Ray, i32, Hit, &mut RndState, RayPayload, SurfaceElement, Material) -> Option[(Ray, RayPayload)],
    on_shadow_hit:       fn (Ray, i32, Color) -> Option[Color], // Will only be called if renderer makes use of advanced_shadows
    on_shadow_miss:      fn (Ray, i32, Color) -> Option[Color], // Will only be called if renderer makes use of advanced_shadows
}

fn @TechniqueNoHitFunction       (_: Ray, _: i32, _: Hit, _: RayPayload, _: SurfaceElement, _: Material)                   = Option[Color]::None;
fn @TechniqueNoMissFunction      (_: Ray, _: i32, _: RayPayload)                                                           = Option[Color]::None;
fn @TechniqueNoShadowFunction    (_: Ray, _: i32, _: Hit, _: &mut RndState, _: RayPayload, _: SurfaceElement, _: Material) = Option[(Ray, Color)]::None;
fn @TechniqueNoBounceFunction    (_: Ray, _: i32, _: Hit, _: &mut RndState, _: RayPayload, _: SurfaceElement, _: Material) = Option[(Ray, RayPayload)]::None;
fn @TechniqueNoShadowHitFunction (_: Ray, _: i32, _: Color)                                                                = Option[Color]::None;
fn @TechniqueNoShadowMissFunction(_: Ray, _: i32, _: Color)                                                                = Option[Color]::None;

type RayEmitter = fn (i32, i32, i32, i32, i32) -> (Ray, RndState, RayPayload);

static MaxRayPayloadComponents = 8;
struct RayPayload {
    components: [f32 * 8]
}

fn make_empty_payload() = undef[RayPayload]();