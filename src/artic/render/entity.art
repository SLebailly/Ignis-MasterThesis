struct EntityData {
    shape_id:   i32,
    bsdf_id:    i32,
    light_id:   i32,
    _pad1:      i32,
    local_mat:  [f32 * 12], // TODO: Check if on-the-fly calculation is worth it?
    global_mat: [f32 * 12],
    normal_mat: [f32 * 9],
    _pad2:      [f32 * 3]
}

struct Entity {
    shape_id:   i32,
    bsdf_id:    i32,
    light_id:   i32,
    emissive:   bool,
    local_mat:  Mat3x4,
    global_mat: Mat3x4,
    normal_mat: Mat3x3
}

type EntityTable = fn (i32) -> Entity;

fn @make_entity_table(dtb: DynTable, acc: DeviceBufferAccessor) -> EntityTable {
    let elem_s = sizeof[EntityData]() as u64;
    @ |id| {
        //let entry = get_lookup_entry(id as u64, dtb); // No need as we have only one type!
        let data = get_table_entry(elem_s * (id as u64), dtb, acc);

        let (shape_id, bsdf_id, light_id) = data.load_int3(0);
        Entity {
            shape_id   = shape_id,
            bsdf_id    = bsdf_id,
            light_id   = light_id,
            emissive   = light_id >= 0,
            local_mat  = data.load_mat3x4(4),
            global_mat = data.load_mat3x4(16),
            normal_mat = data.load_mat3x3(28)
        }
    } 
}