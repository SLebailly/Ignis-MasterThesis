struct EntityMap {
    local_mat4x4:  fn(i32) -> Mat4x4,
    global_mat4x4: fn(i32) -> Mat4x4,
    normal_mat3x3: fn(i32) -> Mat3x3,
    shape:         fn(i32) -> i32,
    shader:        fn(i32) -> Shader
}

struct EntityData {
    shape_id:   i32,
    mat_id:     i32,
    _pad1:      [i32 * 2],
    local_mat:  [f32 * 16], // TODO: Check if on-the-fly calculation is worth it?
    global_mat: [f32 * 16],
    normal_mat: [f32 * 9],
    _pad2:      f32
}

struct Entity {
    shape_id:   i32,
    mat_id:     i32,
    local_mat:  Mat4x4,
    global_mat: Mat4x4,
    normal_mat: Mat3x3
}

type EntityTable = fn (i32) -> Entity;

fn @make_entity_table(dtb: DynTable, acc: DeviceBufferAccessor) -> EntityTable {
    let elem_s = sizeof[EntityData]() as u64;
    |id| {
        //let entry = get_lookup_entry(id as u64, dtb); // No need as we have only one type!
        let data = get_table_entry(elem_s * (id as u64), dtb, acc);

        Entity {
            shape_id   = data.load_i32(0),
            mat_id     = data.load_i32(1),
            local_mat  = data.load_mat4x4(4),
            global_mat = data.load_mat4x4(20),
            normal_mat = data.load_mat3x3(36)
        }
    } 
}