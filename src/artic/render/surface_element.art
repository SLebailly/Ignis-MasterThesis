// Opaque description of a point on a surface
struct SurfaceElement {
    is_entering: bool,  // True if the path enters the surface
    point:       Vec3,  // Point on the surface
    face_normal: Vec3,  // Geometric normal at the surface point
    inv_area:    f32,   // Inverse area of surface element
    prim_coords: Vec2,  // UV coordinates on the surface
    tex_coords:  Vec2,  // Vertex attributes (interpolated)
    local:       Mat3x3 // Local coordinate system at the surface point
}

fn make_invalid_surface_element() = SurfaceElement {
    is_entering = false,
    point       = make_vec3(0,0,0),
    face_normal = make_vec3(0,0,0),
    inv_area    = 0,
    prim_coords = make_vec2(0,0),
    tex_coords  = make_vec2(0,0),
    local       = mat3x3_identity()
};

fn @invert_surface_element(surf: SurfaceElement) = SurfaceElement {
    is_entering = !surf.is_entering,
    point       = surf.point,
    face_normal = vec3_neg(surf.face_normal),
    inv_area    = surf.inv_area,
    prim_coords = surf.prim_coords,
    tex_coords  = surf.tex_coords,
    local       = flip_orthonormal_mat3x3(surf.local)
};

// Map local surface element to global surface element based on the given entity
fn @map_surface_element(surf: SurfaceElement, global_mat: Mat3x4, normal_mat: Mat3x3) -> SurfaceElement {
    let new_n    = mat3x3_mul(normal_mat, surf.face_normal);
    let inv_area = safe_div(1, vec3_len(new_n));

    SurfaceElement {
        is_entering = surf.is_entering,
        point       = mat3x4_transform_point(global_mat, surf.point),
        face_normal = vec3_mulf(new_n, inv_area),
        inv_area    = surf.inv_area * inv_area,
        prim_coords = surf.prim_coords,
        tex_coords  = surf.tex_coords,
        local       = mat3x3_normalize_cols(mat3x3_matmul(normal_mat, surf.local))
    }
}

// From Blender Cycles
// https://github.com/blender/cycles/blob/c40170f6ea8828757eb2cb8db960d3bf4620d03f/src/kernel/closure/bsdf_util.h#L151
fn @ensure_valid_reflection(Ng: Vec3, I: Vec3, N: Vec3) -> Vec3 {
    let R = vec3_reflect(I, N);

    let threshold = math_builtins::fmin[f32](0.9 * vec3_dot(Ng, I), 0.01);
    if vec3_dot(Ng, R) >= threshold { return(N) }

    let NdotNg = vec3_dot(N, Ng);
    let X = vec3_normalize(vec3_sub(N, vec3_mulf(Ng, NdotNg)));

    let Ix  = vec3_dot(I, X);
    let Iz  = vec3_dot(I, Ng);
    let Ix2 = Ix * Ix;
    let Iz2 = Iz * Iz;
    let a = Ix2 + Iz2;

    let b = safe_sqrt(Ix2 * (a - threshold*threshold));
    let c = Iz * threshold + a;

    let fac = 0.5 / a;
    let N1_z2  = fac * (b + c);
    let N2_z2  = fac * (-b + c);
    let valid1 = (N1_z2 > 1e-5) && (N1_z2 <= (1.0 + 1e-5));
    let valid2 = (N2_z2 > 1e-5) && (N2_z2 <= (1.0 + 1e-5));

    let N_new = if valid1 && valid2 {
        let N1 = make_vec2(safe_sqrt(1 - N1_z2), safe_sqrt(N1_z2));
        let N2 = make_vec2(safe_sqrt(1 - N2_z2), safe_sqrt(N2_z2));

        let R1 = 2 * (N1.x * Ix + N1.y * Iz) * N1.y - Iz;
        let R2 = 2 * (N2.x * Ix + N2.y * Iz) * N2.y - Iz;

        let valid3 = (R1 >= 1e-5);
        let valid4 = (R2 >= 1e-5);
        if valid3 && valid4 {
            select(R1 < R2, N1, N2)
        } else {
            select(R1 > R2, N1, N2)
        }
    } else if valid1 || valid2 {
        let Nz2 = select(valid1, N1_z2, N2_z2);
        make_vec2(safe_sqrt(1 - Nz2), safe_sqrt(Nz2))
    } else {
        vec2_expand(0)
    };

    vec3_add(vec3_mulf(X, N_new.x), vec3_mulf(Ng, N_new.y))
}