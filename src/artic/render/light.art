// Result from sampling a light source
struct EmissionSample {
    pos:       Vec3,  // Position on the light source
    dir:       Vec3,  // Direction of the light going outwards
    intensity: Color, // Intensity along the direction
    pdf_area:  f32,   // Probability to sample the point on the light
    pdf_dir:   f32,   // Probability to sample the direction on the light, conditioned on the point on the light source
    cos:       f32    // Cosine between the direction and the light source geometry
}

// Result from sampling direct lighting from a light source
struct DirectLightSample {
    posdir:    Vec3,  // Position on the light source (or direction if infinite)
    intensity: Color, // Intensity along the direction
    pdf_area:  f32,   // Probability to sample the point on the light
    pdf_dir:   f32,   // Probability to sample the direction using emission sampling
    cos:       f32    // Cosine between the direction and the light source geometry
}

// Emission properties of a light source
struct EmissionValue {
    intensity: Color, // Intensity along the direction
    pdf_area:  f32,   // Probability to sample the point on the light
    pdf_dir:   f32    // Probability to sample the direction using emission sampling
}

// Surface that emits light
struct AreaEmitter {
    sample: fn (Vec2) -> (Vec3, Vec3, f32),
    normal: fn (Vec2) -> Vec3,
    pdf:    fn (Vec2) -> f32
}

// Opaque light structure
struct Light {
    // Samples direct illumination from this light source at the given point on a surface
    sample_direct: fn (&mut RndState, SurfaceElement) -> DirectLightSample,
    // Samples the emitting surface of the light
    sample_emission: fn (&mut RndState) -> EmissionSample,
    // Returns the emission properties of the light at a given point on its surface
    emission: fn (Vec3, Vec2) -> EmissionValue,
    // true if the light is a delta light (can not be hit by a ray)
    delta: bool,
    // true if the light is infinite
    infinite: bool
}

fn @make_emission_sample(pos: Vec3, dir: Vec3, intensity: Color, pdf_area: f32, pdf_dir: f32, cos: f32) = EmissionSample {
    pos       = pos,
    dir       = dir,
    intensity = intensity,
    pdf_area  = pdf_area,
    pdf_dir   = pdf_dir,
    cos       = cos
};

fn @make_direct_sample(posdir: Vec3, intensity: Color, pdf_area: f32, pdf_dir: f32, cos: f32) = DirectLightSample {
    posdir    = posdir,
    intensity = intensity,
    pdf_area  = pdf_area,
    pdf_dir   = pdf_dir,
    cos       = cos
};

fn @make_emission_value(intensity: Color, pdf_area: f32, pdf_dir: f32) = EmissionValue {
    intensity = intensity,
    pdf_area  = pdf_area,
    pdf_dir   = pdf_dir
};

// This samples the environment by naive sphere sampling
fn @make_mix_light(lightA : Light, lightB : Light, probability : f32) = Light {
    sample_direct = @ |rnd, from| {
        let A = lightA.sample_direct(rnd, from);
        let B = lightB.sample_direct(rnd, from);
        let u = randf(rnd);
        if u < probability {
            make_direct_sample(A.posdir, A.intensity,
                 A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, A.cos)
        } else {
            make_direct_sample(B.posdir, B.intensity,
                 A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, B.cos)
        }
    },
    sample_emission = @ |rnd| {
        if !lightA.delta && !lightB.delta {
            let A = lightA.sample_emission(rnd);
            let B = lightB.sample_emission(rnd);
            let u = randf(rnd);

            if u < probability {
                make_emission_sample(A.pos, A.dir, A.intensity,
                     A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, A.cos)
            } else {
                make_emission_sample(B.pos, B.dir, B.intensity,
                     A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, B.cos)
            }
        } else if lightA.delta && !lightB.delta {
            lightB.sample_emission(rnd)
        } else {
            lightA.sample_emission(rnd)
        }
    },
    emission = @ |dir, prim_coords| {
        if !lightA.delta && !lightB.delta {
            let A = lightA.emission(dir, prim_coords);
            let B = lightB.emission(dir, prim_coords); 
            make_emission_value(color_lerp(A.intensity,B.intensity, probability), A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability) 
        } else if lightA.delta && !lightB.delta {
            lightB.emission(dir, prim_coords)
        } else {
            lightA.emission(dir, prim_coords)
        }
    },
    delta = (lightA.delta && lightB.delta),
    infinite = (lightA.infinite || lightB.infinite)
};

//-------------------------------------------
fn @make_null_light() = Light {
    sample_direct = @ |_, _| undef[DirectLightSample](),
    sample_emission = @ |_| undef[EmissionSample](),
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = true
};

//-------------------------------------------
fn @make_point_light(math: Intrinsics, pos: Vec3, color: Color) = Light {
    sample_direct = @ |_, _| {
        let intensity = color_mulf(color, 1 / (4 * flt_pi));
        make_direct_sample(pos, intensity, 1, uniform_sphere_pdf(), 1)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        let intensity = color_mulf(color, 1 / (4 * flt_pi));
        make_emission_sample(pos, sample.dir, intensity, 1, sample.pdf, 1)
    },
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = false
};

fn @load_point_light(math: Intrinsics, data: DeviceBuffer, _stage: Stage3Accessor) -> Light {
    let pos   = data.load_vec3(0);
    let color = data.load_vec3(4);

    make_point_light(math, pos, vec3_to_color(color))
}

//-------------------------------------------
fn @make_directional_light(_math: Intrinsics, dir: Vec3, max_radius: f32, color: Color) = Light {
    sample_direct = @ |_, _| {
        make_direct_sample(dir, color, 1, 1, 1)
    },
    sample_emission = @ |_| {
        make_emission_sample(vec3_mulf(dir, max_radius), dir, color, 1, 1, 1)
    },
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = true
};

fn @load_directional_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor) -> Light {
    let dir   = data.load_vec3(0);
    let color = data.load_vec3(4);

    make_directional_light(math, dir, stage.info.scene_radius, vec3_to_color(color))
}

//-------------------------------------------
fn @make_sun_light(math: Intrinsics, dir: Vec3, max_radius: f32, sun_radius: f32, color: Color) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_disk(math, u, v, sun_radius);
        let ndir = vec3_normalize(math, mat3x3_mul(make_orthonormal_mat3x3(dir), sample.pos));
        make_direct_sample(ndir, color, 1.0, sample.pdf, 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_disk(math, u, v, sun_radius);
        let ndir = vec3_normalize(math, mat3x3_mul(make_orthonormal_mat3x3(dir), sample.pos));
        make_emission_sample(vec3_mulf(dir, max_radius), ndir, color, 1.0, sample.pdf, 1.0)
    },
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = true
};

fn @load_sun_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor) -> Light {
    let e0    = data.load_vec4(0);
    let dir   = make_vec3(e0.x, e0.y, e0.z);
    let power = e0.w;
    let sun_r = data.load_f32(4);

    make_sun_light(math, dir, stage.info.scene_radius, sun_r, make_gray_color(power))
}

fn @load_sky_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor) -> Light {
    let buffer_id = data.load_i32(0);
    let buffer    = stage.buffers(buffer_id);
    let (azim_n, elev_n) = buffer.load_int2(0);

    let func = @|dir:Vec3| {
        let (theta, phi) = spherical_from_dir(math, dir);

        let azimuth   = if phi < 0 { phi + 2 * flt_pi } else { phi };
        let elevation = theta - flt_pi / 2;

        let u = azimuth / (2 * flt_pi);
        let v = if elevation < 0 { 0 } else { 2 * elevation / flt_pi };

        let x = (u * ((azim_n - 1) as f32)) as i32;
        let y = (v * ((elev_n - 1) as f32)) as i32;

        vec3_to_color(buffer.load_vec3(4 + y * azim_n * 4 + x * 4))
    };

    make_environment_light_function(math, stage.info.scene_radius, func)
}

//-------------------------------------------
// This samples the environment by naive sphere sampling
fn @make_environment_light(math: Intrinsics, max_radius: f32, color: Color) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        make_direct_sample(sample.dir, color, 1.0, uniform_sphere_pdf(), 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        make_emission_sample(vec3_mulf(sample.dir,max_radius), sample.dir, color, 1.0, sample.pdf, 1.0)
    },
    emission = @ |_, _| make_emission_value(color, 1.0, uniform_sphere_pdf()),
    delta    = false,
    infinite = true
};

fn @load_environment_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor) -> Light {
    let color = data.load_vec3(0);
    make_environment_light(math, stage.info.scene_radius, vec3_to_color(color))
}

//-------------------------------------------
/* TODO: This should contain a distribution map for efficient sampling */
fn @make_environment_light_textured(math: Intrinsics, max_radius: f32, tex: Texture) -> Light {
    let eval = @|dir : Vec3| -> Color {
        let (theta, phi) = spherical_from_dir(math, dir);
        let u = theta / flt_pi;
        let v = phi / (2 * flt_pi);

        tex(make_vec2(v,u))
    };

    Light {
        sample_direct = @ |rnd, _| {
            let u = randf(rnd);
            let v = randf(rnd);
            let sample = sample_uniform_sphere(math, u, v);
            let intensity = eval(sample.dir);
            make_direct_sample(sample.dir, intensity, 1.0, uniform_sphere_pdf(), 1.0)
        },
        sample_emission = @ |rnd| {
            let u = randf(rnd);
            let v = randf(rnd);
            let sample = sample_uniform_sphere(math, u, v);
            let intensity = eval(sample.dir);
            make_emission_sample(vec3_mulf(sample.dir, max_radius), sample.dir, intensity, 1.0, sample.pdf, 1.0)
        },
        emission = @ |dir, _| make_emission_value(eval(dir), 1.0, uniform_sphere_pdf()),
        delta    = false,
        infinite = true
    }
}

fn @load_environment_textured_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor) -> Light {
    let tex_id  = data.load_i32(0);
    let texture = stage.textures(tex_id);
    make_environment_light_textured(math, stage.info.scene_radius, texture)
}

//-------------------------------------------
fn @make_environment_light_function(math: Intrinsics, max_radius: f32, func: fn(Vec3)->Color) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        let intensity = func(sample.dir);
        make_direct_sample(sample.dir, intensity, 1.0, uniform_sphere_pdf(), 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        let intensity = func(sample.dir);
        make_emission_sample(vec3_mulf(sample.dir,max_radius), sample.dir, intensity, 1.0, sample.pdf, 1.0)
    },
    emission = @ |dir, _| {
        make_emission_value(func(dir), 1.0, uniform_sphere_pdf())
    },
    delta    = false,
    infinite = true
};

fn @make_cie_sky_light(math: Intrinsics, max_radius: f32, zenith: Color, ground: Color, groundBrightness: f32, cloudy: bool) =
    make_environment_light_function(math, max_radius, @|dir|{
        let theta = -dir.y;
        let a     = math.powf(theta + 1.01, 10);
        let b	  = 1 / a;
        let denom = 1 / (a + b);
        let c1    = if cloudy { (1 + 2.0 * theta) / 3.0} else { 1 : f32 };
        let c2    = if cloudy { 0.777777777 : f32} else { 1 : f32 };
        color_mulf(color_add(color_mulf(zenith, c1 * a), color_mulf(ground, groundBrightness * c2 * b)), denom)
});

fn @load_cie_sky_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor, cloudy: bool) -> Light {
    let e0               = data.load_vec4(0);
    let zenith           = make_color(e0.x, e0.y, e0.z);
    let groundBrightness = e0.w;
    let ground           = vec3_to_color(data.load_vec3(4));
    make_cie_sky_light(math, stage.info.scene_radius, zenith, ground, groundBrightness, cloudy)
}

//-------------------------------------------
fn @load_cie_uniform_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor) = @load_cie_sky_light(math, data, stage, false);
fn @load_cie_cloudy_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor)  = @load_cie_sky_light(math, data, stage, true);

//-------------------------------------------
fn @make_perez_light(math: Intrinsics, max_radius: f32, sun_dir: Vec3, lum: Color, a: f32, b: f32, c: f32, d: f32, e: f32)  =
    make_environment_light_function(math, max_radius, @|dir|{
        let theta = -dir.y;                 // Cosine between zenith and direction
        let sun_c = vec3_dot(dir, sun_dir); // Cosine between sun and direction
        let sun_a = math.acosf(sun_c);      // Angle between sun and direction

        let A      = if math.fabsf(theta) <= flt_eps { 1 } else { 1 + a * math.expf(b / theta) };
        let B      = 1 + c * math.expf(d * sun_a) + e * sun_c * sun_c;
        let factor = A * B;
        color_mulf(lum, factor)
});

fn @load_perez_light(math: Intrinsics, data: DeviceBuffer, stage: Stage3Accessor) -> Light {
    let e0    = data.load_vec4(0);
    let e1    = data.load_vec4(4);
    let color = vec3_to_color(data.load_vec3(8));
    
    let dir = make_vec3(e0.x, e0.y, e0.z);
    let a   = e0.w;
    let b   = e1.x;
    let c   = e1.y;
    let d   = e1.z;
    let e   = e1.w;
    
    make_perez_light(math, stage.info.scene_radius, dir, color, a, b, c, d, e)
}

//-------------------------------------------
fn @make_area_light(math: Intrinsics, area: AreaEmitter, color: Color) = Light {
    sample_direct = @ |rnd, from_surf| {
        let (pos, n, area_pdf) = area.sample(make_vec2(randf(rnd), randf(rnd)));
        let dir = vec3_sub(from_surf.point, pos);
        let cos = vec3_dot(dir, n) / vec3_len(math, dir);
        make_direct_sample(pos, color, area_pdf, cosine_hemisphere_pdf(cos), cos)
    },
    sample_emission = @ |rnd| {
        let (pos, n, area_pdf) = area.sample(make_vec2(randf(rnd), randf(rnd)));
        let sample = sample_cosine_hemisphere(math, randf(rnd), randf(rnd));
        make_emission_sample(pos, mat3x3_mul(make_orthonormal_mat3x3(n), sample.dir), color, area_pdf, sample.pdf, sample.dir.z)
    },
    emission = @ |dir, prim_coords| make_emission_value(color, area.pdf(prim_coords), cosine_hemisphere_pdf(vec3_dot(area.normal(prim_coords), dir))),
    delta    = false,
    infinite = false
};

fn @load_area_light(math: Intrinsics, data: DeviceBuffer, acc: Stage3Accessor) -> Light {
    let e0    = data.load_vec4(0);
    let id    = bitcast[i32](e0.x);
    let color = make_color(e0.y, e0.z, e0.w);

    let entity  = acc.entities(id);
    let shape   = acc.shapes(entity.shape_id);
    let mesh    = shape.mesh;
    let emitter = AreaEmitter {
        sample = @ |uv| {
            let ux  = uv.x * (mesh.num_tris as f32);
            let f   = ux as i32;
            let uv2 = make_vec2(ux - (f as f32), uv.y);
            let (i0, i1, i2) = mesh.triangles(f);
            let v0  = mesh.vertices(i0);
            let v1  = mesh.vertices(i1);
            let v2  = mesh.vertices(i2);
            let n   = mesh.face_normals(f);
            let inv_area = mesh.face_inv_area(f);
            (mat3x4_transform_point(entity.global_mat, sample_triangle(uv2.x, uv2.y, v0, v1, v2)),
             vec3_normalize(math, mat3x3_mul(entity.normal_mat, n)),
             inv_area)
        },
        normal = @ |uv| {
            let f = (uv.x * (mesh.num_tris as f32)) as i32;
            vec3_normalize(math, mat3x3_mul(entity.normal_mat, mesh.face_normals(f)))
        },
        pdf = @ |uv| {
            let f = (uv.x * (mesh.num_tris as f32)) as i32;
            mesh.face_inv_area(f)
        }
    };
    make_area_light(math, emitter, color)
}

type LightTable = fn (i32) -> Light;

fn @make_light_table(math: Intrinsics, dtb: DynTable, acc: DeviceBufferAccessor, stage: Stage3Accessor) -> LightTable {
    @ |id| {
        let entry = get_lookup_entry(id as u64, dtb, acc);
        let data  = get_table_entry(entry.offset, dtb, acc);
        match entry.type_id {
            0x00 => load_point_light(math, data, stage),                // LIGHT_POINT
            0x01 => load_area_light(math, data, stage),                 // LIGHT_AREA				   
            0x02 => load_directional_light(math, data, stage),          // LIGHT_DIRECTIONAL		   
            0x03 => load_sun_light(math, data, stage),                  // LIGHT_SUN				   
            0x04 => load_sky_light(math, data, stage),                  // LIGHT_SKY			   
            0x10 => load_cie_uniform_light(math, data, stage),          // LIGHT_CIE_UNIFORM		   
            0x11 => load_cie_cloudy_light(math, data, stage),           // LIGHT_CIE_CLOUDY		   
            0x12 => load_perez_light(math, data, stage),                // LIGHT_PEREZ				  
            0x20 => load_environment_light(math, data, stage),          // LIGHT_ENVIRONMENT		  
            0x21 => load_environment_textured_light(math, data, stage), // LIGHT_ENVIRONMENT_TEXTURED
            _ =>  make_environment_light(math, 0, black)
        }
    } 
}

// Same purpose as make_light_table, but assume given type_id is always an area light
// This improves code compilation and overall performance by magnitudes...
fn @make_arealight_table(math: Intrinsics, dtb: DynTable, acc: DeviceBufferAccessor, stage: Stage3Accessor) -> LightTable {
    @ |id| {
        let entry = get_lookup_entry(id as u64, dtb, acc);
        let data  = get_table_entry(entry.offset, dtb, acc);
        load_area_light(math, data, stage)
    } 
}