// Result from sampling a light source
struct EmissionSample {
    pos: Vec3,          // Position on the light source
    dir: Vec3,          // Direction of the light going outwards
    intensity: Color,   // Intensity along the direction
    pdf_area: f32,      // Probability to sample the point on the light
    pdf_dir: f32,       // Probability to sample the direction on the light, conditioned on the point on the light source
    cos: f32            // Cosine between the direction and the light source geometry
}

// Result from sampling direct lighting from a light source
struct DirectLightSample {
    pos: Vec3,          // Position on the light source (or direction if infinite)
    intensity: Color,   // Intensity along the direction
    pdf_area: f32,      // Probability to sample the point on the light
    pdf_dir: f32,       // Probability to sample the direction using emission sampling
    cos: f32            // Cosine between the direction and the light source geometry
}

// Emission properties of a light source
struct EmissionValue {
    intensity: Color,   // Intensity along the direction
    pdf_area: f32,      // Probability to sample the point on the light
    pdf_dir: f32        // Probability to sample the direction using emission sampling
}

// Surface that emits light
struct AreaEmitter {
    sample: fn (Vec2) -> (Vec3, Vec3, f32),
    normal: fn (Vec2) -> Vec3,
    pdf:    fn (Vec2) -> f32
}

// Opaque light structure
struct Light {
    // Samples direct illumination from this light source at the given point on a surface
    sample_direct: fn (&mut RndState, SurfaceElement) -> DirectLightSample,
    // Samples the emitting surface of the light
    sample_emission: fn (&mut RndState) -> EmissionSample,
    // Returns the emission properties of the light at a given point on its surface
    emission: fn (Vec3, Vec2) -> EmissionValue,
    // true if the light is a delta light (can not be hit by a ray)
    delta: bool,
    // true if the light is infinite
    infinite: bool
}

fn @make_emission_sample(pos: Vec3, dir: Vec3, intensity: Color, pdf_area: f32, pdf_dir: f32, cos: f32) -> EmissionSample {
    if pdf_area > 0 && pdf_dir > 0 && cos > 0 {
        EmissionSample {
            pos = pos,
            dir = dir,
            intensity = intensity,
            pdf_area = pdf_area,
            pdf_dir = pdf_dir,
            cos = cos
        }
    } else {
        EmissionSample {
            pos = pos,
            dir = dir,
            intensity = black,
            pdf_area = 1,
            pdf_dir = 1,
            cos = 1
        }
    }
}

fn @make_direct_sample(pos: Vec3, intensity: Color, pdf_area: f32, pdf_dir: f32, cos: f32) -> DirectLightSample {
    if pdf_area > 0 && pdf_dir > 0 && cos > 0 {
        DirectLightSample {
            pos = pos,
            intensity = intensity,
            pdf_area = pdf_area,
            pdf_dir = pdf_dir,
            cos = cos
        }
    } else {
        DirectLightSample {
            pos = pos,
            intensity = black,
            pdf_area = 1,
            pdf_dir = 1,
            cos = 0
        }
    }
}

fn @make_emission_value(intensity: Color, pdf_area: f32, pdf_dir: f32) -> EmissionValue {
    if pdf_dir > 0 {
        EmissionValue {
            intensity = intensity,
            pdf_area = pdf_area,
            pdf_dir = pdf_dir
        }
    } else {
        EmissionValue {
            intensity = black,
            pdf_area = 1,
            pdf_dir = 1
        }
    }
}

// This samples the environment by naive sphere sampling
fn @make_mix_light(lightA : Light, lightB : Light, probability : f32) = Light {
    sample_direct = @ |rnd, from| {
        let A = lightA.sample_direct(rnd, from);
        let B = lightB.sample_direct(rnd, from);
        let u = randf(rnd);
        if u < probability {
            make_direct_sample(A.pos, A.intensity, A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, A.cos)
        } else {
            make_direct_sample(B.pos, B.intensity, A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, B.cos)
        }
    },
    sample_emission = @ |rnd| {
        if !lightA.delta && !lightB.delta {
            let A = lightA.sample_emission(rnd);
            let B = lightB.sample_emission(rnd);
            let u = randf(rnd);

            if u < probability {
                make_emission_sample(A.pos, A.dir, A.intensity, A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, A.cos)
            } else {
                make_emission_sample(B.pos, B.dir, B.intensity, A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability, B.cos)
            }
        } else if lightA.delta && !lightB.delta {
            lightB.sample_emission(rnd)
        } else {
            lightA.sample_emission(rnd)
        }
    },
    emission = @ |dir, uv_coords| {
        if !lightA.delta && !lightB.delta {
            let A = lightA.emission(dir, uv_coords);
            let B = lightB.emission(dir, uv_coords); 
            make_emission_value(color_lerp(A.intensity,B.intensity, probability), A.pdf_area*(1-probability)+B.pdf_area*probability, A.pdf_dir*(1-probability)+B.pdf_dir*probability) 
        } else if lightA.delta && !lightB.delta {
            lightB.emission(dir, uv_coords)
        } else {
            lightA.emission(dir, uv_coords)
        }
    },
    delta = (lightA.delta && lightB.delta),
    infinite = (lightA.infinite || lightB.infinite)
};

//-------------------------------------------
fn @make_null_light() = Light {
    sample_direct = @ |_, _| undef[DirectLightSample](),
    sample_emission = @ |_| undef[EmissionSample](),
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = true
};

//-------------------------------------------
fn @make_point_light(math: Intrinsics, pos: Vec3, color: Color) = Light {
    sample_direct = @ |_, _| {
        let intensity = color_mulf(color, 1 / (4 * flt_pi));
        make_direct_sample(pos, intensity, 1, uniform_sphere_pdf(), 1)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        let intensity = color_mulf(color, 1 / (4 * flt_pi));
        make_emission_sample(pos, sample.dir, intensity, 1, sample.pdf, 1)
    },
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = false
};

fn @load_point_light(math: Intrinsics, data: DeviceBuffer, _info: SceneInfo) -> Light {
    let pos   = data.load_vec3(0);
    let color = data.load_vec3(4);

    make_point_light(math, pos, vec3_to_color(color))
}

//-------------------------------------------
fn @make_directional_light(_math: Intrinsics, dir: Vec3, max_radius: f32, color: Color) = Light {
    sample_direct = @ |_, _| {
        make_direct_sample(dir, color, 1, 1, 1)
    },
    sample_emission = @ |_| {
        make_emission_sample(vec3_mulf(dir, max_radius), dir, color, 1, 1, 1)
    },
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = true
};

fn @load_directional_light(math: Intrinsics, data: DeviceBuffer, info: SceneInfo) -> Light {
    let dir   = data.load_vec3(0);
    let color = data.load_vec3(4);

    make_directional_light(math, dir, info.scene_radius, vec3_to_color(color))
}

//-------------------------------------------
fn @make_sun_light(math: Intrinsics, dir: Vec3, max_radius: f32, sun_radius: f32, color: Color) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_disk(math, u, v, sun_radius);
        let ndir = vec3_normalize(math, mat3x3_mul(make_orthonormal_mat3x3(dir), sample.pos));
        make_direct_sample(ndir, color, 1.0, sample.pdf, 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_disk(math, u, v, sun_radius);
        let ndir = vec3_normalize(math, mat3x3_mul(make_orthonormal_mat3x3(dir), sample.pos));
        make_emission_sample(vec3_mulf(dir, max_radius), ndir, color, 1.0, sample.pdf, 1.0)
    },
    emission = @ |_, _| make_emission_value(black, 1, 1),
    delta    = true,
    infinite = true
};

fn @load_sun_light(math: Intrinsics, data: DeviceBuffer, info: SceneInfo) -> Light {
    let e0    = data.load_vec4(0);
    let dir   = make_vec3(e0.x, e0.y, e0.z);
    let power = e0.w;
    let sun_r = data.load_f32(4);

    make_sun_light(math, dir, info.scene_radius, sun_r, make_gray_color(power))
}

fn @load_sky_light(math: Intrinsics, _data: DeviceBuffer, info: SceneInfo) -> Light {
    // TODO
    make_environment_light(math, info.scene_radius, black)
}

//-------------------------------------------
// This samples the environment by naive sphere sampling
fn @make_sunsky_light(math: Intrinsics, dir: Vec3, max_radius: f32, sun_radius: f32, sun_color: Color, sky_tex: Texture) = make_mix_light(
        make_sun_light(math, dir, max_radius, sun_radius, sun_color),
        make_environment_light_textured(math, max_radius, sky_tex), 
        0.5);

fn @load_sunsky_light(math: Intrinsics, _data: DeviceBuffer, info: SceneInfo) -> Light {
    // TODO
    make_environment_light(math, info.scene_radius, black)
}

//-------------------------------------------
// This samples the environment by naive sphere sampling
fn @make_environment_light(math: Intrinsics, max_radius: f32, color: Color) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        make_direct_sample(sample.dir, color, 1.0, uniform_sphere_pdf(), 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        make_emission_sample(vec3_mulf(sample.dir,max_radius), sample.dir, color, 1.0, sample.pdf, 1.0)
    },
    emission = @ |_, _| make_emission_value(color, 1.0, uniform_sphere_pdf()),
    delta    = false,
    infinite = true
};

fn @load_environment_light(math: Intrinsics, data: DeviceBuffer, info: SceneInfo) -> Light {
    let color = data.load_vec3(0);
    make_environment_light(math, info.scene_radius, vec3_to_color(color))
}

//-------------------------------------------
/* TODO: This should contain a distribution map for efficient sampling */
fn @make_environment_light_textured(math: Intrinsics, max_radius: f32, tex: Texture) -> Light {
    let eval = @|dir : Vec3| -> Color {
        let (theta, phi) = spherical_from_dir(math, dir);
        let u = theta / flt_pi;
        let v = phi / (2 * flt_pi);

        tex(make_vec2(v,u))
    };

    Light {
        sample_direct = @ |rnd, _| {
            let u = randf(rnd);
            let v = randf(rnd);
            let sample = sample_uniform_sphere(math, u, v);
            let intensity = eval(sample.dir);
            make_direct_sample(sample.dir, intensity, 1.0, uniform_sphere_pdf(), 1.0)
        },
        sample_emission = @ |rnd| {
            let u = randf(rnd);
            let v = randf(rnd);
            let sample = sample_uniform_sphere(math, u, v);
            let intensity = eval(sample.dir);
            make_emission_sample(vec3_mulf(sample.dir, max_radius), sample.dir, intensity, 1.0, sample.pdf, 1.0)
        },
        emission = @ |dir, _| make_emission_value(eval(dir), 1.0, uniform_sphere_pdf()),
        delta    = false,
        infinite = true
    }
}

fn @load_environment_textured_light(math: Intrinsics, _data: DeviceBuffer, info: SceneInfo) -> Light {
    // TODO
    make_environment_light(math, info.scene_radius, black)
}

//-------------------------------------------
fn @make_environment_light_function(math: Intrinsics, max_radius: f32, func: fn(Vec3)->Color) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        let intensity = func(sample.dir);
        make_direct_sample(sample.dir, intensity, 1.0, uniform_sphere_pdf(), 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        let intensity = func(sample.dir);
        make_emission_sample(vec3_mulf(sample.dir,max_radius), sample.dir, intensity, 1.0, sample.pdf, 1.0)
    },
    emission = @ |dir, _| {
        make_emission_value(func(dir), 1.0, uniform_sphere_pdf())
    },
    delta    = false,
    infinite = true
};

fn @make_cie_sky_light(math: Intrinsics, max_radius: f32, zenith: Color, ground: Color, groundBrightness: f32, cloudy: bool) =
    make_environment_light_function(math, max_radius, @|dir|{
        let theta = -dir.y;
        let a     = math.powf(theta + 1.01, 10);
        let b	  = 1 / a;
        let denom = 1 / (a + b);
        let c1    = if cloudy { (1 + 2.0 * theta) / 3.0} else { 1 : f32 };
        let c2    = if cloudy { 0.777777777 : f32} else { 1 : f32 };
        color_mulf(color_add(color_mulf(zenith, c1 * a), color_mulf(ground, groundBrightness * c2 * b)), denom)
});

fn @load_cie_sky_light(math: Intrinsics, data: DeviceBuffer, info: SceneInfo, cloudy: bool) -> Light {
    let e0               = data.load_vec4(0);
    let zenith           = make_color(e0.x, e0.y, e0.z);
    let groundBrightness = e0.w;
    let ground           = vec3_to_color(data.load_vec3(4));
    make_cie_sky_light(math, info.scene_radius, zenith, ground, groundBrightness, cloudy)
}

//-------------------------------------------
fn @load_cie_uniform_light(math: Intrinsics, data: DeviceBuffer, info: SceneInfo) = @load_cie_sky_light(math, data, info, false);
fn @load_cie_cloudy_light(math: Intrinsics, data: DeviceBuffer, info: SceneInfo)  = @load_cie_sky_light(math, data, info, true);

//-------------------------------------------
fn @make_perez_light(math: Intrinsics, max_radius: f32, sun_dir: Vec3, lum: Color, a: f32, b: f32, c: f32, d: f32, e: f32)  =
    make_environment_light_function(math, max_radius, @|dir|{
        let theta = -dir.y;                 // Cosine between zenith and direction
        let sun_c = vec3_dot(dir, sun_dir); // Cosine between sun and direction
        let sun_a = math.acosf(sun_c);      // Angle between sun and direction

        let A      = if math.fabsf(theta) <= flt_eps { 1 } else { 1 + a * math.expf(b / theta) };
        let B      = 1 + c * math.expf(d * sun_a) + e * sun_c * sun_c;
        let factor = A * B;
        color_mulf(lum, factor)
});

fn @load_perez_light(math: Intrinsics, data: DeviceBuffer, info: SceneInfo) -> Light {
    let e0    = data.load_vec4(0);
    let e1    = data.load_vec4(4);
    let color = vec3_to_color(data.load_vec3(8));
    
    let dir = make_vec3(e0.x, e0.y, e0.z);
    let a   = e0.w;
    let b   = e1.x;
    let c   = e1.y;
    let d   = e1.z;
    let e   = e1.w;
    
    make_perez_light(math, info.scene_radius, dir, color, a, b, c, d, e)
}

//-------------------------------------------
fn @make_camera_light(math: Intrinsics, camera: Camera, color: Color) = Light {
    sample_direct = @ |_, _| {
        let intensity = color_mulf(color, 1.0 / (4.0 * flt_pi));
        make_direct_sample(camera.origin(), intensity, 1.0, uniform_sphere_pdf(), 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(math, u, v);
        let intensity = color_mulf(color, 1.0 / (4.0 * flt_pi));
        make_emission_sample(camera.origin(), sample.dir, intensity, 1.0, sample.pdf, 1.0)
    },
    emission = @ |_, _| make_emission_value(black, 1.0, 1.0),
    delta    = true,
    infinite = false
};

//-------------------------------------------
fn @make_area_light(math: Intrinsics, area: AreaEmitter, color: Color) = Light {
    sample_direct = @ |rnd, from_surf| {
        let (pos, n, area_pdf) = area.sample(make_vec2(randf(rnd), randf(rnd)));
        let dir = vec3_sub(from_surf.point, pos);
        let cos = vec3_dot(dir, n) / vec3_len(math, dir);
        make_direct_sample(pos, color, area_pdf, cosine_hemisphere_pdf(cos), cos)
    },
    sample_emission = @ |rnd| {
        let (pos, n, area_pdf) = area.sample(make_vec2(randf(rnd), randf(rnd)));
        let sample = sample_cosine_hemisphere(math, randf(rnd), randf(rnd));
        make_emission_sample(pos, mat3x3_mul(make_orthonormal_mat3x3(n), sample.dir), color, area_pdf, sample.pdf, sample.dir.z)
    },
    emission = @ |dir, uv_coords| make_emission_value(color, area.pdf(uv_coords), cosine_hemisphere_pdf(vec3_dot(area.normal(uv_coords), dir))),
    delta    = false,
    infinite = false
};

struct LightAccessor {
    shapes:   ShapeTable,
    entities: EntityTable
}

fn @load_area_light(math: Intrinsics, data: DeviceBuffer, acc: LightAccessor) -> Light {
    let e0    = data.load_vec4(0);
    let id    = bitcast[i32](e0.x);
    let color = make_color(e0.y, e0.z, e0.w);

    let entity  = acc.entities(id);
    let shape   = acc.shapes(entity.shape_id);
    let mesh    = shape.mesh;
    let emitter = AreaEmitter {
        sample = @ |uv| {
            let ux  = uv.x * (mesh.num_tris as f32);
            let f   = ux as i32;
            let uv2 = make_vec2(ux - (f as f32), uv.y);
            let (i0, i1, i2) = mesh.triangles(f);
            let v0  = mesh.vertices(i0);
            let v1  = mesh.vertices(i1);
            let v2  = mesh.vertices(i2);
            let n   = mesh.face_normals(f);
            let inv_area = mesh.face_inv_area(f);
            (mat4x4_transform_point(entity.global_mat, sample_triangle(uv2.x, uv2.y, v0, v1, v2)),
             mat3x3_mul(entity.normal_mat, n),
             inv_area)
        },
        normal = @ |uv| {
            let f = (uv.x * (mesh.num_tris as f32)) as i32;
            mat3x3_mul(entity.normal_mat, mesh.face_normals(f))
        },
        pdf = @ |uv| {
            let f = (uv.x * (mesh.num_tris as f32)) as i32;
            mesh.face_inv_area(f)
        }
    };
    make_area_light(math, emitter, color)
}

type LightTable  = fn (i32) -> Light;

fn @make_light_table(math: Intrinsics, dtb: DynTable, info: SceneInfo, acc: DeviceBufferAccessor, lacc: LightAccessor) -> LightTable {
    @ |id| {
        let entry = get_lookup_entry(id as u64, dtb, acc);
        let data  = get_table_entry(entry.offset, dtb, acc);
        match entry.type_id {
            0x00 => load_point_light(math, data, info),                // LIGHT_POINT
            0x01 => load_area_light(math, data, lacc),                 // LIGHT_AREA				   
            0x02 => load_directional_light(math, data, info),          // LIGHT_DIRECTIONAL		   
            0x03 => load_sun_light(math, data, info),                  // LIGHT_SUN				   
            0x04 => load_sky_light(math, data, info),                  // LIGHT_SKY				   
            0x05 => load_sunsky_light(math, data, info),               // LIGHT_SUNSKY			   
            0x10 => load_cie_uniform_light(math, data, info),          // LIGHT_CIE_UNIFORM		   
            0x11 => load_cie_cloudy_light(math, data, info),           // LIGHT_CIE_CLOUDY		   
            0x12 => load_perez_light(math, data, info),                // LIGHT_PEREZ				  
            0x20 => load_environment_light(math, data, info),          // LIGHT_ENVIRONMENT		  
            0x21 => load_environment_textured_light(math, data, info), // LIGHT_ENVIRONMENT_TEXTURED
            _ =>  make_environment_light(math, 0, black)
        }
    } 
}

// Same as before, but assume given id is always a area light
fn @make_arealight_table(math: Intrinsics, dtb: DynTable, acc: DeviceBufferAccessor, lacc: LightAccessor) -> LightTable {
    @ |id| {
        let entry = get_lookup_entry(id as u64, dtb, acc);
        let data  = get_table_entry(entry.offset, dtb, acc);
        load_area_light(math, data, lacc)
    } 
}