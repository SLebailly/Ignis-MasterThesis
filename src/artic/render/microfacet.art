struct MicrofacetSample {
    normal: Vec3,          
    pdf   : f32
}

struct MicrofacetModel {
    D     : fn (Vec3) -> f32,
    G1    : fn (Vec3, Vec3) -> f32,
    sample: fn (&mut RndState, Vec3) -> MicrofacetSample
}

fn @make_aniso_beckmann_model(math: Intrinsics, surf: SurfaceElement, alpha_u: f32, alpha_v: f32) = MicrofacetModel {
    D = @|m| {
        let cosZ = vec3_dot(surf.local.col(2), m);
        let cosX = vec3_dot(surf.local.col(0), m);
        let cosY = vec3_dot(surf.local.col(1), m);

        let kx = cosX / alpha_u;
        let ky = cosY / alpha_v;
        let k2 = (kx * kx + ky * ky) / (cosZ * cosZ);

        let norm  = 1 / (flt_pi * alpha_u * alpha_v * cosZ * cosZ * cosZ * cosZ);
        norm * math.expf(-k2)
    },
    G1 = @|w, m| {
        let cosZ = vec3_dot(surf.local.col(2), w);
        if cosZ * vec3_dot(w, m) <= flt_eps { return(0) };

        let cosX = vec3_dot(surf.local.col(0), w);
        let cosY = vec3_dot(surf.local.col(1), w);

        let kx = alpha_u * cosX;
        let ky = alpha_v * cosY;
        let k2 = (kx * kx + ky * ky) / (cosZ * cosZ);

        if k2 <= flt_eps { return(1) };

        let a  = math.rsqrtf(k2);
        let a2 = 1 / k2;

        if a >= 1.6 { 
            1.0
        } else { 
            (3.535 * a + 2.181 * a2) / (1.0 + 2.276 * a + 2.577 * a2) 
        }
    },
    sample = @ |rnd, _| {
        let u0 = randf(rnd);
        let u1 = randf(rnd);
        
        let ar      = alpha_v / alpha_u;
        let tanPhi  = ar * math.tanf(2 * flt_pi * u1);
        let cosPhi_ = math.sqrtf(1 - tanPhi*tanPhi);
        let cosPhi  = if fabs(u1-0.5) < 0.25 { -cosPhi_ } else { cosPhi_ };
        let sinPhi  = cosPhi * tanPhi;

        let kx = cosPhi / alpha_u;
        let ky = sinPhi / alpha_v;
        let k2 = 1 / (kx * kx + ky * ky);

        let cosTheta  = math.rsqrtf(1 - k2 * math.logf(1.0 - u0));
        let cosTheta2 = cosTheta * cosTheta;
        let sinTheta  = math.sqrtf(1 - cosTheta2);

        let pdf = (1 - u0) / (flt_pi * alpha_u * alpha_v * cosTheta2 * cosTheta);
        let lh  = make_vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta); // Microfacet normal in local shading space
        MicrofacetSample { normal = mat3x3_mul(surf.local, lh), pdf = pdf}
    }
};

///////////////////////////////////

struct MicrofacetDistribution {
    D     : fn (Vec3) -> f32, /* Normal */
    G     : fn (Vec3, Vec3, Vec3) -> f32, /* Wi, Wo, Normal */
    pdf   : fn (Vec3) -> f32, /* Wi, Normal */
    sample: fn (&mut RndState, Vec3) -> MicrofacetSample
}

fn @make_microfacet_distribution(model: MicrofacetModel, surf: SurfaceElement) = MicrofacetDistribution {
    D      = model.D,
    G      = @ |wi, wo, m| model.G1(wi, m) * model.G1(wo, m),
    pdf    = @ |m| model.D(m) * vec3_dot(surf.local.col(2), m),
    sample = model.sample
};

fn @make_beckmann_distribution(math: Intrinsics, surf: SurfaceElement, alpha_u: f32, alpha_v: f32) -> MicrofacetDistribution {
    make_microfacet_distribution(make_aniso_beckmann_model(math, surf, alpha_u, alpha_v), surf)
}

/*fn make_iso_ggx_distribution(math: Intrinsics, surf: SurfaceElement, alpha: f32) -> MicrofacetDistribution {
    let a2 = alpha * alpha;
    MicrofacetDistribution {
        eval = @|wi, wo| {
            let ndotl = vec3_dot(surf.local.col(2), wi);
            let ndotv = vec3_dot(surf.local.col(2), wo);
            let denomA = ndotv * math.sqrtf(a2 + (1.0 - a2) * ndotl * ndotl);
            let denomB = ndotl * math.sqrtf(a2 + (1.0 - a2) * ndotv * ndotv);
            2.0 * ndotl * ndotv / (denomA + denomB)
        },
        pdf = @|wi, wo| { 
            let h = vec3_normalize(math, vec3_add(wi,wo));
            let ndoth = vec3_dot(surf.local.col(2), h);
            1.0 / (flt_pi * a2 * ndoth * ndoth * ndoth * 4)
        },
        sample = @ |rnd, out_dir| {
            let u0 = randf(rnd);
            let u1 = randf(rnd);
            let t2 = a2 * u1 / (1.0 - u1);
            let cosTheta = 1.0/math.sqrtf(1+ t2);
            let sinTheta = math.sqrtf(1.0 - cosTheta * cosTheta);
            let cosPhi   = math.cosf(2.0 * flt_pi * u0);
            let sinPhi   = math.sinf(2.0 * flt_pi * u0);

            let s = 1.0 + u1 / (1.0 - u1);
            let pdf = 1.0 / (flt_pi * a2 * cosTheta * cosTheta * cosTheta * s * s);
            let h = make_vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
            (vec3_reflect(out_dir, h), pdf, 1)
        },
    }
}*/