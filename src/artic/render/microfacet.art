struct MicrofacetSample {
    normal: Vec3,          
    pdf   : f32
}

struct MicrofacetModel {
    D     : fn (Vec3) -> f32,
    G1    : fn (Vec3, Vec3) -> f32,
    sample: fn (&mut RndState) -> MicrofacetSample
}

fn @make_aniso_beckmann_model(math: Intrinsics, surf: SurfaceElement, alpha_u: f32, alpha_v: f32) = MicrofacetModel {
    D = @|m| {
        let cosZ = vec3_dot(surf.local.col(2), m);
        let cosX = vec3_dot(surf.local.col(0), m);
        let cosY = vec3_dot(surf.local.col(1), m);

        let kx = cosX / alpha_u;
        let ky = cosY / alpha_v;
        let k2 = (kx * kx + ky * ky) / (cosZ * cosZ);

        let norm  = 1 / (flt_pi * alpha_u * alpha_v * cosZ * cosZ * cosZ * cosZ);
        norm * math.expf(-k2)
    },
    G1 = @|w, m| { // g 1 walter
        let cosZ = vec3_dot(surf.local.col(2), w);
        if cosZ * vec3_dot(w, m) <= flt_eps { return(0) };

        let cosX = vec3_dot(surf.local.col(0), w);
        let cosY = vec3_dot(surf.local.col(1), w);

        let kx = alpha_u * cosX;
        let ky = alpha_v * cosY;
        let k2 = (kx * kx + ky * ky) / (cosZ * cosZ);

        if k2 <= flt_eps { return(1) };

        let a  = math.rsqrtf(k2);
        let a2 = 1 / k2;

        if a >= 1.6 { 
            1.0
        } else { 
            (3.535 * a + 2.181 * a2) / (1.0 + 2.276 * a + 2.577 * a2) 
        }
    },
    sample = @ |rnd| {
        let u0 = randf(rnd);
        let u1 = randf(rnd);
        
        let ar     = alpha_v / alpha_u;
        let phi    = math.atanf(ar * math.tanf(2 * flt_pi * u1));
        let cosPhi = math.cosf(phi);
        let sinPhi = math.sqrtf(1 - cosPhi*cosPhi);

        let kx = cosPhi / alpha_u;
        let ky = sinPhi / alpha_v;
        let k2 = 1 / (kx * kx + ky * ky);

        let cosTheta  = math.rsqrtf(1 - k2 * math.logf(1.0 - u0));
        let cosTheta2 = cosTheta * cosTheta;
        let sinTheta  = math.sqrtf(1 - cosTheta2);

        let pdf = (1 - u0) / (flt_pi * alpha_u * alpha_v * cosTheta2 * cosTheta);
        let lh  = make_vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta); // Microfacet normal in local shading space
        MicrofacetSample { normal = mat3x3_mul(surf.local, lh), pdf = pdf}
    }
};

fn make_aniso_ggx_model(math: Intrinsics, surf: SurfaceElement, alpha_u: f32, alpha_v: f32) = MicrofacetModel {
    D = @|m| {
        let cosZ = vec3_dot(surf.local.col(2), m); // cosTheta
        let cosX = vec3_dot(surf.local.col(0), m); // cosPhi * sinTheta
        let cosY = vec3_dot(surf.local.col(1), m); // sinPhi * sinTheta

        let kx = cosX / alpha_u;
        let ky = cosY / alpha_v;
        let k2 = (kx * kx + ky * ky) / (cosZ * cosZ);

        let norm = 1 / (flt_pi * alpha_u * alpha_v * cosZ * cosZ * cosZ * cosZ);
        norm * (1 + k2) * (1 + k2)
    },
    G1 = @|w, m| { // g 1 smith

        let cosZ = vec3_dot(surf.local.col(2), w);
        if cosZ * vec3_dot(w, m) <= flt_eps { return(0) };

        let cosX = vec3_dot(surf.local.col(0), w);
        let cosY = vec3_dot(surf.local.col(1), w);

        let kx = alpha_u * cosX;
        let ky = alpha_v * cosY;
        let k2 = (kx * kx + ky * ky) / (cosZ * cosZ);

        if k2 <= flt_eps { return(1) };

        let a  = math.rsqrtf(k2);
        let a2 = 1 / k2;

        if a >= 1.6 { 
            1.0
        } else { 
            (3.535 * a + 2.181 * a2) / (1.0 + 2.276 * a + 2.577 * a2) 
        }
        // let cosZ = vec3_dot(surf.local.col(2), w);
        // if cosZ * vec3_dot(w, m) <= flt_eps { return(0) };

        // let cosX = vec3_dot(surf.local.col(0), w);
        // let cosY = vec3_dot(surf.local.col(1), w);

        // let kx = alpha_u * cosX;
        // let ky = alpha_v * cosY;
        // let k2 = (kx * kx + ky * ky) / (cosZ * cosZ);

        // let denom = 1 + math.sqrtf(1 + k2);
        // if denom <= flt_eps { 0 } else { 2 / denom }
    },
    sample = @ |rnd| {
        let u0 = randf(rnd);
        let u1 = randf(rnd);
        
        let ar     = alpha_v / alpha_u;
        let phi    = math.atanf(ar * math.tanf(2 * flt_pi * u1));
        let cosPhi = math.cosf(phi);
        let sinPhi = math.sqrtf(1 - cosPhi*cosPhi);

        let kx = cosPhi / alpha_u;
        let ky = sinPhi / alpha_v;
        let d2 = kx * kx + ky * ky;
        let a2 = 1 / d2;
        let t2 = a2 * u0 / (1 - u0);

        let cosTheta  = math.rsqrtf(1 + t2);
        let cosTheta2 = cosTheta * cosTheta;
        let sinTheta  = math.sqrtf(1 - cosTheta2);

        let k2  = d2 * (sinTheta * sinTheta) / cosTheta2;
        let pdf = (1 + k2) * (1 + k2) / (flt_pi * alpha_u * alpha_v * cosTheta2 * cosTheta);
        let lh  = make_vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
        MicrofacetSample { normal = mat3x3_mul(surf.local, lh), pdf = pdf}
    }
};
///////////////////////////////////

struct MicrofacetDistribution {
    D     : fn (Vec3) -> f32,             // Normal
    G     : fn (Vec3, Vec3, Vec3) -> f32, // Wi, Wo, Normal
    pdf   : fn (Vec3) -> f32,             // Wi, Normal
    sample: fn (&mut RndState, Vec3) -> MicrofacetSample
}

fn @make_microfacet_distribution(model: MicrofacetModel, surf: SurfaceElement) = MicrofacetDistribution {
    D      = model.D,
    G      = @ |wi, wo, m| model.G1(wi, m) * model.G1(wo, m),
    pdf    = @ |m| model.D(m) * vec3_dot(surf.local.col(2), m),
    sample = @ |rnd, _| model.sample(rnd)
};

fn @make_beckmann_distribution(math: Intrinsics, surf: SurfaceElement, alpha_u: f32, alpha_v: f32) -> MicrofacetDistribution {
    make_microfacet_distribution(make_aniso_beckmann_model(math, surf, alpha_u, alpha_v), surf)
}

fn @make_ggx_distribution(math: Intrinsics, surf: SurfaceElement, alpha_u: f32, alpha_v: f32) -> MicrofacetDistribution {
    make_microfacet_distribution(make_aniso_ggx_model(math, surf, alpha_u, alpha_v), surf)
}
