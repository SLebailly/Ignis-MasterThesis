// Abstract geometry object (tied to one device)
struct Shape {
    // Computes the surface element after an intersection on this geometry
    surface_element: fn (Ray, Hit) -> SurfaceElement
}

struct TriShape {
    num_face: i32,
    num_verts: i32,
    num_norms: i32,
    num_attrs: i32,
    data: &[u8]
}

// Triangle mesh with per-vertex/per-face attributes
struct TriMesh {
    vertices:     fn (i32) -> Vec3,
    normals:      fn (i32) -> Vec3,
    face_normals: fn (i32) -> Vec3,
    face_area:    fn (i32) -> f32,
    triangles:    fn (i32) -> (i32, i32, i32),
    attrs:        fn (i32) -> (bool, fn (i32) -> Vec4),
    num_attrs:    i32,
    num_tris:     i32
}

// Creates a geometry object from a triangle mesh definition
fn @make_trimesh_shape(math: Intrinsics, tri_mesh: TriMesh) = Shape {
    surface_element = @ |local_ray, hit| {
        let (i0, i1, i2) = tri_mesh.triangles(hit.prim_id);

        let face_normal = tri_mesh.face_normals(hit.prim_id);
        let normal = vec3_normalize(math, vec3_lerp2(tri_mesh.normals(i0), tri_mesh.normals(i1), tri_mesh.normals(i2), hit.uv_coords.x, hit.uv_coords.y));
        let is_entering = vec3_dot(local_ray.dir, face_normal) <= 0;

        fn @attr(i: i32) -> Vec4 {
            if i >= tri_mesh.num_attrs {
                make_vec4(0, 0, 0, 0)
            } else {
                let (per_face, attr_value) = tri_mesh.attrs(i);
                if per_face {
                    attr_value(hit.prim_id)
                } else {
                    vec4_lerp2(attr_value(i0), attr_value(i1), attr_value(i2), hit.uv_coords.x, hit.uv_coords.y)
                }
            }
        }

        SurfaceElement {
            is_entering = is_entering,
            point =       vec3_add(local_ray.org, vec3_mulf(local_ray.dir, hit.distance)),
            face_normal = if is_entering { face_normal } else { vec3_neg(face_normal) },
            uv_coords =   hit.uv_coords,
            local =       make_orthonormal_mat3x3(if vec3_dot(local_ray.dir, normal) <= 0 { normal } else { vec3_neg(normal) }),
            attr =        attr
        }
    }
};

type ShapeTable  = fn (i32) -> Shape;

fn @make_shape_table(math: Intrinsics, dtb: DynTable, acc: DeviceBufferAccessor) -> ShapeTable {
    |id| {
        let entry = get_lookup_entry(id as u64, dtb, acc);
        // Type is TriMesh for currently.
        let data  = get_table_entry(entry.offset as u64, dtb, acc);

        ig_host_print("Load: ");
        ig_host_print_i(id as i64);
        ig_host_print("\n");
        let num_face  = data.load_i32(0);
        let num_attrs = data.load_i32(3);
        
        let trimesh = TriMesh { // TODO: This is actually device specific!
            vertices     = |_i:i32| make_vec3(0,0,0),
            normals      = |_i:i32| make_vec3(0,0,1),
            face_normals = |_i:i32| make_vec3(0,0,1),
            face_area    = |_i:i32| 0,
            triangles    = |_i:i32| (0, 1, 2),
            attrs        = |_attr:i32| (false, |_i:i32| make_vec4(0,0,0,0)),
            num_attrs    = num_attrs,
            num_tris     = num_face
        };

        make_trimesh_shape(math, trimesh)
    } 
}