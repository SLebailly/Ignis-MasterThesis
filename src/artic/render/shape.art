// Abstract geometry object (tied to one device)
struct Shape {
    // Computes the surface element after an intersection on this geometry
    surface_element: fn (Ray, Hit) -> SurfaceElement
}

struct TriShape {
    num_face: i32,
    num_verts: i32,
    num_norms: i32,
    num_attrs: i32,
    data: &[u8]
}

// Triangle mesh with per-vertex/per-face attributes
struct TriMesh {
    vertices:     fn (i32) -> Vec3,
    normals:      fn (i32) -> Vec3,
    face_normals: fn (i32) -> Vec3,
    face_area:    fn (i32) -> f32,
    triangles:    fn (i32) -> (i32, i32, i32),
    attrs:        fn (i32) -> (bool, fn (i32) -> Vec4),
    num_attrs:    i32,
    num_tris:     i32
}

// Creates a geometry object from a triangle mesh definition
fn @make_trimesh_shape(math: Intrinsics, tri_mesh: TriMesh) -> Shape {
    let f_tris  = tri_mesh.triangles;
    let f_n     = tri_mesh.normals;
    let f_fn    = tri_mesh.face_normals;
    let f_attrs = tri_mesh.attrs;

    Shape {
        surface_element = @ |local_ray, hit| {
            let (i0, i1, i2) = $f_tris(hit.prim_id);

            let face_normal = @f_fn(hit.prim_id);
            let normal      = vec3_normalize(math, vec3_lerp2(@f_n(i0), @f_n(i1), @f_n(i2), hit.uv_coords.x, hit.uv_coords.y));
            let is_entering = vec3_dot(local_ray.dir, face_normal) <= 0;

            fn @attr(i: i32) -> Vec4 {
                if i >= tri_mesh.num_attrs {
                    make_vec4(0, 0, 0, 0)
                } else {
                    let (per_face, attr_value) = @f_attrs(i);
                    if per_face {
                        attr_value(hit.prim_id)
                    } else {
                        vec4_lerp2(attr_value(i0), attr_value(i1), attr_value(i2), hit.uv_coords.x, hit.uv_coords.y)
                    }
                }
            }

            SurfaceElement {
                is_entering = is_entering,
                point =       vec3_add(local_ray.org, vec3_mulf(local_ray.dir, hit.distance)),
                face_normal = if is_entering { face_normal } else { vec3_neg(face_normal) },
                uv_coords =   hit.uv_coords,
                local =       make_orthonormal_mat3x3(if vec3_dot(local_ray.dir, normal) <= 0 { normal } else { vec3_neg(normal) }),
                attr =        attr
            }
        }
    }
}

type ShapeTable  = fn (i32) -> Shape;

fn @make_shape_table(math: Intrinsics, dtb: DynTable, acc: DeviceBufferAccessor) -> ShapeTable {
    @ |id| {
        let entry = get_lookup_entry(id as u64, dtb, acc);
        // Type is TriMesh for currently.
        let data  = get_table_entry(entry.offset, dtb, acc);

        let (num_face, num_verts, num_norms, num_attrs) = data.load_int4(0);
        
        let v_start    = 4;
        let n_start    = v_start    + num_verts * 4;
        let fn_start   = n_start    + num_norms * 4;
        let ind_start  = fn_start   + num_face  * 4;
        let attr_start = ind_start  + num_face  * 4;
        let fa_start   = attr_start + num_attrs * 4;
        
        let trimesh = TriMesh {
            vertices     = @ |i:i32| data.load_vec3(v_start  + i*4),
            normals      = @ |i:i32| data.load_vec3(n_start  + i*4),
            face_normals = @ |i:i32| data.load_vec3(fn_start + i*4),
            face_area    = @ |i:i32| data.load_f32(fa_start  + i),
            triangles    = @ |i:i32| { let (i0,i1,i2,_) = data.load_int4(ind_start + i*4); (i0, i1, i2) },
            attrs        = @ |_attr:i32| (false, |_i:i32| make_vec4(0,0,0,0)), // TODO
            num_attrs    = num_attrs,
            num_tris     = num_face
        };

        make_trimesh_shape(math, trimesh)
    } 
}