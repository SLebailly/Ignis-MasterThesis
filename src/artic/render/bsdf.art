// Opaque description of a point on a surface
struct SurfaceElement {
    is_entering: bool,  // True if the path enters the surface
    point:       Vec3,  // Point on the surface
    face_normal: Vec3,  // Geometric normal at the surface point
    uv_coords:   Vec2,  // UV coordinates on the surface
    tex_coords:  Vec2,  // Vertex attributes (interpolated)
    local:       Mat3x3 // Local coordinate system at the surface point
}

fn @invert_surface_element(surf: SurfaceElement) = SurfaceElement {
    is_entering = !surf.is_entering,
    point       = surf.point,
    face_normal = vec3_neg(surf.face_normal),
    uv_coords   = surf.uv_coords,
    tex_coords  = surf.tex_coords,
    local       = flip_orthonormal_mat3x3(surf.local)
};

// Map local surface element to global surface element based on the given entity
fn @map_surface_element(math: Intrinsics, surf: SurfaceElement, global_mat: Mat4x4, normal_mat: Mat3x3) = SurfaceElement {
    is_entering = surf.is_entering,
    point       = mat4x4_transform_point(global_mat, surf.point),
    face_normal = vec3_normalize(math, mat3x3_mul(normal_mat, surf.face_normal)),
    uv_coords   = surf.uv_coords,
    tex_coords  = surf.tex_coords,
    local       = mat3x3_normalize_cols(math, mat3x3_matmul(normal_mat, surf.local))
};

// Result of sampling a BSDF
struct BsdfSample {
    in_dir: Vec3,  // Sampled direction
    pdf:    f32,   // BSDF value for the sample
    cos:    f32,   // Cosine between the sampled direction and the surface normal
    color:  Color  // Color of the sample, with cosine and pdf already applied
}

// Opaque BSDF structure
struct Bsdf {
    // Evaluates the reflectance of the material for the given pair of directions, the cosine term is already applied
    eval: fn (Vec3, Vec3) -> Color,
    // Evaluates the sampling probability density for a given pair of directions
    pdf: fn (Vec3, Vec3) -> f32,
    // Samples a direction
    sample: fn (&mut RndState, Vec3, bool) -> BsdfSample,
    // Returns true if the material is purely specular
    is_specular: bool
}

// Creates a BSDF sample and checks that it lies on the right side of the surface
fn @make_bsdf_sample(surf: SurfaceElement, in_dir: Vec3, pdf: f32, cos: f32, color: Color, inverted: bool) -> BsdfSample {
    // Checks that the sample is above the surface (or under it if inverted is true)
    let valid = (pdf > 0) && (inverted ^ (vec3_dot(in_dir, surf.face_normal) > 0));
    BsdfSample {
        in_dir = in_dir,
        pdf    = if valid { pdf } else { 1 },
        cos    = cos,
        color  = if valid { color } else { black }
    }
}

fn @reject_bsdf_sample() = BsdfSample {
    in_dir = make_vec3(0,0,1),
    pdf    = 0,
    cos    = 0,
    color  = black
};

// Weight pdf and color based on respective factors
fn @bsdf_sample_mulf(sample: BsdfSample, pdf_f: f32, color_f: f32) = BsdfSample {
    in_dir = sample.in_dir,
    pdf    = sample.pdf * pdf_f,
    cos    = sample.cos,
    color  = color_mulf(sample.color, color_f)
};

// Creates a fully absorbing BSDF that behaves like a black body
fn @make_black_bsdf() = Bsdf {
    eval =   @ |_, _| black,
    pdf  =   @ |_, _| 0,
    sample = @ |_, _, _| reject_bsdf_sample(),
    is_specular = false
};

//--------------------------------------
// Creates a purely two-sided diffuse BSDF
fn @make_diffuse_bsdf(math: Intrinsics, surf: SurfaceElement, kd: Color) = Bsdf {
    eval = @ |in_dir, _| color_mulf(kd, positive_cos(in_dir, surf.local.col(2)) / flt_pi),
    pdf = @ |in_dir, _| cosine_hemisphere_pdf(positive_cos(in_dir, surf.local.col(2))),
    sample = @ |rnd, _, _| {
        let sample = sample_cosine_hemisphere(math, randf(rnd), randf(rnd));
        let gdir   = vec3_normalize(math, mat3x3_mul(surf.local, sample.dir));
        make_bsdf_sample(surf, if surf.is_entering { gdir } else { vec3_neg(gdir) }, sample.pdf, sample.dir.z, kd, false)
    },
    is_specular = false
};

fn @load_diffuse_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let kd = vec3_to_color(data.load_vec3(0));
    make_diffuse_bsdf(math, surf, kd)
}

//--------------------------------------
// Creates a two-sided BSDF based on orennayar
fn @make_orennayar_bsdf(math: Intrinsics, surf: SurfaceElement, alpha: f32, kd: Color) -> Bsdf {
    let a2 = alpha * alpha;
    let eval = @ |in_dir : Vec3, out_dir : Vec3| {
        let p1 = positive_cos(in_dir, surf.local.col(2));
        let p2 = positive_cos(out_dir, surf.local.col(2));
        let s  = -p1 * p2 + positive_cos(out_dir, in_dir);
        let t  = if s <= flt_eps { 1 } else { math.fmaxf(flt_eps, math.fmaxf(p1, p2)) };

        let A = 1 - 0.5 * a2 / (a2 + 0.33);
        let B = 0.45 * a2 / (a2 + 0.09);
        let C = 0.17 * a2 / (a2 + 0.13); // Correction term
        color_mulf(color_add(color_mulf(kd, (A + (B * s / t)) / flt_pi), color_mul(kd, color_mulf(kd, C / flt_pi))), p1)
    };

    Bsdf {
        eval = eval,
        pdf = @ |in_dir, _| cosine_hemisphere_pdf(positive_cos(in_dir, surf.local.col(2))),
        sample = @ |rnd, out_dir, _| {
            let sample = sample_cosine_hemisphere(math, randf(rnd), randf(rnd));
            let gdir   = mat3x3_mul(surf.local, sample.dir);
            make_bsdf_sample(surf, if surf.is_entering { gdir } else { vec3_neg(gdir) }, sample.pdf, sample.dir.z, color_mulf(eval(gdir, out_dir), 1/sample.pdf), false)
        },
        is_specular = false
    }
}

fn @load_orennayar_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let e0 = data.load_vec4(0);
    let kd = make_color(e0.x, e0.y, e0.z);
    let alpha = e0.w;

    make_orennayar_bsdf(math, surf, alpha, kd)
}

//--------------------------------------
// Creates a physically-correct Phong BSDF
fn @make_phong_bsdf(math: Intrinsics, surf: SurfaceElement, ks: Color, ns: f32) = Bsdf {
    eval = @ |in_dir, out_dir| {
        let cosI = positive_cos(in_dir, surf.local.col(2));
        let cos  = positive_cos(in_dir, vec3_reflect(out_dir, surf.local.col(2)));
        color_mulf(ks, cosI * fastpow/*math.powf*/(cos, ns) * (ns + 2) / (2 * flt_pi))
    },
    pdf = @ |in_dir, out_dir| {
        let cos = positive_cos(in_dir, vec3_reflect(out_dir, surf.local.col(2)));
        cosine_power_hemisphere_pdf(math, cos, ns)
    },
    sample = @ |rnd, out_dir, _| {
        let reflect_out = vec3_reflect(out_dir, surf.local.col(2));
        let sample      = sample_cosine_power_hemisphere(math, ns, randf(rnd), randf(rnd));
        let in_dir      = mat3x3_mul(make_orthonormal_mat3x3(reflect_out), sample.dir);
        let cos         = positive_cos(in_dir, surf.local.col(2));
        let color       = color_mulf(ks, (ns + 2) / (ns + 1));
        make_bsdf_sample(surf, in_dir, sample.pdf, cos, color, false)
    },
    is_specular = false
};

fn @load_phong_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let e0 = data.load_vec4(0);
    let ks = make_color(e0.x, e0.y, e0.z);
    let ns = e0.w;

    make_phong_bsdf(math, surf, ks, ns)
}

//--------------------------------------
// Creates a plastic bsdf based on Fresnel equation (which is just a variadic mix bsdf with extra diffuse term)
fn @make_plastic_bsdf(math: Intrinsics, surf: SurfaceElement, n1: f32, n2: f32, ks: Color, kd: Color) -> Bsdf {
    // Layered BSDF
    let diffuse = make_diffuse_bsdf(math, surf, kd);
    let mirror  = make_mirror_bsdf(math, surf, ks);

    let N   = surf.local.col(2);
    let eta = n1 / n2; // Some systems use n2 / n1 for eta
    // Calculate approximate diffuse Fresnel reflectance
    let fdr = fresnel_diffuse_factor(eta);

    // Diffuse inner scattering term
    let diff_scattering = @|cos_i : f32| {
        let fi = fresnel(math, eta, cos_i);
         (1 - fi.factor) * eta * eta / (1 - fdr)
    };

    // Apply inner scattering term to diffuse bsdf
    let diffuse_extra = Bsdf {
        eval   = @ |in_dir, out_dir| {
            let cos_i = positive_cos(in_dir, N);
            color_mulf(diffuse.eval(in_dir, out_dir), diff_scattering(cos_i))
        },
        pdf    = diffuse.pdf,
        sample = @ |rnd, out_dir, adjoint| {
            let s = diffuse.sample(rnd, out_dir, adjoint);
            BsdfSample { in_dir = s.in_dir, pdf = s.pdf, cos = s.cos, color = color_mulf(s.color,  diff_scattering(s.cos)) }
        },
        is_specular = diffuse.is_specular
    };

    // Fresnel based mix function
    let mix_f = @|out_dir : Vec3| -> f32 {
        let cos_o = positive_cos(out_dir, N);
        let fo    = fresnel(math, eta, cos_o);
        fo.factor
    };

    make_variadic_mix_bsdf(diffuse_extra, mirror, mix_f)
}

fn @load_plastic_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let e0 = data.load_vec4(0);
    let e1 = data.load_vec4(4);
    let ks = make_color(e0.x, e0.y, e0.z);
    let n1 = e0.w;
    let kd = make_color(e1.x, e1.y, e1.z);
    let n2 = e1.w;

    make_plastic_bsdf(math, surf, n1, n2, ks, kd)
}

//--------------------------------------
// Creates a perfect mirror BSDF
fn @make_mirror_bsdf(_math: Intrinsics, surf: SurfaceElement, ks: Color) = Bsdf {
    eval   = @ |_, _| black,
    pdf    = @ |_, _| 0,
    sample = @ |_, out_dir, _| {
        make_bsdf_sample(surf, vec3_reflect(out_dir, surf.local.col(2)), 1, 1, ks, false)
    },
    is_specular = true
};

fn @load_mirror_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let ks = vec3_to_color(data.load_vec3(0));
    make_mirror_bsdf(math, surf, ks)
}

//--------------------------------------
// Creates a perfect glass BSDF
fn @make_glass_bsdf(math: Intrinsics, surf: SurfaceElement, n1: f32, n2: f32, ks: Color, kt: Color) = Bsdf {
    eval   = @ |_, _| black,
    pdf    = @ |_, _| 0,
    sample = @ |rnd, out_dir, adjoint| {
        let k = if surf.is_entering { n1 / n2 } else { n2 / n1 };
        let n = surf.local.col(2);
        let cos_i = vec3_dot(out_dir, n);

        let fterm = fresnel(math, k, cos_i);

        if !fterm.total {
            // Refraction
            let cos_t = fterm.cos_t;
            let F     = fterm.factor;
            if (randf(rnd) > F) {
                let t = vec3_sub(vec3_mulf(n, k * cos_i - cos_t), vec3_mulf(out_dir, k));
                let adjoint_term = if adjoint { k * k } else { 1 };
                return(make_bsdf_sample(surf, t, 1, 1, color_mulf(kt, adjoint_term), true))
            }
        }
        // Reflection
        make_bsdf_sample(surf, vec3_reflect(out_dir, n), 1, 1, ks, false)
    },
    is_specular = true
};

fn @load_glass_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let e0 = data.load_vec4(0);
    let e1 = data.load_vec4(4);
    let ks = make_color(e0.x, e0.y, e0.z);
    let n1 = e0.w;
    let kt = make_color(e1.x, e1.y, e1.z);
    let n2 = e1.w;

    make_glass_bsdf(math, surf, n1, n2, ks, kt)
}

//--------------------------------------
// Creates a perfect glass BSDF with thin interface approximation
fn @make_thin_glass_bsdf(math: Intrinsics, surf: SurfaceElement, n1: f32, n2: f32, ks: Color, kt: Color) = Bsdf {
    eval   = @ |_, _| black,
    pdf    = @ |_, _| 0,
    sample = @ |rnd, out_dir, _| {
        let k = if surf.is_entering { n1 / n2 } else { n2 / n1 };
        let N = surf.local.col(2);
        let cos_i = positive_cos(out_dir, N);

        let fterm = fresnel(math, k, cos_i);
        let F = /*if fterm.factor < 1.0 {*/ fterm.factor + (1 - fterm.factor) * fterm.factor / (fterm.factor + 1) /*} else { 1.0 }*/;

        if randf(rnd) > F {
            // Refraction
            make_bsdf_sample(surf, vec3_neg(out_dir), 1, 1, kt, true)
        } else {
            // Reflection
            make_bsdf_sample(surf, vec3_reflect(out_dir, N), 1, 1, ks, false)
        }
    },
    is_specular = true
};

fn @load_thin_glass_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let e0 = data.load_vec4(0);
    let e1 = data.load_vec4(4);
    let ks = make_color(e0.x, e0.y, e0.z);
    let n1 = e0.w;
    let kt = make_color(e1.x, e1.y, e1.z);
    let n2 = e1.w;

    make_thin_glass_bsdf(math, surf, n1, n2, ks, kt)
}

//--------------------------------------
// Creates a perfect conductor BSDF
fn @make_conductor_bsdf(_math: Intrinsics, surf: SurfaceElement, ior: f32, k: f32, ks: Color) = Bsdf {
    eval   = @ |_, _| black,
    pdf    = @ |_, _| 0,
    sample = @ |_, out_dir, _| {
        let n = surf.local.col(2);
        let cos_i = vec3_dot(out_dir, n);

        let f = conductor_factor(ior, k, cos_i);

        let color = color_mulf(ks, f);
        make_bsdf_sample(surf, vec3_reflect(out_dir, n), 1, 1, color, false)
    },
    is_specular = true
};

fn @load_conductor_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let e0  = data.load_vec4(0);
    let e1  = data.load_vec4(4);
    let ks  = make_color(e0.x, e0.y, e0.z);
    let ior = e1.x;
    let k   = e1.y;

    make_conductor_bsdf(math, surf, ior, k, ks)
}

//--------------------------------------
// Creates a microfacet conductor BSDF. This is the front version
fn @make_rough_conductor_bsdf_front(math: Intrinsics, surf: SurfaceElement, ior: f32, k: f32, ks: Color, micro: MicrofacetDistribution) -> Bsdf {
    let N = surf.local.col(2);
    Bsdf {
        eval   = @ |in_dir, out_dir| {
            let cos_o = positive_cos(out_dir, N);
            let cos_i = positive_cos(in_dir, N);

            if cos_o <= flt_eps || cos_i <= flt_eps { return(black) }

            let H  = vec3_halfway(math, in_dir, out_dir);
            let D  = micro.D(H);
            let G  = micro.G(in_dir, out_dir, H);
            let F  = conductor_factor(ior, k, positive_cos(out_dir, H));
            color_mulf(ks, F * D * G / (4 * cos_o))
        },
        pdf    = @ |in_dir, out_dir| {
            let H     = vec3_halfway(math, in_dir, out_dir);
            let dot   = positive_cos(in_dir, H);
            let jacob = 1 / (4 * dot); // Jacobian of the half-direction mapping
            if dot <= flt_eps { return(0) } else { micro.pdf(H) * jacob }
        },
        sample = @ |rnd, out_dir, _| {
            let cos_o   = positive_cos(out_dir, N);
            if cos_o <= flt_eps { return(reject_bsdf_sample()) };

            let s      = micro.sample(rnd, out_dir);
            if vec3_len2(s.normal) <= flt_eps { return(reject_bsdf_sample()) };

            let H      = vec3_normalize(math, s.normal);
            let in_dir = vec3_reflect(out_dir, H);

            let cos_i   = positive_cos(in_dir, N);
            if cos_i <= flt_eps { return(reject_bsdf_sample()) };

            let cos_h   = positive_cos(H, N);
            let cos_h_o = positive_cos(out_dir, H); // = cos_h_i
            if cos_h_o <= flt_eps || cos_h <= flt_eps { return(reject_bsdf_sample()) };

            let jacob   = 1 / (4 * cos_h_o); // Jacobian of the half-direction mapping

            let G = micro.G(in_dir, out_dir, H);
            let F = conductor_factor(ior, k, cos_h_o);

            let color = color_mulf(ks, F * G / (4 * cos_o * cos_h));
            make_bsdf_sample(surf, in_dir, s.pdf * jacob, cos_i, color, false)
        },
        is_specular = false
    }
}

// Creates a microfacet conductor BSDF. This is the two-sided version
fn @make_rough_conductor_bsdf(math: Intrinsics, surf: SurfaceElement, ior: f32, k: f32, ks: Color, micro: MicrofacetDistribution) -> Bsdf {
    if !surf.is_entering { 
        make_rough_conductor_bsdf_front(math, invert_surface_element(surf), ior, k, ks, micro)
    } else { 
        make_rough_conductor_bsdf_front(math, surf, ior, k, ks, micro)
    }
}

fn @load_rough_conductor_bsdf(math: Intrinsics, data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    let e0  = data.load_vec4(0);
    let e1  = data.load_vec4(4);
    let ks  = make_color(e0.x, e0.y, e0.z);

    let ior = e1.x;
    let k   = e1.y;
    let alpha_u = e1.z;
    let alpha_v = e1.w;

    make_rough_conductor_bsdf(math, surf, ior, k, ks, make_beckmann_distribution(math, surf, alpha_u, alpha_v))
}

//--------------------------------------
// Creates a BSDF that passthroughs all rays and behaves like a refractive interface with ior=1
fn @make_passthrough_bsdf(surf: SurfaceElement) = Bsdf {
    eval        = @ |_, _| black,
    pdf         = @ |_, _| 0,
    sample      = @ |_, out_dir, _| make_bsdf_sample(surf, vec3_neg(out_dir), 1, 1, white, true),
    is_specular = true
};

fn @load_passthrough_bsdf(_math: Intrinsics, _data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    make_passthrough_bsdf(surf)
}

//--------------------------------------
// Creates a BSDF that interpolates between two other BSDFs based on a variadic mix function
fn @make_variadic_mix_bsdf(mat1: Bsdf, mat2: Bsdf, mix_f: fn(Vec3) -> f32) = Bsdf {
    eval = @ |in_dir, out_dir| {
        let k = mix_f(out_dir);
        color_lerp(mat1.eval(in_dir, out_dir),
                   mat2.eval(in_dir, out_dir),
                   k)
    },
    pdf = @ |in_dir, out_dir| {
        let k = mix_f(out_dir);
        lerp(mat1.pdf(in_dir, out_dir),
             mat2.pdf(in_dir, out_dir),
             k)
    },
    sample = @ |rnd, out_dir, adjoint| {
        let k = mix_f(out_dir);
        let (sample, pdf, color) = if randf(rnd) >= k {
            let s = mat1.sample(rnd, out_dir, adjoint);
            let p = lerp(s.pdf, mat2.pdf(s.in_dir, out_dir), k);
            let c = color_lerp(s.color, mat2.eval(s.in_dir, out_dir), k);
            (s, p, c)
        } else {
            let s = mat2.sample(rnd, out_dir, adjoint);
            let p = lerp(mat1.pdf(s.in_dir, out_dir), s.pdf, k);
            let c = color_lerp(mat1.eval(s.in_dir, out_dir), s.color, k);
            (s, p, c)
        };
        BsdfSample { in_dir = sample.in_dir, pdf = pdf, cos = sample.cos, color = color }
    },
    is_specular = mat1.is_specular & mat2.is_specular
};

// Creates a BSDF that interpolates between two other BSDFs
fn @make_mix_bsdf(mat1: Bsdf, mat2: Bsdf, k: f32) = make_variadic_mix_bsdf(mat1, mat2, @|_| k);

fn @load_blend_bsdf(_math: Intrinsics, _data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    /*
    let (b0, b1, w)  = data.load_int3(0);
    
    let weight = bitcast[f32](w);
    
    let bsdf0 = $get_shader_loader(b0 as u32);
    let bsdf1 = $get_shader_loader(b1 as u32);
    make_mix_bsdf(bsdf0(math, data, ray, hit, surf), bsdf1(math, data, ray, hit, surf), weight)
    */
    // TODO
    make_passthrough_bsdf(surf)
}

//--------------------------------------
fn @load_mask_bsdf(_math: Intrinsics, _data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    // TODO
    make_passthrough_bsdf(surf)
}

//--------------------------------------
fn @shading_normal_adjoint(in_dir: Vec3, out_dir: Vec3, ns: Vec3, ng: Vec3) -> f32 {
    let ons = positive_cos(out_dir, ns);
    let ins = positive_cos(in_dir, ns);
    let ong = positive_cos(out_dir, ng);
    let ing = positive_cos(in_dir, ng);
    if ins <= flt_eps || ong <= flt_eps { 0 } else { (ons/ins) * (ing/ong) }
}

// Normal Mapping
fn @make_normalmap(math: Intrinsics, surf: SurfaceElement, bsdf_factory: fn (SurfaceElement) -> Bsdf, normal: Color) -> Bsdf {
    let N    = vec3_normalize(math, mat3x3_mul(mat3x3_transpose(surf.local), vec3_normalize(math, make_vec3(normal.r, normal.g, normal.b))));
    let bsdf = @bsdf_factory(SurfaceElement{
        is_entering = surf.is_entering,
        point       = surf.point,
        face_normal = surf.face_normal,
        uv_coords   = surf.uv_coords,
        tex_coords  = surf.tex_coords,
        local       = make_orthonormal_mat3x3(N)
    });

    Bsdf {
        eval        = bsdf.eval,
        pdf         = bsdf.pdf,
        sample      = @ |rnd, out_dir, adjoint| {
            let s = bsdf.sample(rnd, out_dir, adjoint);
            if adjoint {
                let fac = shading_normal_adjoint(s.in_dir, out_dir, N, surf.local.col(2));
                BsdfSample { in_dir = s.in_dir, pdf = s.pdf, cos = s.cos /*TODO: Really?*/, color = color_mulf(s.color, fac) }
            } else {
                s
            }
        },
        is_specular = bsdf.is_specular
    }
}

fn @load_normalmap_bsdf(_math: Intrinsics, _data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    // TODO
    make_passthrough_bsdf(surf)
}

//--------------------------------------
// Bump Mapping
fn @make_bumpmap(math: Intrinsics, surf: SurfaceElement, bsdf_factory: fn (SurfaceElement) -> Bsdf, dx: f32, dy: f32, strength: f32) -> Bsdf {
    let N = vec3_normalize(math, vec3_sub(surf.local.col(2), vec3_mulf(vec3_add(vec3_mulf(surf.local.col(0), dx), vec3_mulf(surf.local.col(1), dy)), strength)));
    let bsdf = @bsdf_factory(SurfaceElement{
        is_entering = surf.is_entering,
        point       = surf.point,
        face_normal = surf.face_normal,
        uv_coords   = surf.uv_coords,
        tex_coords  = surf.tex_coords,
        local       = make_orthonormal_mat3x3(N)
    });

    Bsdf {
        eval        = bsdf.eval,
        pdf         = bsdf.pdf,
        sample      = @ |rnd, out_dir, adjoint| {
            let s = bsdf.sample(rnd, out_dir, adjoint);
            if adjoint {
                let fac = shading_normal_adjoint(s.in_dir, out_dir, N, surf.local.col(2));
                BsdfSample { in_dir = s.in_dir, pdf = s.pdf, cos = s.cos /*TODO: Really?*/, color = color_mulf(s.color, fac) }
            } else {
                s
            }
        },
        is_specular = bsdf.is_specular
    }
}

fn @load_bumpmap_bsdf(_math: Intrinsics, _data: DeviceBuffer, _ray: Ray, _hit: Hit, surf: SurfaceElement) -> Bsdf {
    // TODO
    make_passthrough_bsdf(surf)
}

type ShaderTable = fn (i32) -> Shader;

fn @make_shader_table(math: Intrinsics, dtb: DynTable, acc: DeviceBufferAccessor) -> ShaderTable {
    @ |id| {
        let entry = get_lookup_entry(id as u64, dtb, acc);
        let data  = get_table_entry(entry.offset, dtb, acc);

        @|ray, hit, surf| {
            match entry.type_id {
                0x00 => load_diffuse_bsdf(math, data, ray, hit, surf),         // BSDF_DIFFUSE		  
                0x01 => load_orennayar_bsdf(math, data, ray, hit, surf),       // BSDF_ORENNAYAR		  
                0x02 => load_glass_bsdf(math, data, ray, hit, surf),           // BSDF_DIELECTRIC		  
                //0x03 => load_rough_dielectric_bsdf(math, data, ray, hit, surf), // BSDF_ROUGH_DIELECTRIC 
                0x04 => load_thin_glass_bsdf(math, data, ray, hit, surf),      // BSDF_THIN_DIELECTRIC  
                0x05 => load_mirror_bsdf(math, data, ray, hit, surf),          // BSDF_MIRROR			  
                0x06 => load_conductor_bsdf(math, data, ray, hit, surf),       // BSDF_CONDUCTOR		  
                0x07 => load_rough_conductor_bsdf(math, data, ray, hit, surf), // BSDF_ROUGH_CONDUCTOR  
                0x10 => load_plastic_bsdf(math, data, ray, hit, surf),         // BSDF_PLASTIC		  
                0x11 => load_phong_bsdf(math, data, ray, hit, surf),           // BSDF_PHONG			  
                0x12 => load_disney_bsdf(math, data, ray, hit, surf),          // BSDF_DISNEY			  
                0x20 => load_blend_bsdf(math, data, ray, hit, surf),           // BSDF_BLEND			  
                0x21 => load_mask_bsdf(math, data, ray, hit, surf),            // BSDF_MASK			  
                0x22 => load_passthrough_bsdf(math, data, ray, hit, surf),     // BSDF_PASSTROUGH		  
                0x30 => load_normalmap_bsdf(math, data, ray, hit, surf),       // BSDF_NORMAL_MAP		  
                0x31 => load_bumpmap_bsdf(math, data, ray, hit, surf),         // BSDF_BUMP_MAP		  
                //0x40 => load_klems_bsdf(math, data, ray, hit, surf),           // BSDF_KLEMS		
                _    => make_black_bsdf()
            }
        }
    } 
}