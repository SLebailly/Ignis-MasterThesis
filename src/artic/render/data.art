struct LookupEntry {
    type_id: u32, // Type ID depends on the actual dyntable usecase
    offset:  u32  // Offset to start of the DynTable in bytes (should be u64 to fit the functions)
}

// TODO: Prolly the mother of all cache misses :O
struct DynTable {
    count:  u64,            // Entry counts
    header: &[LookupEntry], // Pointer to an array of lookup entries
    size:   u64,            // Size in bytes of the buffer 'start' is pointing to
    start:  &[u8]           // Pointer to an buffer of size 'size'
}

fn @get_lookup_entry(ind: u64, tbl: &DynTable) -> LookupEntry {
    // TODO: Check boundaries
    tbl.header(ind)
}

fn @get_table_entry[T](off: u64, tbl: &DynTable) -> &T {
    // TODO: Check boundaries
    (&tbl.start(off)) as &T
}

struct SceneDatabase {
    shapes:   DynTable,
    entities: DynTable,
    lights:   DynTable,
    shaders:  DynTable,
    bvhs:     DynTable
}

struct SceneAccessor {
    shapes:   ShapeTable, // Defined in shape.art
    entities: EntityTable,// Defined in entity.art
    lights:   LightTable, // Defined in light.art
    shaders:  ShaderTable,// Defined in material.art
    bvhs:     BVHTable    // Defined in intersection.art
}

fn @make_scene_accessor(math: Intrinsics, database: &SceneDatabase) = SceneAccessor {
    shapes   = make_shape_table(math, database.shapes),   // Defined in shape.art
    entities = make_entity_table(database.entities),      // Defined in entity.art
    lights   = make_light_table(math, database.lights),   // Defined in light.art
    shaders  = make_shader_table(math, database.shaders), // Defined in material.art
    bvhs     = make_bvh_table(database)                   // Defined in intersection.art
};
