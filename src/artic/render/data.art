struct LookupEntry {
    type_id: u32, // Type ID depends on the actual dyntable usecase
    offset:  u32  // Offset to start of the DynTable in bytes (should be u64 to fit the functions)
}

// TODO: Prolly the mother of all cache misses :O
struct DynTable {
    count:  u64,            // Entry counts
    header: &[LookupEntry], // Pointer to an array of lookup entries
    size:   u64,            // Size in bytes of the buffer 'start' is pointing to
    start:  &[u8]           // Pointer to an buffer of size 'size'
}

struct SceneDatabase {
    shapes:   DynTable,
    entities: DynTable,
    lights:   DynTable,
    shaders:  DynTable,
    bvhs:     DynTable
}

struct SceneAccessor {
    shapes:   ShapeTable, // Defined in shape.art
    entities: EntityTable,// Defined in entity.art
    lights:   LightTable, // Defined in light.art
    shaders:  ShaderTable,// Defined in material.art
    bvhs:     BVHTable    // Defined in intersection.art
}

type DeviceBufferAccessor = fn (&[u8]) -> DeviceBuffer;
fn @get_lookup_entry(ind: u64, tbl: &DynTable, acc: DeviceBufferAccessor) -> LookupEntry {
    // TODO: Check boundaries
    let data = acc(&tbl.header(ind) as &[u8]);
    LookupEntry {
        type_id = data.load_i32(0) as u32,
        offset  = data.load_i32(1) as u32
    }
}

fn @get_table_ptr(off: u64, tbl: &DynTable) -> &[u8] {
    // TODO: Check boundaries
    &tbl.start(off) as &[u8]
}

fn @get_table_entry(off: u64, tbl: &DynTable, acc: DeviceBufferAccessor) -> DeviceBuffer {
    // TODO: Check boundaries
    acc(get_table_ptr(off, tbl))
}