struct PathTracer {
    on_emit:   RayEmitter,
    on_hit:    fn (Ray, Hit, &mut RayState, SurfaceElement, Material) -> Option[Color],
    on_nonhit: fn (Ray, &mut RayState) -> Option[Color],
    on_shadow: fn (Ray, Hit, &mut RayState, SurfaceElement, Material) -> Option[(Ray, Color)],
    on_bounce: fn (Ray, Hit, &mut RayState, SurfaceElement, Material) -> Option[(Ray, RayState)],
}

struct RayState {
    rnd:     RndState,
    contrib: Color,
    mis:     f32,
    depth:   i32
}

type RayEmitter = fn (i32, i32, i32, i32, i32) -> (Ray, RayState);
type RayEmitterFactory = fn (Scene, Device, i32) -> RayEmitter;

fn @make_ray_state(rnd: RndState, contrib: Color, mis: f32, depth: i32) -> RayState {
    RayState {
        rnd = rnd,
        contrib = contrib,
        mis = mis,
        depth = depth
    }
}

fn @make_camera_emitter() -> RayEmitterFactory {
    @ |scene, _device, iter| -> RayEmitter {
        @ |sample, x, y, width, height| {
            let mut hash = fnv_init();
            hash = fnv_hash(hash, sample as u32);
            hash = fnv_hash(hash, iter as u32);
            hash = fnv_hash(hash, x as u32);
            hash = fnv_hash(hash, y as u32);
            let mut rnd = hash /*as RndState*/;
            let kx = 2 * (x as f32 + randf(&mut rnd)) / (width  as f32) - 1;
            let ky = 1 - 2 * (y as f32 + randf(&mut rnd)) / (height as f32);
            let ray = scene.camera.generate_ray(kx, ky);
            let state = make_ray_state(rnd, white, 0, 0);
            (ray, state)
        }
    }
}

fn @make_list_emitter(ray_count: i32, rays: &[Ray]) -> RayEmitterFactory {
    @ |_scene, _device, iter| -> RayEmitter {
        @ |sample, x, y, width, _height| {
            let mut hash = fnv_init();
            hash = fnv_hash(hash, sample as u32);
            hash = fnv_hash(hash, iter as u32);
            hash = fnv_hash(hash, x as u32);
            hash = fnv_hash(hash, y as u32);
            let rnd = hash /*as RndState*/;
            let id = y*width + x;
            let ray = if id < ray_count { rays(id) } else { rays(0) };
            let state = make_ray_state(rnd, white, 0, 0);
            (ray, state)
        }
    }
}

fn @make_debug_renderer(emitter: RayEmitterFactory) -> Renderer {
    @ |scene, device, iter| {
        let path_tracer = PathTracer {
            on_emit   = emitter(scene, device, iter),
            on_hit    = @ |_ray, _hit, _state, surf, _mat| {
                let n = surf.local.col(2);
                make_option(make_color(abs(n.x), abs(n.y), abs(n.z)))
            },
            on_nonhit = @ |_, _| Option[(Color)]::None,
            on_shadow = @ |_, _, _, _, _| Option[(Ray, Color)]::None,
            on_bounce = @ |_, _, _, _, _| Option[(Ray, RayState)]::None,
        };

        device.trace(scene, path_tracer, 1);
    }
}

fn @make_path_tracing_renderer(max_path_len: i32, spp: i32, emitter: RayEmitterFactory) -> Renderer {
    @ |scene, device, iter| {
        let offset : f32 = 0.001;
        let pdf_lightpick = 1 / (scene.num_lights as f32);

        let on_emit = emitter(scene, device, iter);

        fn @on_shadow( ray: Ray
                     , _hit: Hit
                     , state: &mut RayState
                     , surf: SurfaceElement
                     , mat: Material
                     ) -> Option[(Ray, Color)] {
            // No shadow rays for specular materials
            if mat.bsdf.is_specular {
                return(Option[(Ray, Color)]::None)
            }

            let rnd = &mut state.rnd;
            // Note: randi() returns random integers, but we only want positive integers here
            let light_id = (randi(rnd) & 0x7FFFFFFF) % scene.num_lights;
            let lights = scene.lights;
            let light = @lights(light_id);
            let sample_direct = light.sample_direct;
            let light_sample = @sample_direct(rnd, surf.point);
            if light.infinite {
                let light_dir = light_sample.pos;
                let vis = vec3_dot(light_dir, surf.local.col(2));

                if vis > flt_eps {
                    let in_dir = light_dir;
                    let out_dir = vec3_neg(ray.dir);

                    let pdf_e = mat.bsdf.pdf(in_dir, out_dir);
                    let pdf_l = light_sample.pdf_dir * pdf_lightpick;
                    let inv_pdf_l = 1 / pdf_l;

                    let mis = if light.has_area { 1 / (1 + pdf_e * inv_pdf_l) } else { 1 };
                    let cos_e = vis;

                    let contrib = color_mul(light_sample.intensity, color_mul(state.contrib, mat.bsdf.eval(in_dir, out_dir)));
                    return(make_option(
                        make_ray(surf.point, light_dir, offset, 1 - offset),
                        color_mulf(contrib, cos_e * mis)
                    ))
                }
            } else {
                let light_dir = vec3_sub(light_sample.pos, surf.point);
                let vis = vec3_dot(light_dir, surf.local.col(2));

                if vis > flt_eps && light_sample.cos > flt_eps {
                    let inv_d = 1 / vec3_len(device.intrinsics, light_dir);
                    let inv_d2 = inv_d * inv_d;
                    let in_dir = vec3_mulf(light_dir, inv_d);
                    let out_dir = vec3_neg(ray.dir);

                    let pdf_e = if light.has_area { mat.bsdf.pdf(in_dir, out_dir) } else { 0 };
                    let pdf_l = light_sample.pdf_area * pdf_lightpick;
                    let inv_pdf_l = 1 / pdf_l;

                    let cos_e = vis * inv_d;
                    let cos_l = light_sample.cos;

                    let mis = if light.has_area { 1 / (1 + pdf_e * cos_l * inv_d2 * inv_pdf_l) } else { 1 };
                    let geom_factor = cos_e * cos_l * inv_d2 * inv_pdf_l;

                    let contrib = color_mul(light_sample.intensity, color_mul(state.contrib, mat.bsdf.eval(in_dir, out_dir)));
                    return(make_option(
                        make_ray(surf.point, light_dir, offset, 1 - offset),
                        color_mulf(contrib, geom_factor * mis)
                    ))
                }
            }
            return(Option[(Ray, Color)]::None)
        }

        fn @on_hit( ray: Ray
                  , hit: Hit
                  , state: &mut RayState
                  , surf: SurfaceElement
                  , mat: Material
                  ) -> Option[Color] {
            // Hits on a light source
            if mat.is_emissive && surf.is_entering {
                let out_dir = vec3_neg(ray.dir);
                let emit = mat.emission(out_dir);
                let next_mis = state.mis * hit.distance * hit.distance / vec3_dot(out_dir, surf.local.col(2));
                let mis = 1 / (1 + next_mis * pdf_lightpick * emit.pdf_area);
                make_option(color_mulf(color_mul(state.contrib, emit.intensity), mis))
            } else {
                Option[Color]::None
            }
        }

        fn @on_nonhit( ray: Ray
                     , state: &mut RayState) {
            let mut inflights = 0;
            let mut color = make_color(0, 0, 0);
            let lights = scene.lights;

            for light_id in unroll(0, scene.num_lights) {
                let light = @lights(light_id);
                // Do not include delta lights or finite lights
                if light.infinite && light.has_area {
                    inflights += 1;

                    let out_dir = vec3_neg(ray.dir);
                    let emit = light.emission(out_dir, make_vec2(0,0));
                    let mis = 1 / (1 + state.mis * pdf_lightpick * emit.pdf_dir);
                    color = color_add(color, color_mulf(color_mul(state.contrib, emit.intensity), mis));
                }
            }

            if inflights > 0 {
                make_option(color)
            } else {
                Option[Color]::None
            }
        }

        fn @on_bounce( ray: Ray
                     , _hit: Hit
                     , state: &mut RayState
                     , surf: SurfaceElement
                     , mat: Material
                     ) -> Option[(Ray, RayState)] {
            // Russian roulette and maximum depth
            let rr_prob = russian_roulette(state.contrib, 0.75);
            if state.depth >= max_path_len || randf(&mut state.rnd) >= rr_prob {
                return(Option[(Ray, RayState)]::None)
            }

            // Bounce
            let out_dir = vec3_neg(ray.dir);
            let mat_sample = mat.bsdf.sample(&mut state.rnd, out_dir, false);

            // The bsdf might reject the sampling
            if mat_sample.pdf <= flt_eps { return(Option[(Ray, RayState)]::None) }

            let contrib = color_mul(state.contrib, mat_sample.color);
            
            let mis = if mat.bsdf.is_specular { 0 } else { 1 / mat_sample.pdf };
            let new_contrib = color_mulf(contrib, mat_sample.cos / (mat_sample.pdf * rr_prob));

            make_option(
                make_ray(surf.point, mat_sample.in_dir, offset, flt_max),
                make_ray_state(state.rnd, new_contrib, mis, state.depth + 1)
            )
        }

        let path_tracer = PathTracer {
            on_emit   = on_emit,
            on_hit    = on_hit,
            on_nonhit = on_nonhit,
            on_shadow = on_shadow,
            on_bounce = on_bounce
        };

        device.trace(scene, path_tracer, spp);
    }
}
