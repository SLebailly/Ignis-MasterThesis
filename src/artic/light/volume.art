// uniformly samples a BBox, and returns the local and global coordinates of the sampled point
fn @sample_bbox_uniform(rnd: &mut RndState, bbox: BBox) -> (Vec3, Vec3) {
    let lx = randf(rnd);
    let ly = randf(rnd);
    let lz = randf(rnd);

    let gx = bbox.min.x + (lx * (bbox.max.x - bbox.min.x));
    let gy = bbox.min.y + (ly * (bbox.max.y - bbox.min.y));
    let gz = bbox.min.z + (lz * (bbox.max.z - bbox.min.z));

    (make_vec3(lx, ly, lz), make_vec3(gx, gy, gz))
}

fn @make_volume_light(id: i32, volume: Volume, bbox: BBox) = Light {
    id = id,
    sample_direct = @ |rnd, from_surf| {
        let (pos_local, pos) = sample_bbox_uniform(rnd, bbox);
        let props = volume.access_data().properties_at_indx(volume.coord_to_indx(pos_local));
        let dir   = vec3_norm(vec3_sub(pos, from_surf.point));
        make_direct_sample(pos, dir, intensity: Color, pdf: Pdf, cos: f32, dist: f32)
    },
    sample_emission = @ |rnd| {
        let (surf, area_pdf) = area.sample_emission(make_vec2(randf(rnd), randf(rnd)));
        let sample = sample_cosine_hemisphere(randf(rnd), randf(rnd));
        let weight = safe_div(1, area_pdf * sample.pdf);
        let ctx    = make_emissive_shading_context(make_zero_ray(), surf, vec2_to_3(surf.tex_coords, 0));
        make_emission_sample(surf.point,
            mat3x3_mul(surf.local, sample.dir),
            color_mulf(color_f(ctx), weight),
            area_pdf,
            sample.pdf,
            sample.dir.z)
    },
    emission     = color_f,
    pdf_direct   = @ |ray, surf| area.pdf_direct(surf.prim_coords, ray.org),
    pdf_emission = @ |ray, surf| make_emissive_pdf(area.pdf_emission(surf.prim_coords, ray.org), cosine_hemisphere_pdf(-vec3_dot(area.normal(surf.prim_coords), ray.dir))),
    delta    = false,
    infinite = false
};
