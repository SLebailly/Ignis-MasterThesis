mod shading {
use super as all;
use super::math_builtins;

type SurfaceElement = all::SurfaceElement;
type Vec3 = all::Vec3;

fn @to_world(surf: SurfaceElement, v: Vec3) = all::vec3_add(all::vec3_add(all::vec3_mulf(surf.local.col(0), v.x), all::vec3_mulf(surf.local.col(1), v.y)), all::vec3_mulf(surf.local.col(2), v.z));
fn @to_local(surf: SurfaceElement, v: Vec3) = all::make_vec3(all::vec3_dot(surf.local.col(0), v), all::vec3_dot(surf.local.col(1), v), all::vec3_dot(surf.local.col(2), v));

// All function below expect a local vector!
fn @cos2_theta(v: Vec3)    = v.z * v.z;
fn @cos_theta(v: Vec3)     = v.z;
fn @abs_cos_theta(v: Vec3) = math_builtins::fabs[f32](v.z);
fn @sin2_theta(v: Vec3)    = 1 - cos2_theta(v);
fn @sin_theta(v: Vec3)     = math_builtins::sqrt[f32](sin2_theta(v));
fn @tan2_theta(v: Vec3)    = sin2_theta(v) / cos2_theta(v);
fn @tan_theta(v: Vec3)     = math_builtins::sqrt[f32](tan2_theta(v));

fn @cos_phi(v: Vec3)  = v.x / sin_theta(v);
fn @cos2_phi(v: Vec3) = v.x * v.x / sin2_theta(v);
fn @sin_phi(v: Vec3)  = v.y / sin_theta(v);
fn @sin2_phi(v: Vec3) = v.y*v.y / sin2_theta(v);

fn @cos_diff_phi(a: Vec3, b: Vec3) -> f32 {
    let A = a.x * a.x + a.y * a.y;
    let B = b.x * b.x + b.y * b.y;
    (a.x * b.x + a.y * b.y) / math_builtins::sqrt[f32](A * B)
}

fn @theta(v: Vec3) = math_builtins::acos[f32](cos_theta(v));
fn @phi(v: Vec3) -> f32 {
    let a = math_builtins::atan2[f32](v.y, v.x);
    if a < 0 { a + 2 * super::flt_pi } else { a }
}

fn @is_same_hemisphere(a: Vec3, b: Vec3) = cos_theta(a) * cos_theta(b) >= 0;
fn @is_positive_hemisphere(v: Vec3)      = cos_theta(v) >= 0;

fn @make_same_hemisphere(a: Vec3, b: Vec3) = if is_same_hemisphere(a, b) { b } else { all::vec3_neg(b) };
fn @make_positive_hemisphere(v: Vec3)      = if is_positive_hemisphere(v) { v } else { all::vec3_neg(v) };
}