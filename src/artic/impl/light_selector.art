// Result of sampling a direction
struct LightSelector {
    count:     i32,
    sample:    fn (&mut RndState) -> (Light, f32),
    pdf:       fn (Light) -> f32,
    infinites: LightTable,
    finites:   LightTable
}

fn @make_null_light_selector() = LightSelector {
    count     = 0,
    sample    = @|_| (make_null_light(0), 1),
    pdf       = @|_| 1,
    infinites = make_empty_light_table(),
    finites   = make_empty_light_table()
};

fn @pick_light_id(rnd: &mut RndState, num_lights: i32) {
    if ?num_lights && num_lights == 1 {
        0
    } else {
        // Note: randi() returns random integers, but we only want positive integers here
        (randi(rnd) & 0x7FFFFFFF) % num_lights
    }
}

fn @make_uniform_light_selector(infinite_lights: LightTable, finite_lights: LightTable) -> LightSelector {
    let num_lights     = infinite_lights.count + finite_lights.count;
    let pdf_inf_lights = if infinite_lights.count == 0 { 1 } else { 1 / (infinite_lights.count as f32) };
    let pdf_fin_lights = if finite_lights.count == 0   { 1 } else { 1 / (finite_lights.count as f32) };

    LightSelector {
        count  = num_lights,
        sample = @|rnd| {
            let id = pick_light_id(rnd, num_lights);
            if id < infinite_lights.count {
                (infinite_lights.get(id), pdf_inf_lights)
            } else {
                (finite_lights.get(id - infinite_lights.count), pdf_fin_lights)
            }
        },
        pdf       = @|light| select(light.infinite, pdf_inf_lights, pdf_fin_lights),
        infinites = infinite_lights,
        finites   = finite_lights
    }
}

fn @make_cdf_light_selector(infinite_lights: LightTable, finite_lights: LightTable, sampler: cdf::CDF1D) -> LightSelector {
    if infinite_lights.count == 0 {
        LightSelector {
            count     = sampler.func_size,
            sample    = @|rnd| { let s = sampler.sample_discrete(randf(rnd)); (finite_lights.get(s.off), s.pdf) },
            pdf       = @|light| sampler.pdf_discrete(light.id).pdf,
            infinites = infinite_lights,
            finites   = finite_lights
        }
    } else {
        let pdf_infinite_lights = 1 / (infinite_lights.count as f32);
        let infinite_ratio      = 0.5:f32;
        LightSelector {
            count  = infinite_lights.count + sampler.func_size,
            sample = @|rnd| {
                let q = randf(rnd);
                if q < infinite_ratio {
                    let id = pick_light_id(rnd, infinite_lights.count);
                    (infinite_lights.get(id), pdf_infinite_lights)
                } else {
                    let s = sampler.sample_discrete(randf(rnd));
                    (finite_lights.get(s.off), s.pdf)
                }
            },
            pdf       = @|light| if light.infinite { pdf_infinite_lights } else { sampler.pdf_discrete(light.id).pdf },
            infinites = infinite_lights,
            finites   = finite_lights
        }
    }
}

fn @make_hierarchy_light_selector(infinite_lights: LightTable, finite_lights: LightTable, _data: DeviceBuffer) -> LightSelector {
    make_uniform_light_selector(infinite_lights, finite_lights)
    // TODO
}
