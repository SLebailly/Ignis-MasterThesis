// This samples the environment by naive sphere sampling
fn @make_environment_light(max_radius: f32, color: Color) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(u, v);
        make_direct_sample(sample.dir, color, 1.0, sample.pdf, 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(u, v);
        make_emission_sample(vec3_mulf(sample.dir,max_radius), sample.dir, color, 1.0, sample.pdf, 1.0)
    },
    emission = @ |_, _| make_emission_value(color, 1.0, uniform_sphere_pdf()),
    delta    = false,
    infinite = true
};

//-------------------------------------------
// This samples the environment by a given two-dimensional cdf
fn @make_environment_light_textured(max_radius: f32, tex: Texture, env_cdf: cdf::CDF2D, transform: Mat3x3) -> Light {
    let map = @|dir : Vec3| -> Vec2 {
        let (theta, phi) = spherical_from_dir(mat3x3_mul(transform, dir));
        let v = theta / flt_pi;
        let u = phi / (2 * flt_pi);
        make_vec2(u,v)
    };
    let unmap = @|uv : Vec2| -> Vec3 {
        let border = make_repeat_border();
        let theta  = border.vert(uv.y) * flt_pi;
        let phi    = border.horz(uv.x) * 2 * flt_pi;
        mat3x3_left_mul(transform, dir_from_spherical(theta, phi))
    };
    let eval = @|dir : Vec3| tex(map(dir));

    Light {
        sample_direct = @ |rnd, _| {
            let u = randf(rnd);
            let v = randf(rnd);
            let sample    = cdf::sample_cdf_2d(make_vec2(u, v), env_cdf);
            let sinTheta  = math_builtins::sin(sample.pos.y*flt_pi);
            let dir       = unmap(sample.pos);
            let intensity = eval(dir);
            make_direct_sample(dir, intensity, 1.0, safe_div(sample.pdf, sinTheta * flt_pi * flt_pi * 2), 1.0)
        },
        sample_emission = @ |rnd| {
            let u = randf(rnd);
            let v = randf(rnd);
            let sample    = cdf::sample_cdf_2d(make_vec2(u, v), env_cdf);
            let sinTheta  = math_builtins::sin(sample.pos.y*flt_pi);
            let dir       = unmap(sample.pos);
            let intensity = eval(dir);
            make_emission_sample(vec3_mulf(dir, max_radius), dir, intensity, 1.0, safe_div(sample.pdf, sinTheta * flt_pi * flt_pi * 2), 1.0)
        },
        emission = @ |dir, _| {
            let uv        = map(dir);
            let pdf       = cdf::pdf_cdf_2d(uv, env_cdf);
            let sinTheta  = math_builtins::sin(uv.y*flt_pi);
            make_emission_value(eval(dir), 1.0, safe_div(pdf, sinTheta * flt_pi * flt_pi * 2))
        },
        delta    = false,
        infinite = true
    }
}

//-------------------------------------------
fn @make_environment_light_function(max_radius: f32, func: fn(Vec3)->Color, transform: Mat3x3) = Light {
    sample_direct = @ |rnd, _| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(u, v);
        let intensity = func(sample.dir);
        let dir = mat3x3_left_mul(transform, sample.dir);
        make_direct_sample(dir, intensity, 1.0, sample.pdf, 1.0)
    },
    sample_emission = @ |rnd| {
        let u = randf(rnd);
        let v = randf(rnd);
        let sample = sample_uniform_sphere(u, v);
        let intensity = func(mat3x3_mul(transform, sample.dir));
        let dir = mat3x3_left_mul(transform, sample.dir);
        make_emission_sample(vec3_mulf(dir,max_radius), dir, intensity, 1.0, sample.pdf, 1.0)
    },
    emission = @ |dir, _| {
        make_emission_value(func(mat3x3_mul(transform, dir)), 1.0, uniform_sphere_pdf())
    },
    delta    = false,
    infinite = true
};

// Some texture node do not have an associated cdf, use naive sampling instead
fn @make_environment_light_textured_naive(max_radius: f32, tex: Texture, transform: Mat3x3) =
    make_environment_light_function(max_radius, @|dir|{
        let (theta, phi) = spherical_from_dir(dir);
        let u = theta / flt_pi;
        let v = phi / (2 * flt_pi);
        tex(make_vec2(v,u))
}, transform);