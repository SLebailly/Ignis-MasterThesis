// ---------------------- 1D
fn @noise1[T](u: T, seed: f32) -> f32 {
    let mut tmp = fnv_hash(fnv_hash(fnv_init(), bitcast[u32](seed)), bitcast[u32](u));
    randf(&mut tmp)
}

fn @snoise1(u: f32, seed: f32)     = noise1(u, seed: f32) * 2 - 1;
fn @vec3_noise1(u: f32, seed: f32) = make_vec3(snoise1(u, seed), snoise1(u, seed + 1234), snoise1(u, seed + 5678));
fn @cellnoise1(u: f32, seed: f32)  = noise1(u as i32, seed);

// Similar to Ken Perlin's original noise function
fn @pnoise1(u: f32, seed: f32) -> f32 {
    let ix = u as i32;
    let kx = smoothstep(u - (ix as f32));

    let p0 = noise1(ix  , seed);
    let p1 = noise1(ix+1, seed);

    lerp(p0, p1, kx)
}

// ---------------------- 2D
fn @noise2[T](u: T, v: T, seed: f32) -> f32 {
    let mut tmp = fnv_hash(fnv_hash(fnv_hash(fnv_init(), bitcast[u32](seed)), bitcast[u32](u)), bitcast[u32](v));
    randf(&mut tmp)
}

fn @noise2_v(uv: Vec2, seed: f32)    = noise2(uv.x, uv.y, seed);
fn @snoise2(uv: Vec2, seed: f32)     = noise2_v(uv, seed: f32) * 2 - 1;
fn @vec3_noise2(uv: Vec2, seed: f32) = make_vec3(snoise2(uv, seed), snoise2(uv, seed + 1234), snoise2(uv, seed + 5678));
fn @cellnoise2(uv: Vec2, seed: f32)  = noise2(uv.x as i32, uv.y as i32, seed);

fn @pnoise2(uv: Vec2, seed: f32) -> f32 {
    let ix = uv.x as i32;
    let iy = uv.y as i32;
    let kx = smoothstep(uv.x - (ix as f32));
    let ky = smoothstep(uv.y - (iy as f32));

    let p00 = noise2(ix  , iy  , seed);
    let p10 = noise2(ix+1, iy  , seed);
    let p01 = noise2(ix  , iy+1, seed);
    let p11 = noise2(ix+1, iy+1, seed);

    lerp(lerp(p00, p10, kx), lerp(p01, p11, kx), ky)
}

// Based on https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#classic-perlin-noise
// Returns between [-1, 1]
fn @sperlin2(uv: Vec2, seed: f32) -> f32 {
    fn mod289(x: f32)    = x - math_builtins::floor(x / 289.0) * 289;
    fn mod289_v(v: Vec4) = vec4_map(v, mod289);
    fn permute(v: Vec4)  = mod289_v(vec4_add(vec4_mul(vec4_mulf(v, 34), v), v));
    fn fract_v(v: Vec4)  = vec4_map(v, @|x| x - math_builtins::floor(x));

    let p = vec2_add(uv, vec2_expand(noise1(1234, seed)));

    let pix_ = math_builtins::floor(p.x);
    let piy_ = math_builtins::floor(p.y);
    let piz_ = pix_ + 1;
    let piw_ = piy_ + 1;
    
    let pfx = p.x - pix_;
    let pfy = p.y - piy_;
    let pfz = pfx - 1;
    let pfw = pfy - 1;

    let pix = mod289(pix_); 
    let piy = mod289(piy_);
    let piz = mod289(piz_);
    let piw = mod289(piw_); 

    let vix = make_vec4(pix, piz, pix, piz);
    let viy = make_vec4(piy, piy, piw, piw);
    let vfx = make_vec4(pfx, pfz, pfx, pfz);
    let vfy = make_vec4(pfy, pfy, pfw, pfw);

    let vi = permute(vec4_add(permute(vix), viy));
    let gx = vec4_sub(vec4_mulf(fract_v(vec4_divf(vi, 41)), 2), vec4_expand(1));
    let gy = vec4_sub(vec4_abs(gx), vec4_expand(0.5));
    let tx = vec4_floor(vec4_add(gx, vec4_expand(0.5)));
    
    let gx2 = vec4_sub(gx, tx);
    let g00 = make_vec2(gx2.x, gy.x);
    let g10 = make_vec2(gx2.y, gy.y);
    let g01 = make_vec2(gx2.z, gy.z);
    let g11 = make_vec2(gx2.w, gy.w);
    
    let norm = vec4_sub(vec4_expand(1.79284291400159),
                    vec4_mulf(make_vec4(vec2_len2(g00), vec2_len2(g01), vec2_len2(g10), vec2_len2(g11)),
                        0.85373472095314 ));

    let n00 = vec2_dot(g00, make_vec2(vfx.x, vfy.x)) * norm.x;
    let n10 = vec2_dot(g10, make_vec2(vfx.y, vfy.y)) * norm.y;
    let n01 = vec2_dot(g01, make_vec2(vfx.z, vfy.z)) * norm.z;
    let n11 = vec2_dot(g11, make_vec2(vfx.w, vfy.w)) * norm.w;
    
    let fade_x = smootherstep(pfx);
    let fade_y = smootherstep(pfy);
    let n_x    = vec2_lerp(make_vec2(n00, n01), make_vec2(n10, n11), fade_x);
    2.3 * lerp(n_x.x, n_x.y, fade_y)
}
fn @perlin2(uv: Vec2, seed: f32) = (sperlin2(uv, seed) + 1) / 2;

// As in https://www.shadertoy.com/view/lsjGWD
fn @voronoi2_gen(uv: Vec2, seed: f32, dist_f: fn(Vec2, Vec2)->f32, compute_f: fn(f32, f32)->f32) {
    let ip = vec2_floor(uv);
    let fp = vec2_map(uv, |x| x - math_builtins::floor(x));

	let mut f1 = 8.0 : f32;
	let mut f2 = 8.0 : f32;
	
    for j in unroll(-1, 2) {
        for i in unroll(-1, 2) {
            let g = make_vec2(i as f32, j as f32);
            let k = vec2_add(ip, g);
            let o = make_vec2(noise2_v(k, seed), noise2_v(k, seed + DEFAULT_CNOISE_SEED_SHIFT0));
            let d = dist_f(vec2_add(g, o), fp);

            if d < f1 { 
                f2 = f1; 
                f1 = d; 
            } else if d < f2 {
                f2 = d;
            }
        }
    }
    
	compute_f(f1, f2)
}

// Generic Fractional Brownian Motion
fn @fbm2_gen(uv: Vec2, seed: f32, octaves: i32, lacunarity: f32, gain: f32, dist_f: fn(Vec2, Vec2)->f32, compute_f: fn(f32, f32)->f32) {
    let mut s = 0.0 : f32;
	let mut m = 0.0 : f32;
	let mut a = gain;
    let mut p = uv;
	
	for _ in unroll(0, octaves) {
		s += a * voronoi2_gen(p, seed, dist_f, compute_f);
		m += a;
		a *= gain;
		p = vec2_mulf(p, lacunarity);
	}

	s / m
}

fn @voronoi2(uv: Vec2, seed: f32) = voronoi2_gen(uv, seed, @|a, b| vec2_len2(vec2_sub(b, a)), @|f1, _f2| f1);
fn @fbm2(uv: Vec2, seed: f32)     = fbm2_gen(uv, seed, 6, 2, 0.5, @|a, b| vec2_len2(vec2_sub(b, a)), @|f1, _f2| f1);

// ---------------------- 3D
fn @noise3[T](u: T, v: T, w: T, seed: f32) -> f32 {
    let mut tmp = fnv_hash(fnv_hash(fnv_hash(fnv_hash(fnv_init(), bitcast[u32](seed)), bitcast[u32](u)), bitcast[u32](v)), bitcast[u32](w));
    randf(&mut tmp)
}

fn @noise3_v(uvw: Vec3, seed: f32)    = noise3(uvw.x, uvw.y, uvw.z, seed);
fn @snoise3(uvw: Vec3, seed: f32)     = noise3_v(uvw, seed: f32) * 2 - 1;
fn @vec3_noise3(uvw: Vec3, seed: f32) = make_vec3(snoise3(uvw, seed), snoise3(uvw, seed + 1234), snoise3(uvw, seed + 5678));
fn @cellnoise3(uvw: Vec3, seed: f32)  = noise3(uvw.x as i32, uvw.y as i32, uvw.z as i32, seed);

fn @pnoise3(uvw: Vec3, seed: f32) -> f32 {
    let ix = uvw.x as i32;
    let iy = uvw.y as i32;
    let iz = uvw.z as i32;
    let kx = smoothstep(uvw.x - (ix as f32));
    let ky = smoothstep(uvw.y - (iy as f32));
    let kz = smoothstep(uvw.z - (iz as f32));

    let p000 = noise3(ix  , iy  , iz  , seed);
    let p100 = noise3(ix+1, iy  , iz  , seed);
    let p010 = noise3(ix  , iy+1, iz  , seed);
    let p110 = noise3(ix+1, iy+1, iz  , seed);
    let p001 = noise3(ix  , iy  , iz+1, seed);
    let p101 = noise3(ix+1, iy  , iz+1, seed);
    let p011 = noise3(ix  , iy+1, iz+1, seed);
    let p111 = noise3(ix+1, iy+1, iz+1, seed);

    let a0 = lerp(lerp(p000, p100, kx), lerp(p010, p110, kx), ky);
    let a1 = lerp(lerp(p001, p101, kx), lerp(p011, p111, kx), ky);
    lerp(a0, a1, kz)
}

// ---------------------- Colored Version
static DEFAULT_CNOISE_SEED_SHIFT0 = 175391:f32;
static DEFAULT_CNOISE_SEED_SHIFT1 = 822167:f32;
fn @make_color_noise_fn[T](nfunc: fn (T, f32) -> f32, v: T, seed: f32) = make_color(nfunc(v, seed), nfunc(v, seed + DEFAULT_CNOISE_SEED_SHIFT0), nfunc(v, seed + DEFAULT_CNOISE_SEED_SHIFT1), 1);
fn @cnoise1(u: f32, seed: f32)        = make_color_noise_fn(noise1[f32], u, seed);
fn @cnoise2(uv: Vec2, seed: f32)      = make_color_noise_fn(noise2_v, uv, seed);
fn @cnoise3(uvw: Vec3, seed: f32)     = make_color_noise_fn(noise3_v, uvw, seed);
fn @ccellnoise1(u: f32, seed: f32)    = make_color_noise_fn(cellnoise1, u,   seed);
fn @ccellnoise2(uv: Vec2, seed: f32)  = make_color_noise_fn(cellnoise2, uv,  seed);
fn @ccellnoise3(uvw: Vec3, seed: f32) = make_color_noise_fn(cellnoise3, uvw, seed);
fn @cpnoise1(u: f32, seed: f32)       = make_color_noise_fn(pnoise1, u,   seed);
fn @cpnoise2(uv: Vec2, seed: f32)     = make_color_noise_fn(pnoise2, uv,  seed);
fn @cpnoise3(uvw: Vec3, seed: f32)    = make_color_noise_fn(pnoise3, uvw, seed);

fn @cperlin2(uv: Vec2, seed: f32) {
    let color = cnoise2(uv, seed);
    color_mulf(color, perlin2(uv, seed))
}

// fn @cperlin3(uvw: Vec3, seed: f32)    = make_color_noise_fn(perlin3, uvw, seed);
fn @cvoronoi2(uv: Vec2, seed: f32)    = make_color_noise_fn(voronoi2, uv,  seed); // FIXME: Each cell should contain a different color
fn @cfbm2(uv: Vec2, seed: f32)        = make_color_noise_fn(fbm2, uv,  seed);     // FIXME: See above

// ---------------------- Defaults
static DEFAULT_NOISE_SEED = 36326639:f32;
fn @noise1_def(u: f32)         = noise1(u,       DEFAULT_NOISE_SEED);
fn @noise2_def(uv: Vec2)       = noise2_v(uv,    DEFAULT_NOISE_SEED);
fn @noise3_def(uvw: Vec3)      = noise3_v(uvw,   DEFAULT_NOISE_SEED);
fn @cellnoise1_def(u: f32)     = cellnoise1(u,   DEFAULT_NOISE_SEED);
fn @cellnoise2_def(uv: Vec2)   = cellnoise2(uv,  DEFAULT_NOISE_SEED);
fn @cellnoise3_def(uvw: Vec3)  = cellnoise3(uvw, DEFAULT_NOISE_SEED);
fn @pnoise1_def(u: f32)        = pnoise1(u,      DEFAULT_NOISE_SEED);
fn @pnoise2_def(uv: Vec2)      = pnoise2(uv,     DEFAULT_NOISE_SEED);
fn @pnoise3_def(uvw: Vec3)     = pnoise3(uvw,    DEFAULT_NOISE_SEED);
fn @sperlin2_def(uv: Vec2)     = sperlin2(uv,    DEFAULT_NOISE_SEED);
// fn @sperlin3_def(uvw: Vec3)    = sperlin3(uvw,   DEFAULT_NOISE_SEED);
fn @perlin2_def(uv: Vec2)      = perlin2(uv,     DEFAULT_NOISE_SEED);
// fn @perlin3_def(uvw: Vec3)     = perlin3(uvw,    DEFAULT_NOISE_SEED);
fn @voronoi2_def(uv: Vec2)     = voronoi2(uv,    DEFAULT_NOISE_SEED);
fn @fbm2_def(uv: Vec2)         = fbm2(uv,    DEFAULT_NOISE_SEED);

fn @cnoise1_def(u: f32)        = cnoise1(u,       DEFAULT_NOISE_SEED);
fn @cnoise2_def(uv: Vec2)      = cnoise2(uv,      DEFAULT_NOISE_SEED);
fn @cnoise3_def(uvw: Vec3)     = cnoise3(uvw,     DEFAULT_NOISE_SEED);
fn @ccellnoise1_def(u: f32)    = ccellnoise1(u,   DEFAULT_NOISE_SEED);
fn @ccellnoise2_def(uv: Vec2)  = ccellnoise2(uv,  DEFAULT_NOISE_SEED);
fn @ccellnoise3_def(uvw: Vec3) = ccellnoise3(uvw, DEFAULT_NOISE_SEED);
fn @cpnoise1_def(u: f32)       = cpnoise1(u,      DEFAULT_NOISE_SEED);
fn @cpnoise2_def(uv: Vec2)     = cpnoise2(uv,     DEFAULT_NOISE_SEED);
fn @cpnoise3_def(uvw: Vec3)    = cpnoise3(uvw,    DEFAULT_NOISE_SEED);
fn @cperlin2_def(uv: Vec2)     = cperlin2(uv,     DEFAULT_NOISE_SEED);
// fn @cperlin3_def(uvw: Vec3)    = cperlin3(uvw,    DEFAULT_NOISE_SEED);
fn @cvoronoi2_def(uv: Vec2)    = cvoronoi2(uv,    DEFAULT_NOISE_SEED);
fn @cfbm2_def(uv: Vec2)        = cfbm2(uv,        DEFAULT_NOISE_SEED);

// ---------------------- Textures
fn @make_gen_noise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3, func: fn (Vec2, f32) -> f32) -> Texture {
    @ |uv| {
        let uv2 = mat3x3_transform_point_affine(transform, uv); 
        let suv = vec2_mul(uv2, scale);       
        color_mulf(color, func(suv, seed))
    }
}

fn @make_noise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)     = make_gen_noise_texture(scale, color, seed, transform, noise2_v);
fn @make_cellnoise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3) = make_gen_noise_texture(scale, color, seed, transform, cellnoise2);
fn @make_pnoise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)    = make_gen_noise_texture(scale, color, seed, transform, pnoise2);
fn @make_perlin_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)    = make_gen_noise_texture(scale, color, seed, transform, perlin2);
fn @make_voronoi_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)   = make_gen_noise_texture(scale, color, seed, transform, voronoi2);
fn @make_fbm_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)       = make_gen_noise_texture(scale, color, seed, transform, fbm2);

// ---------------------- Textures (Colored)
fn @make_gen_colored_noise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3, func: fn (Vec2, f32) -> f32) -> Texture {
    @ |uv| {
        let uv2 = mat3x3_transform_point_affine(transform, uv); 
        let suv = vec2_mul(uv2, scale);
        color_mul(color, make_color_noise_fn(func, suv, seed))
    }
}

fn @make_cnoise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)     = make_gen_colored_noise_texture(scale, color, seed, transform, noise2_v);
fn @make_ccellnoise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3) = make_gen_colored_noise_texture(scale, color, seed, transform, cellnoise2);
fn @make_cpnoise_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)    = make_gen_colored_noise_texture(scale, color, seed, transform, pnoise2);
fn @make_cperlin_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)    = make_gen_colored_noise_texture(scale, color, seed, transform, perlin2);
fn @make_cvoronoi_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)   = make_gen_colored_noise_texture(scale, color, seed, transform, voronoi2);
fn @make_cfbm_texture(scale: Vec2, color: Color, seed: f32, transform: Mat3x3)       = make_gen_colored_noise_texture(scale, color, seed, transform, fbm2);
