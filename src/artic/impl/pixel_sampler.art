type PixelSampler = fn (&mut RndState, i32) -> (f32, f32);

// --------------------------
fn @make_uniform_pixel_sampler() -> PixelSampler {
    @|rnd, _| {
		let rx = randf(rnd);
		let ry = randf(rnd);
        (rx, ry)
    }
}

// --------------------------
fn @mjitt_permute(i: u32, l: u32, p: u32) -> u32
{
	let mut w = l - 1;
    let mut i2 = i;

	if w == 0 {
		0
	} else if (l & w) == 0 { // Power of 2
		i2 ^= p;
		i2 *= 0xe170893d;
		i2 ^= p >> 16;
		i2 ^= (i2 & w) >> 4;
		i2 ^= p >> 8;
		i2 *= 0x0929eb3f;
		i2 ^= p >> 23;
		i2 ^= (i2 & w) >> 1;
		i2 *= 1 | p >> 27;
		i2 *= 0x6935fa69;
		i2 ^= (i2 & w) >> 11;
		i2 *= 0x74dcb303;
		i2 ^= (i2 & w) >> 2;
		i2 *= 0x9e501cc3;
		i2 ^= (i2 & w) >> 2;
		i2 *= 0xc860a3df;
		i2 &= w;
		i2 ^= i2 >> 5;
		(i2 + p) & w
	} else {
		w |= w >> 1;
		w |= w >> 2;
		w |= w >> 4;
		w |= w >> 8;
		w |= w >> 16;
		while true {
			i2 ^= p;
			i2 *= 0xe170893d;
			i2 ^= p >> 16;
			i2 ^= (i2 & w) >> 4;
			i2 ^= p >> 8;
			i2 *= 0x0929eb3f;
			i2 ^= p >> 23;
			i2 ^= (i2 & w) >> 1;
			i2 *= 1 | p >> 27;
			i2 *= 0x6935fa69;
			i2 ^= (i2 & w) >> 11;
			i2 *= 0x74dcb303;
			i2 ^= (i2 & w) >> 2;
			i2 *= 0x9e501cc3;
			i2 ^= (i2 & w) >> 2;
			i2 *= 0xc860a3df;
			i2 &= w;
			i2 ^= i2 >> 5;
            if i2 < l { break() }
		}
		(i2 + p) % l
	}
}

// FIXME: There is a bug somewhere making the output blur
fn @make_mjitt_pixel_sampler(bin_x: u32, bin_y: u32) -> PixelSampler {
    let SEED : u32 = 8744221777;
	let F1   : u32 = 0xa511e9b3;
	let F2   : u32 = 0x63d83595;

    @|rnd, index| {
		let index2 = index as u32;
		let sx     = mjitt_permute(index2 % bin_x, bin_x, SEED * F1);
		let sy     = mjitt_permute(index2 / bin_x, bin_y, SEED * F2);

		let jx = randf(rnd);
		let jy = randf(rnd);

        let bin_xf = bin_x as f32;
        let bin_yf = bin_y as f32;
        let rx = ((index2 % bin_x) as f32 + (sy as f32 + jx) / bin_yf) / bin_xf;
        let ry = ((index2 / bin_x) as f32 + (sx as f32 + jy) / bin_xf) / bin_yf;
        
        (rx, ry)
    }
}

// --------------------------
fn @halton(index: i32, base: i32) {
    // TODO: Saving this state would make it waaay faster
    let mut n = 0 : i32;
    let mut d = 1 : i32;
    
    for _i in range(0, index) {
        let x = d - n;
        if x == 1 {
            n = 1;
            d *= base;
        } else {
            let mut y = d / base;
            while x <= y {
                y /= base;
            }
            n = (base + 1) * y - x;
        }
    }
    
    n as f32 / d as f32    
}

// FIXME: Can not be used in progressive rendering due to the bad iteration scheme
fn @make_halton_pixel_sampler() -> PixelSampler {
	let Base1  : i32 = 13;
	let Base2  : i32 = 47;
    let Burnin : i32 = Base2;

    @|_rnd, index| {
		let rx = halton(index + Burnin, Base1);
		let ry = halton(index + Burnin, Base2);
        (rx, ry)
    }
}
