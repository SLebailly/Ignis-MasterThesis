/* Based on the paper:
	BURLEY, Brent; STUDIOS, Walt Disney Animation. Physically-based shading at disney. In: ACM SIGGRAPH. 2012. S. 1-7.
	and code:
	https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf
  And based on the follow-up paper:
    BURLEY, Brent; STUDIOS, Walt Disney Animation. Extending the Disney BRDF to a BSDF with Integrated Subsurface Scattering. (2015).
	https://blog.selfshadow.com/publications/s2015-shading-course/#course_content
*/

mod principled {
use super as all;
use super::math_builtins;
use super::shading;

type SurfaceElement = all::SurfaceElement;
type Color = all::Color;
type Vec3 = all::Vec3;

struct Closure {
    surf:                  SurfaceElement,
    base_color:            Color,
    ior:                   f32,
    diffuse_transmission:  f32,
    specular_transmission: f32,
    specular_tint:         f32,
    roughness:             f32,
    anisotropic:           f32,
    flatness:              f32,
    metallic:              f32, 
    sheen:                 f32,
    sheen_tint:            f32,
    clearcoat:             f32,
    clearcoat_gloss:       f32,
    thin:                  bool
}

struct EvalClosure {
    wo: Vec3,
    wi: Vec3,
    h:  Vec3,
    general: Closure,
    adjoint: bool
}

fn @tint_color(color: Color) = super::color_mulf(color, 1 / super::color_luminance(color));
fn @sheen_tint_color(color: Color, tint: f32) = super::color_lerp(super::white, tint_color(color), tint);

fn @getMicro(closure: Closure, roughness: f32) -> all::MicrofacetDistribution {
    let aspect = math_builtins::sqrt(1 - closure.anisotropic * 0.9);
    let ax	   = math_builtins::fmax(0.001 : f32, roughness * roughness / aspect);
    let ay	   = math_builtins::fmax(0.001 : f32, roughness * roughness * aspect);
    super::make_vndf_ggx_distribution(closure.surf, ax, ay)
}

fn @evalDisneyFresnelTerm(closure: EvalClosure) -> Color {
    let HdL = super::vec3_dot(closure.wi, closure.h);
    let HdV = super::vec3_dot(closure.wo, closure.h);

    let color = tint_color(closure.general.base_color);
    let ni    = closure.general.ior;
    let no    = 1.0002926 : f32; // Air
    let eta	  = if HdV < 0 { no / ni } else { ni / no };

    let a  = super::color_lerp(super::white, color, closure.general.specular_tint);
    let r0 = super::color_lerp(super::color_mulf(a, super::schlick_from_relative_ior(eta)), closure.general.base_color, closure.general.metallic);
    let f1 = super::make_gray_color(super::fresnel(eta, HdV).factor);
    let f2 = super::schlick(r0, super::white, math_builtins::fabs(HdL));

    super::color_lerp(f1, f2, closure.general.metallic)
}

fn @evalRetroDiffuseTerm(closure: EvalClosure) -> f32 {
    let r2    = closure.general.roughness * closure.general.roughness;
    let HdotL = super::vec3_dot(closure.wi, closure.h);
    let fd90  = 0.5 + 2 * HdotL * HdotL * r2;
    let lk    = super::schlick_approx(shading::abs_cos_theta(closure.wi));
    let vk    = super::schlick_approx(shading::abs_cos_theta(closure.wo));

    super::flt_inv_pi * fd90 * (lk + vk + lk * vk * (fd90 - 1))
}

fn @evalSubsurfaceTerm(closure: EvalClosure) -> f32 {
    let r2    = closure.general.roughness * closure.general.roughness;
    let HdotL = super::vec3_dot(closure.wi, closure.h);
    let fss90 = HdotL * HdotL * r2;
    let aNdL  = shading::abs_cos_theta(closure.wi);
    let aNdV  = shading::abs_cos_theta(closure.wo);
    let lk    = super::schlick_approx(aNdL);
    let vk    = super::schlick_approx(aNdV);

    let fss = (1 - lk + fss90 * lk) * (1 - vk + fss90 * vk);
    1.25 * (fss * (1 / (aNdL + aNdV + 1e-5) - 0.5) + 0.5)
}

fn @evalSheenTerm(closure: EvalClosure) -> Color {
    let lk = super::schlick_approx(shading::abs_cos_theta(closure.wi));
    super::color_mulf(sheen_tint_color(closure.general.base_color, closure.general.sheen_tint), closure.general.sheen * lk)
}

fn @evalDiffuseTerm(closure: EvalClosure) -> f32 {
    let aNdL = shading::abs_cos_theta(closure.wi);
    let aNdV = shading::abs_cos_theta(closure.wo);
    let lk   = super::schlick_approx(aNdL);
    let vk   = super::schlick_approx(aNdV);

    let d = if closure.general.thin {1 - closure.general.flatness + evalSubsurfaceTerm(closure) * closure.general.flatness } else { 1 };

    super::flt_inv_pi * d * (1 - 0.5 * lk) * (1 - 0.5 * vk)
}

fn @evalReflectionTerm(closure: EvalClosure) -> Color {
    if !shading::is_same_hemisphere(closure.wi, closure.wo) { return(super::black) };

    let micro = getMicro(closure.general, closure.general.roughness);

    let F    = evalDisneyFresnelTerm(closure);
    let D    = micro.D(closure.h);
    let G    = micro.G(closure.wi, closure.wo, closure.h);
    let norm = micro.norm(closure.wi, closure.wo, closure.h);

    let jacob = 1 / (4 * shading::cos_theta(closure.wi)); // Jacobian of the half-direction mapping
    super::color_mulf(F, D * G * norm * jacob)
}

fn @evalRefractionTerm(closure: EvalClosure) -> Color {
    if shading::is_same_hemisphere(closure.wi, closure.wo) { return(super::black) };

    let roughness = if closure.general.thin { 
        math_builtins::fmax[f32](0.0, math_builtins::fmin[f32](1.0, (0.65 * closure.general.ior - 0.35) * closure.general.roughness))
    } else { 
        closure.general.roughness
    };
    let micro = getMicro(closure.general, roughness);

    let ni  = closure.general.ior;
    let no  = 1.0002926 : f32; // Air
    let eta = if shading::is_positive_hemisphere(closure.wi) { ni / no } else { no / ni };

    let HdL  = super::absolute_cos(closure.wi, closure.h);
    let F    = super::fresnel(eta, HdL).factor;
    let D    = micro.D(closure.h);
    let G    = micro.G(closure.wi, closure.wo, closure.h);
    let norm = micro.norm(closure.wi, closure.wo, closure.h);

    let jacob_d = eta * shading::cos_theta(closure.wi) + shading::cos_theta(closure.wo);
    let jacob   = shading::abs_cos_theta(closure.wo) / (jacob_d * jacob_d); // Jacobian of the half-direction mapping for refraction
    let spread  = if closure.adjoint { 1 / (eta * eta) } else { 1 };
    let term    = (1 - F) * D * G * norm * jacob * spread;

    if closure.general.thin {
        super::color_mulf(
            super::make_color(math_builtins::sqrt[f32](closure.general.base_color.r), math_builtins::sqrt[f32](closure.general.base_color.g), math_builtins::sqrt[f32](closure.general.base_color.b)),
            term)
    } else {
        super::color_mulf(closure.general.base_color, term)
    }
}

fn @evalClearcoatTerm(closure: EvalClosure) -> Color {
    let F0 = 0.04 : f32; // IOR 1.5
    let R  = 0.25 : f32;
    let R2 = 0.1 * (1 - closure.general.clearcoat_gloss) + 0.01 * closure.general.clearcoat_gloss;

    let aHdL = super::absolute_cos(closure.wi, closure.h);

    let d  = super::ndf_ggx(super::mat3x3_identity(), closure.h, R2, R2);
    let hk = super::schlick_approx(aHdL);
    let f  = F0 * (1 - hk) + hk;
    let g  = super::g_1_smith(super::mat3x3_identity(), closure.wi, closure.h, R, R) * super::g_1_smith(super::mat3x3_identity(), closure.wo, closure.h, R, R);
    let norm = super::compute_microfacet_norm(closure.wi, closure.wo, closure.h, closure.general.surf.local);

    super::make_gray_color(R * d * f * g * norm)
}

}

// Principled BSDF
fn @make_principled_bsdf(surf: SurfaceElement,
                     base_color: Color,
                     ior: f32, diffuse_transmission: f32, specular_transmission: f32, specular_tint: f32,
                     roughness: f32, anisotropic: f32, flatness: f32, metallic: f32, 
                     sheen: f32, sheen_tint: f32, clearcoat: f32, clearcoat_gloss: f32,
                     thin: bool) -> Bsdf {
    let closure = principled::Closure {
        surf                  = surf,
        base_color            = base_color,
        ior                   = ior,
        diffuse_transmission  = diffuse_transmission,
        specular_transmission = specular_transmission,
        specular_tint         = specular_tint,
        roughness             = roughness,
        anisotropic           = anisotropic,
        flatness              = flatness,
        metallic              = metallic,
        sheen                 = sheen,
        sheen_tint            = sheen_tint,
        clearcoat             = clearcoat,
        clearcoat_gloss       = clearcoat_gloss,
        thin                  = thin
    };

    let eval = @ |in_dir : Vec3, out_dir : Vec3| {
        let wo = shading::to_local(surf, out_dir);
        let wi = shading::to_local(surf, in_dir);
        let eval_closure = principled::EvalClosure {
            wo      = wo,
            wi      = wi,
            h       = vec3_normalize(vec3_add(wi, wo)),
            general = closure,
            adjoint = false // TODO?
        };
        
        let is_transmission  = !shading::is_same_hemisphere(wi, wo);
        let upper_hemisphere = shading::is_positive_hemisphere(wi) && shading::is_positive_hemisphere(wo);
        
        let aNdL = shading::abs_cos_theta(wi);

        let mut contrib = black;
        
        // Diffuse part
        if !is_transmission {
            let diffuse_weight = (1 - metallic) * (1 - specular_transmission);

            let retro  = principled::evalRetroDiffuseTerm(eval_closure) * diffuse_weight;
            let sheenf = color_mulf(principled::evalSheenTerm(eval_closure), diffuse_weight);
            contrib    = color_add(contrib, color_add(color_mulf(base_color, retro * aNdL), color_mulf(sheenf, aNdL)));

            let diff = principled::evalDiffuseTerm(eval_closure) * (if thin { 1 - diffuse_transmission } else { diffuse_weight });
            contrib  = color_add(contrib, color_mulf(base_color, diff * aNdL)); 
        }

        if is_transmission && thin {
            let diff = principled::evalDiffuseTerm(eval_closure) * diffuse_transmission;
            contrib  = color_add(contrib, color_mulf(base_color, diff * aNdL)); 
        }

        // Specular part
        contrib = color_add(contrib, principled::evalReflectionTerm(eval_closure));

        if is_transmission {
            let transmission_weight = (1 - metallic) * specular_transmission;
            let trans = principled::evalRefractionTerm(eval_closure);
            contrib = color_add(contrib, color_mulf(trans, transmission_weight));
        }

        // Clearcoat
        if upper_hemisphere {
            contrib = color_add(contrib, principled::evalClearcoatTerm(eval_closure));
        }

        contrib
    };

    Bsdf {
        eval = eval,
        pdf = @ |in_dir, _| cosine_hemisphere_pdf(math_builtins::fabs(vec3_dot(in_dir, surf.local.col(2)))),
        sample = @ |rnd, out_dir, _| {
            let sample = sample_cosine_hemisphere(randf(rnd), randf(rnd));
            let gdir   = vec3_normalize(mat3x3_mul(surf.local, sample.dir));
            let color  = color_mulf(eval(gdir, out_dir), 1/sample.pdf);
            make_bsdf_sample(surf, gdir, sample.pdf, color, false)
        },
        is_specular = false
    }
}