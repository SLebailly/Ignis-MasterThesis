// Creates a microfacet conductor BSDF based on the metallic roughness PBR style
fn @make_metallic_roughness_bsdf_front(surf: SurfaceElement, base_color: Color, metallic: f32, micro: MicrofacetDistribution) -> Bsdf {
    let N = surf.local.col(2);
    
    fn @burley(alpha: f32, cos_o: f32, cos_i: f32, cos_h_i: f32) -> f32 {
        // Burley 2012, "Physically-Based Shading at Disney"
        let f90 = 0.5 + 2 * alpha * cos_h_i * cos_h_i;
        let oS  = schlick_f(1, f90, cos_o);
        let iS  = schlick_f(1, f90, cos_i);
    
        oS * iS / flt_pi
    }

    let eval = @ |in_dir : Vec3, out_dir : Vec3| -> Color {
        let cos_o = absolute_cos(out_dir, N);
        let cos_i = absolute_cos(in_dir, N);

        if cos_o <= flt_eps || cos_i <= flt_eps { return(black) }

        let H = vec3_halfway(in_dir, out_dir);
        let cos_h_i = absolute_cos(in_dir, H);

        let diffuse_color = color_lerp(base_color, black, metallic);
        let f0            = color_lerp(make_gray_color(0.04), base_color, metallic);

        let D = micro.D(H);
        let G = micro.G(in_dir, out_dir, H);
        let F = schlick(f0, white, cos_h_i);

        // Cheaply approximate a isotropic roughness based on (possible) anisotropic roughness
        let alpha = (micro.alpha_u + micro.alpha_v) / 2;

        let Fr = if micro.is_delta { F } else { color_mulf(F, D * G / (4 * cos_o)) };
        let Fd = color_mulf(diffuse_color, burley(alpha, cos_o, cos_i, cos_h_i));

        color_mulf(color_add(Fr, Fd), cos_i)
    };

    if micro.is_delta {
        Bsdf {
            eval   = @ |_, _| black,
            pdf    = @ |_, _| 0,
            sample = @ |_, out_dir, _| {
                let in_dir = vec3_reflect(out_dir, N);
                make_bsdf_sample(surf, in_dir, 1, @eval(in_dir, out_dir), 1, false)
            },
            is_specular = true
        }
    } else {
        Bsdf {
            eval   = eval,
            pdf    = @ |in_dir, out_dir| {
                let H     = vec3_halfway(in_dir, out_dir);
                let dot   = positive_cos(in_dir, H);
                let jacob = 1 / (4 * dot); // Jacobian of the half-direction mapping
                if dot <= flt_eps { return(0) } else { micro.pdf(in_dir, out_dir, H) * jacob }
            },
            sample = @ |rnd, out_dir, _| {
                let cos_o = positive_cos(out_dir, N);
                if cos_o <= flt_eps { return(reject_bsdf_sample()) };

                let s = micro.sample(rnd, out_dir);
                if vec3_len2(s.normal) <= flt_eps { return(reject_bsdf_sample()) };

                let H      = vec3_normalize(s.normal);
                let in_dir = vec3_reflect(out_dir, H);

                let cos_i = positive_cos(in_dir, N);
                if cos_i <= flt_eps { return(reject_bsdf_sample()) };

                let cos_h_o = positive_cos(out_dir, H); // = cos_h_i

                let jacob   = 1 / (4 * cos_h_o); // Jacobian of the half-direction mapping
                let pdf     = s.pdf * jacob;

                let color = color_mulf(@eval(in_dir, out_dir), 1 / pdf);
                make_bsdf_sample(surf, in_dir, pdf, color, 1, false)
            },
            is_specular = false
        }
    }
}

fn @make_metallic_roughness_bsdf(surf: SurfaceElement, base_color: Color, metallic: f32, micro: MicrofacetDistribution) -> Bsdf {
    if !surf.is_entering {
        make_metallic_roughness_bsdf_front(invert_surface_element(surf), base_color, metallic, micro)
    } else {
        make_metallic_roughness_bsdf_front(surf, base_color, metallic, micro)
    }
}
