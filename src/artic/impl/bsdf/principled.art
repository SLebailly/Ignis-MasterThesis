/* Based on the paper:
	BURLEY, Brent; STUDIOS, Walt Disney Animation. Physically-based shading at disney. In: ACM SIGGRAPH. 2012. S. 1-7.
	and code:
	https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf
  And based on the follow-up paper:
    BURLEY, Brent; STUDIOS, Walt Disney Animation. Extending the Disney BRDF to a BSDF with Integrated Subsurface Scattering. (2015).
	https://blog.selfshadow.com/publications/s2015-shading-course/#course_content
*/

mod principled {
use super as all;
use super::math_builtins;
use super::shading;

type SurfaceElement = all::SurfaceElement;
type Color = all::Color;
type Vec3 = all::Vec3;

struct Closure {
    surf:                  SurfaceElement,
    base_color:            Color,
    ior:                   f32,
    diffuse_transmission:  f32,
    specular_transmission: f32,
    specular_tint:         f32,
    roughness:             f32,
    anisotropic:           f32,
    flatness:              f32,
    metallic:              f32, 
    sheen:                 f32,
    sheen_tint:            f32,
    clearcoat:             f32,
    clearcoat_gloss:       f32,
    thin:                  bool,

    eta: f32
}

struct EvalClosure {
    wo: Vec3,
    wi: Vec3,
    h:  Vec3,
    general: Closure,
    adjoint: bool
}

fn @tint_color(color: Color) = super::color_mulf(color, super::safe_div(1, super::color_luminance(color)));
fn @sheen_tint_color(color: Color, tint: f32) = super::color_lerp(super::white, tint_color(color), tint);

fn @getMicro(closure: Closure, roughness: f32, _is_refl: bool) -> all::MicrofacetDistribution {
    let aspect = if closure.anisotropic == 0 { 1 } else { math_builtins::sqrt[f32](1 - closure.anisotropic * 0.9) };
    let ax	   = math_builtins::fmax[f32](0.001, roughness * roughness / aspect);
    let ay	   = math_builtins::fmax[f32](0.001, roughness * roughness * aspect);

    super::make_vndf_ggx_distribution(super::mat3x3_identity(), ax, ay)
}

fn @getReflectionMicro(closure: Closure) = getMicro(closure, closure.roughness, true);
fn @getRefractionMicro(closure: Closure) -> all::MicrofacetDistribution {
    let roughness = if closure.thin { 
        math_builtins::fmax[f32](0.0, math_builtins::fmin[f32](1.0, (0.65 * closure.ior - 0.35) * closure.roughness))
    } else { 
        closure.roughness
    };
    getMicro(closure, roughness, false)
}

fn @evalDisneyFresnelTerm(closure: EvalClosure) -> Color {
    let HdL = super::absolute_cos(closure.wi, closure.h);
    let HdV = super::absolute_cos(closure.wo, closure.h);

    let f1 = super::make_gray_color(super::fresnel(closure.general.eta, HdV).factor);

    let color = tint_color(closure.general.base_color);
    let a  = super::color_lerp(super::white, color, closure.general.specular_tint);
    let r0 = super::color_lerp(super::color_mulf(a, super::schlick_r0(closure.general.eta)), closure.general.base_color, closure.general.metallic);
    let f2 = super::schlick(r0, super::white, HdL);

    super::color_lerp(f1, f2, closure.general.metallic)
}

fn @evalSubsurfaceTerm(closure: EvalClosure) -> f32 {
    let r2    = closure.general.roughness * closure.general.roughness;
    let HdotL = super::vec3_dot(closure.wi, closure.h);
    let fss90 = HdotL * HdotL * r2;
    let aNdL  = shading::abs_cos_theta(closure.wi);
    let aNdV  = shading::abs_cos_theta(closure.wo);
    let lk    = super::schlick_approx(aNdL);
    let vk    = super::schlick_approx(aNdV);

    let fss = (1 - lk + fss90 * lk) * (1 - vk + fss90 * vk);
    1.25 * (fss * (1 / (aNdL + aNdV + 1e-5) - 0.5) + 0.5)
}

fn @evalSheenTerm(closure: EvalClosure) -> Color {
    let lk = super::schlick_approx(shading::abs_cos_theta(closure.wi));
    super::color_mulf(sheen_tint_color(closure.general.base_color, closure.general.sheen_tint), closure.general.sheen * lk)
}

fn @evalDiffuseTerm(closure: EvalClosure) -> f32 {
    let lk    = super::schlick_approx(shading::abs_cos_theta(closure.wi));
    let vk    = super::schlick_approx(shading::abs_cos_theta(closure.wo));

    let diff  = (1 - 0.5 * lk) * (1 - 0.5 * vk);

    let VdotL = super::vec3_dot(closure.wi, closure.wo);
    let rr    = (VdotL + 1) * closure.general.roughness;
    let retro = rr * (lk + vk + lk * vk * (rr - 1));

    let ss = if closure.general.thin {1 - closure.general.flatness + evalSubsurfaceTerm(closure) * closure.general.flatness } else { 1 };

    super::flt_inv_pi * (diff + retro) * ss
}

fn @evalReflectionTerm(closure: EvalClosure) -> Color {
    let micro = getReflectionMicro(closure.general);

    let F    = evalDisneyFresnelTerm(closure);
    let D    = micro.D(closure.h);
    let G    = micro.G(closure.wi, closure.wo, closure.h);
    let norm = micro.norm(closure.wi, closure.wo, closure.h);

    let jacob = shading::halfway_reflective_jacobian(all::absolute_cos(closure.wo, closure.h));
    super::color_mulf(F, D * G * norm * jacob)
}

fn @evalRefractionTerm(closure: EvalClosure) -> Color {
    let micro = getRefractionMicro(closure.general);

    let HdI   = super::vec3_dot(closure.wi, closure.h);
    let HdO   = super::vec3_dot(closure.wo, closure.h);
    let F     = super::fresnel(closure.general.eta, HdI).factor; 
    let D     = micro.D(closure.h);
    let G     = micro.G(closure.wi, closure.wo, closure.h);
    let norm  = micro.norm(closure.wi, closure.wo, closure.h); // ~ cos_h_i / cos_o

    let jacob  = shading::halfway_refractive_jacobian(closure.general.eta, HdI, HdO);
    let spread = if closure.adjoint { 1 / (closure.general.eta * closure.general.eta) } else { 1 };
    let term   = closure.general.eta * closure.general.eta * (1 - F) * D * G * norm * jacob * spread * super::safe_div(1, shading::abs_cos_theta(closure.wi));

    if closure.general.thin {
        super::color_mulf(
            super::make_color(math_builtins::sqrt[f32](closure.general.base_color.r), math_builtins::sqrt[f32](closure.general.base_color.g), math_builtins::sqrt[f32](closure.general.base_color.b)),
            term)
    } else {
        super::color_mulf(closure.general.base_color, term)
    }
}

fn @evalClearcoatTerm(closure: EvalClosure) -> Color {
    let F0 = 0.04 : f32; // sqr((eta-1)/(eta+1)) IOR 1.5
    let R  = 0.25 : f32;
    let R2 = 0.1 * (1 - closure.general.clearcoat_gloss) + 0.01 * closure.general.clearcoat_gloss;

    let aHdL = super::absolute_cos(closure.wi, closure.h);

    let d    = super::ndf_ggx(super::mat3x3_identity(), closure.h, R2, R2);
    let f    = super::schlick_f(F0, 1, aHdL);
    let g    = super::g_1_smith(super::mat3x3_identity(), closure.wi, closure.h, R, R) * super::g_1_smith(super::mat3x3_identity(), closure.wo, closure.h, R, R);
    let norm = super::compute_microfacet_norm(closure.wi, closure.wo, closure.h, closure.general.surf.local);

    super::make_gray_color(R * d * f * g * norm)
}

struct LobeDistribution {
    diff_refl:  f32,
    diff_trans: f32,
    spec_refl:  f32,
    spec_trans: f32
}

fn @calcLobeDistribution(closure: Closure, wo: Vec3) -> LobeDistribution {
    // if true {return(LobeDistribution{ diff_refl = 1, diff_trans = 0, spec_refl =0, spec_trans = 0 }) }

    let diff_refl = closure.roughness * closure.roughness * (1 - closure.metallic) * (1 - closure.specular_transmission);
    let F         = super::fresnel(closure.eta, shading::abs_cos_theta(wo)).factor;
    let spec_refl = F;

    let has_transmission = closure.diffuse_transmission > 0 || closure.specular_transmission > 0;
    if !has_transmission {
        let norm = diff_refl + spec_refl;
        if norm <= super::flt_eps {
            LobeDistribution{ diff_refl = 1, diff_trans = 0, spec_refl = 0, spec_trans = 0 }
        } else {
            LobeDistribution{ diff_refl = diff_refl / norm, diff_trans = 0, spec_refl = spec_refl / norm, spec_trans = 0 }
        }
    } else {
        let diff_trans = closure.diffuse_transmission * diff_refl;
        let spec_trans = (1 - F) * (1 - closure.metallic) * closure.specular_transmission;

        let norm = diff_refl + spec_refl + diff_trans + spec_trans;
        if norm <= super::flt_eps {
            LobeDistribution{ diff_refl = 1, diff_trans = 0, spec_refl = 0, spec_trans = 0 }
        } else {
            LobeDistribution{ diff_refl = diff_refl / norm, diff_trans = diff_trans / norm, spec_refl = spec_refl / norm, spec_trans = spec_trans / norm }
        }
    }
}
}

// Principled BSDF
fn @make_principled_bsdf(surf: SurfaceElement,
                     base_color: Color,
                     ior: f32, diffuse_transmission: f32, specular_transmission: f32, specular_tint: f32,
                     roughness: f32, anisotropic: f32, flatness: f32, metallic: f32, 
                     sheen: f32, sheen_tint: f32, clearcoat: f32, clearcoat_gloss: f32,
                     thin: bool) -> Bsdf {
    let AIR = 1.0002926 : f32;
    let closure = principled::Closure {
        surf                  = surf,
        base_color            = base_color,
        ior                   = ior,
        diffuse_transmission  = diffuse_transmission,
        specular_transmission = specular_transmission,
        specular_tint         = specular_tint,
        roughness             = roughness,
        anisotropic           = anisotropic,
        flatness              = flatness,
        metallic              = metallic,
        sheen                 = sheen,
        sheen_tint            = sheen_tint,
        clearcoat             = clearcoat,
        clearcoat_gloss       = clearcoat_gloss,
        thin                  = thin,
        eta                   = if !surf.is_entering { ior / AIR } else { AIR / ior },
    };

    let eval = @ |in_dir : Vec3, out_dir : Vec3| -> Color {
        let wo = shading::to_local(surf, out_dir);
        let wi = shading::to_local(surf, in_dir);
        let eval_closure = principled::EvalClosure {
            wo      = wo,
            wi      = wi,
            h       = vec3_halfway(wi, wo),
            general = closure,
            adjoint = false // TODO?
        };
        
        let is_transmission  = !shading::is_same_hemisphere(wi, wo);
        let upper_hemisphere = shading::is_positive_hemisphere(wi) && shading::is_positive_hemisphere(wo);
        
        let aNdL = shading::abs_cos_theta(wi);

        let mut contrib = black;

        // Diffuse part
        if !is_transmission {
            let diffuse_weight = (1 - metallic) * (1 - specular_transmission);

            let diff = principled::evalDiffuseTerm(eval_closure) * (if thin { 1 - diffuse_transmission } else { diffuse_weight });
            contrib  = color_add(contrib, color_mulf(base_color, diff * aNdL)); 

            if !?sheen || (?sheen && sheen > 0) {
                let sheenf = color_mulf(principled::evalSheenTerm(eval_closure), diffuse_weight);
                contrib    = color_add(contrib, color_mulf(sheenf, aNdL));
            }
        }

        if is_transmission && thin {
            if !?diffuse_transmission || (?diffuse_transmission && diffuse_transmission > 0) {
                let diff = principled::evalDiffuseTerm(eval_closure) * diffuse_transmission;
                contrib  = color_add(contrib, color_mulf(base_color, diff * aNdL)); 
            }
        }

        // Specular part
        if is_transmission {
            if !?specular_transmission || (?specular_transmission && specular_transmission > 0) {
                contrib = color_add(contrib, color_mulf(principled::evalRefractionTerm(eval_closure), (1 - metallic) * specular_transmission));
            }
        } else {
            contrib = color_add(contrib, principled::evalReflectionTerm(eval_closure));
        }

        // Clearcoat
        if upper_hemisphere {
            if !?clearcoat || (?clearcoat && clearcoat > 0) {
                contrib = color_add(contrib, color_mulf(principled::evalClearcoatTerm(eval_closure), clearcoat));
            }
        }

        contrib
    };

    Bsdf {
        eval = eval,
        pdf = @ |in_dir, out_dir| -> f32 {
            let wo       = shading::to_local(surf, out_dir);
            let wi       = shading::to_local(surf, in_dir);
            let lobes    = principled::calcLobeDistribution(closure, wo);
            let diff_pdf = cosine_hemisphere_pdf(shading::abs_cos_theta(wi));
            if shading::is_same_hemisphere(wo, wi) {
                let pwo      = shading::make_positive_hemisphere(wo);
                let pwi      = shading::make_positive_hemisphere(wi);
                let micro    = principled::getReflectionMicro(closure);
                let H        = vec3_halfway(pwo, pwi);
                let dot      = vec3_dot(pwo, H); // Is always positive
                let refl_pdf = micro.pdf(pwi, pwo, H) * shading::halfway_reflective_jacobian(dot);

                lobes.diff_refl * diff_pdf + lobes.spec_refl * refl_pdf
            } else {
                let pwo   = shading::make_positive_hemisphere(wo);
                let pwi   = vec3_neg(shading::make_positive_hemisphere(wi));
                let micro = principled::getRefractionMicro(closure);
                let H     = vec3_halfway_refractive(pwo, 1, pwi, closure.eta);
                let cos_i = vec3_dot(pwi, H);
                let cos_o = vec3_dot(pwo, H);

                let trans_pdf = micro.pdf(pwi, pwo, H) * shading::halfway_refractive_jacobian(closure.eta, cos_i, cos_o);

                lobes.diff_trans * diff_pdf + lobes.spec_trans * trans_pdf
            }
        },
        sample = @ |rnd, out_dir, _| {
            let s_return = return;

            let wo    = shading::to_local(surf, out_dir);
            let lobes = principled::calcLobeDistribution(closure, wo);
            let pick  = randf(rnd);

            let sample = if pick < lobes.diff_refl {
                // Diffuse reflection
                let s = sample_cosine_hemisphere(randf(rnd), randf(rnd));
                DirSample { dir = shading::make_same_hemisphere(wo, s.dir),
                            pdf = s.pdf * lobes.diff_refl }
            } else if pick < lobes.diff_refl + lobes.diff_trans {
                // Diffuse transmission
                let s = sample_cosine_hemisphere(randf(rnd), randf(rnd));
                DirSample { dir = vec3_neg(shading::make_same_hemisphere(wo, s.dir)),
                            pdf = s.pdf * lobes.diff_trans }
            } else if pick < lobes.diff_refl + lobes.diff_trans + lobes.spec_trans {
                // Specular transmission
                let pwo   = shading::make_positive_hemisphere(wo);
                let micro = principled::getRefractionMicro(closure);
                let s     = micro.sample(rnd, pwo);
                if vec3_len2(s.normal) <= flt_eps || s.pdf <= flt_eps { s_return(reject_bsdf_sample()) };

                let H     = vec3_normalize(s.normal);
                let cos_o = vec3_dot(pwo, H);
                let fr    = fresnel(closure.eta, cos_o);

                if fr.total {
                    let pwi = vec3_reflect(pwo, H);

                    if shading::is_same_hemisphere(pwo, pwi) {
                        DirSample { dir = shading::make_same_hemisphere(wo, pwi),
                                    pdf = s.pdf * shading::halfway_reflective_jacobian(cos_o) * lobes.spec_trans }
                    } else {
                        s_return(reject_bsdf_sample()) 
                    }
                } else {
                    let pwi = vec3_refract(pwo, H, closure.eta, cos_o, fr.cos_t);

                    if !shading::is_same_hemisphere(pwo, pwi) {
                        DirSample { dir = vec3_neg(shading::make_same_hemisphere(wo, pwi)), 
                                    pdf = s.pdf * shading::halfway_refractive_jacobian(closure.eta, cos_o, fr.cos_t) * lobes.spec_trans }
                    } else {
                        s_return(reject_bsdf_sample()) 
                    }
                }
            } else {
                // Specular reflection
                let pwo   = shading::make_positive_hemisphere(wo);
                let micro = principled::getReflectionMicro(closure);
                let s     = micro.sample(rnd, pwo);
                if vec3_len2(s.normal) <= flt_eps || s.pdf <= flt_eps { s_return(reject_bsdf_sample()) };

                let H     = vec3_normalize(s.normal);
                let cos_o = vec3_dot(pwo, H);
                let pwi   = vec3_reflect(pwo, H);

                if shading::is_same_hemisphere(pwo, pwi) {
                    DirSample { dir = shading::make_same_hemisphere(wo, pwi),
                                pdf = s.pdf * shading::halfway_reflective_jacobian(cos_o) * lobes.spec_refl }
                } else {
                    s_return(reject_bsdf_sample()) 
                }
            };

            if sample.pdf <= flt_eps {
                reject_bsdf_sample()
            } else {
                let s_eta = if shading::is_same_hemisphere(wo, sample.dir) { 1 } else { closure.eta };
                let gdir  = shading::to_world(surf, sample.dir);
                make_option(BsdfSample {
                    in_dir = gdir,
                    pdf    = sample.pdf,
                    color  = color_mulf(eval(gdir, out_dir), 1 / sample.pdf),
                    eta    = s_eta
                })
            }
        },
        is_specular = false // We prevent a roughness = 0, so no chance to be specular
    }
}