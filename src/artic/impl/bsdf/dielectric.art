// Creates a perfect glass BSDF
fn @make_glass_bsdf(surf: SurfaceElement, n1: f32, n2: f32, ks: Color, kt: Color) = Bsdf {
    eval   = @ |_, _| black,
    pdf    = @ |_, _| 0,
    sample = @ |rnd, out_dir, adjoint| {
        let k = if surf.is_entering { n1 / n2 } else { n2 / n1 };
        let n = surf.local.col(2);
        let cos_o = vec3_dot(out_dir, n);

        let fterm = fresnel(k, cos_o);

        if (randf(rnd) > fterm.factor) {
            // Refraction
            let t = vec3_refract(out_dir, n, k, cos_o, fterm.cos_t);
            let adjoint_term = if adjoint { k * k } else { 1 };
            return(make_bsdf_sample(surf, t, 1, color_mulf(kt, adjoint_term), k, true))
        } else {
            // Reflection
            make_bsdf_sample(surf, vec3_reflect(out_dir, n), 1, ks, 1, false)
        }
    },
    is_specular = true
};

//--------------------------------------
// Creates a perfect glass BSDF with thin interface approximation
fn @make_thin_glass_bsdf(surf: SurfaceElement, n1: f32, n2: f32, ks: Color, kt: Color) = Bsdf {
    eval   = @ |_, _| black,
    pdf    = @ |_, _| 0,
    sample = @ |rnd, out_dir, _| {
        let k = if surf.is_entering { n1 / n2 } else { n2 / n1 };
        let N = surf.local.col(2);
        let cos_o = absolute_cos(out_dir, N);

        let fterm = fresnel(k, cos_o);
        let F = /*if fterm.factor < 1.0 {*/ fterm.factor + (1 - fterm.factor) * fterm.factor / (fterm.factor + 1) /*} else { 1.0 }*/;

        if randf(rnd) > F {
            // Refraction
            make_bsdf_sample(surf, vec3_neg(out_dir), 1, kt, 1 /* It is thin*/, true)
        } else {
            // Reflection
            make_bsdf_sample(surf, vec3_normalize(vec3_reflect(out_dir, N)), 1, ks, 1, false)
        }
    },
    is_specular = true
};

//--------------------------------------
// Creates a rough glass BSDF
fn @make_rough_glass_bsdf(surf: SurfaceElement, n1: f32, n2: f32, ks: Color, kt: Color, micro: MicrofacetDistribution) -> Bsdf {
    let eta = if surf.is_entering { n1 / n2 } else { n2 / n1 };
    let N   = surf.local.col(2);

    let eval = @ |in_dir: Vec3, out_dir: Vec3| -> Color {
        // if true { return(white) }
        let cos_i = vec3_dot(N, in_dir);
        let cos_o = vec3_dot(N, out_dir);

        let is_transmission = cos_i * cos_o < 0;

        let H = if is_transmission { vec3_halfway_refractive(in_dir, out_dir, eta) } else { vec3_halfway(in_dir, out_dir) };
        
        let cos_h_i = vec3_dot(H, in_dir);
        let cos_h_o = vec3_dot(H, out_dir);

        let fterm = fresnel(eta, math_builtins::fabs(cos_h_o));
        if micro.is_delta { return(if is_transmission { color_mulf(kt, 1-fterm.factor) } else { color_mulf(ks, fterm.factor) }) }

        let D = micro.D(H);
        let G = micro.G(in_dir, out_dir, H);

        if !is_transmission {
            let jacob = shading::halfway_reflective_jacobian(cos_o); // ~ 1 / (4 * cos_o)
            color_mulf(ks, fterm.factor * D * G * math_builtins::fabs(jacob))
        } else {
            let jacob = shading::halfway_refractive_jacobian(eta, cos_h_i, cos_h_o); // ~ eta * eta * cos_h_i / (cos_h_i + eta * cos_h_o)^2
            let norm  = math_builtins::fabs(safe_div(cos_h_o * jacob, cos_o)); // ~ cos_h_i * cos_h_o / (cos_o * ~cos_i~) * ...
            color_mulf(kt, (1 - fterm.factor) * D * G * norm)
        }
    };

    let pdf = @ |in_dir: Vec3, out_dir: Vec3| -> f32 {
        if micro.is_delta { return(0) }

        let cos_i = vec3_dot(N, in_dir);
        let cos_o = vec3_dot(N, out_dir);

        let is_transmission = cos_i * cos_o < 0;

        let H = if is_transmission { vec3_halfway_refractive(in_dir, out_dir, eta) } else { vec3_halfway(in_dir, out_dir) };

        let cos_h_i = vec3_dot(H, in_dir);
        let cos_h_o = vec3_dot(H, out_dir);

        let fterm = fresnel(eta, math_builtins::fabs(cos_h_o));

        if !is_transmission {
            fterm.factor * micro.pdf(in_dir, out_dir, H) * math_builtins::fabs(shading::halfway_reflective_jacobian(cos_h_o))
        } else {
            (1 - fterm.factor) * micro.pdf(in_dir, out_dir, H) * math_builtins::fabs(shading::halfway_refractive_jacobian(eta, cos_h_i, cos_h_o))
        }
    };

    Bsdf {
        eval   = eval,
        pdf    = pdf,
        sample = @ |rnd, out_dir, adjoint| {
            let cos_o = vec3_dot(N, out_dir);

            let s = micro.sample(rnd, out_dir);
            if vec3_len2(s.normal) <= flt_eps || s.pdf <= flt_eps { return(reject_bsdf_sample()) };

            let oH = vec3_normalize(s.normal);
            let H  = if vec3_dot(oH, out_dir) < 0 { vec3_neg(oH) } else { oH };

            let cos_h_o = vec3_dot(H, out_dir);

            let fterm = fresnel(eta, cos_h_o);

            let (in_dir, sel_pdf) = if (randf(rnd) > fterm.factor) {
                // Refraction
                let dir   = vec3_normalize(vec3_refract(out_dir, H, eta, cos_h_o, fterm.cos_t));
                let jacob = shading::halfway_refractive_jacobian(eta, vec3_dot(H, dir), cos_h_o);
                (dir, (1 - fterm.factor) * if micro.is_delta { 1 } else { math_builtins::fabs(jacob) })
            } else {
                // Reflection
               let dir   = vec3_normalize(vec3_reflect(out_dir, H));
               let jacob = shading::halfway_reflective_jacobian(cos_h_o);
               (dir, fterm.factor * if micro.is_delta { 1 } else { math_builtins::fabs(jacob) })
            };

            let cos_i = vec3_dot(N, in_dir);
            let is_transmission = cos_i * cos_o < 0;
            let adjoint_term = if is_transmission && adjoint { eta * eta } else { 1 };
            make_option(BsdfSample {
                in_dir = in_dir,
                pdf    = s.pdf * sel_pdf,
                color  = color_mulf(eval(in_dir, out_dir), safe_div(adjoint_term, s.pdf * sel_pdf)),
                eta    = if !is_transmission { 1 } else { eta }
            })
        },
        is_specular = micro.is_delta,
    }
}
