static VOLUME_BOUNDS_FLT_MIN = 0.00001:f32;

// struct containing the defining parameters for a homogeneous volume or homgeneous part of a heterogenenous volume
struct VolumeProperties {
    coeff_scattering: Color,
    coeff_absorption: Color,
    coeff_extinction: Color,

    optical_thickness: fn (/* dist */ f32) -> Color
}

// struct allowing access to the properties of each voxel (may enhance random access through top down/bottom up traversal whenever possible)
struct VolumeAccessor{
    properties_at_indx:  fn (/* i */ i32, /* j */ i32, /* k */ i32) -> VolumeProperties,
    dimension_at_indx: fn (/* i */ i32, /* j */ i32, /* k */ i32) -> i32 // returns 1 for a non sparse volume, else return the amount of 1-size voxels covered by this index in each dimension
}

// struct containing all the necessary data for a volume
struct Volume {
    // variables
    width:  i32,
    height: i32,
    depth:  i32,

    // functions
    access_data:       fn () -> VolumeAccessor,
    coord_to_indx:     fn (/* coord */ Vec3) -> (i32, i32, i32),
    indx_to_coord:     fn (/* x */ i32, /* y */ i32, /* z */ i32) -> Vec3,
    is_in_vxl:         fn (/* coord */ Vec3, /* x */ i32, /* y */ i32, /* z */ i32) -> bool,
    bounds:            fn (/* x */ i32, /* y */ i32, /* z */ i32, /* dim */ i32) -> (/* lower */ Vec3, /* upper */ Vec3)
}


fn @make_volume_properties(coeff_scattering: Color, coeff_absorption: Color, coeff_emission: Color) -> VolumeProperties {
    
    let coeff_absorption_t = color_sub(coeff_absorption, coeff_emission);
    let coeff_extinction   = color_add(coeff_scattering, coeff_absorption_t);

    VolumeProperties {
        coeff_scattering = coeff_scattering,
        coeff_absorption = coeff_absorption_t,
        coeff_extinction = coeff_extinction,

        optical_thickness = @|t: f32| color_mulf(coeff_extinction, t),
    }
}

fn @make_volume(width: i32, height: i32, depth: i32, access_data: fn () -> VolumeAccessor) -> Volume {

    let vxl_dimensions = vec3_div(vec3_expand(1:f32), make_vec3(width as f32, height as f32, depth as f32));

    fn @is_in_vxl(coord: Vec3, x: i32, y: i32, z: i32) -> bool {
        let vxl_coord = indx_to_coord(x, y, z);
        let diff      = vec3_abs(vec3_sub(coord, vxl_coord));

        (diff.x < vxl_dimensions.x && diff.y < vxl_dimensions.y && diff.z < vxl_dimensions.z)
    }

    fn @bounds(x: i32, y: i32, z: i32, dim: i32) -> (Vec3, Vec3) {
        let lower = indx_to_coord(x, y, z);
        let upper = vec3_add(lower, vec3_mulf(vxl_dimensions, dim as f32));

        (lower, upper)
    }

    fn @coord_to_indx(coord: Vec3) -> (i32, i32, i32) {

        let scaled_coords = vec3_div(coord, vxl_dimensions);
        
        let x = math_builtins::floor(scaled_coords.x) as i32;
        let y = math_builtins::floor(scaled_coords.y) as i32; 
        let z = math_builtins::floor(scaled_coords.z) as i32;

        (x, y, z)
    }

    fn @indx_to_coord(x: i32, y: i32, z: i32) -> Vec3 {
        vec3_mul(make_vec3((x as f32), (y as f32), (z as f32)), vxl_dimensions)
    }

    fn @_indx_to_coord_center(x: i32, y: i32, z: i32) -> Vec3 {
        vec3_mul(make_vec3((x as f32) + 0.5, (y as f32) + 0.5, (z as f32) + 0.5), vxl_dimensions)
    }
/*
    fn @vxl_at_indx(x: i32, y: i32, z: i32) -> VolumeVoxel {

        //clamp between 0 and width-height-depth
        let xs = if x < 0 { 0 } else if x >= width  { width  - 1 } else { x };
        let ys = if y < 0 { 0 } else if y >= height { height - 1 } else { y };
        let zs = if z < 0 { 0 } else if z >= depth  { depth  - 1 } else { z };

        read_voxel(xs, ys, zs)
    }

    fn @vxl_at_coord(coord: Vec3) -> VolumeVoxel {

        let (x, y, z) = coord_to_indx(coord);

        vxl_at_indx(x, y, z) 
    }

*/
/*
    fn @vxl_at_coord_lerp(coord: Vec3) -> VolumeVoxel {

        let (ind_x, ind_y, ind_z) = coord_to_indx(coord);
        
        let vxl_center = indx_to_coord_center(ind_x, ind_y, ind_z);
        let lcoord     = vec3_div(vec3_sub(coord, vxl_center), vxl_dimensions);

        let (x_0, x_1, t_x) = if lcoord.x < 0 { (ind_x - 1, ind_x, 1:f32 + lcoord.x) } else { (ind_x, ind_x + 1, lcoord.x) };
        let (y_0, y_1, t_y) = if lcoord.y < 0 { (ind_y - 1, ind_y, 1:f32 + lcoord.y) } else { (ind_y, ind_y + 1, lcoord.y) };
        let (z_0, z_1, t_z) = if lcoord.z < 0 { (ind_y - 1, ind_y, 1:f32 + lcoord.z) } else { (ind_z, ind_z + 1, lcoord.z) };
        
        let vxl_00 = vxl_lerp(vxl_at_indx(x_0, y_0, z_0), vxl_at_indx(x_1, y_0, z_0), t_x);
        let vxl_01 = vxl_lerp(vxl_at_indx(x_0, y_0, z_1), vxl_at_indx(x_1, y_0, z_1), t_x);
        let vxl_10 = vxl_lerp(vxl_at_indx(x_0, y_1, z_0), vxl_at_indx(x_1, y_1, z_0), t_x);
        let vxl_11 = vxl_lerp(vxl_at_indx(x_0, y_1, z_1), vxl_at_indx(x_1, y_1, z_1), t_x);

        let vxl_0 = vxl_lerp(vxl_00, vxl_01, t_y);
        let vxl_1 = vxl_lerp(vxl_10, vxl_11, t_y);

        vxl_lerp(vxl_0, vxl_1, t_z)
    }
*/

    Volume {
        width  = width,
        height = height,
        depth  = depth,

        access_data = access_data,

        coord_to_indx     = coord_to_indx,
        indx_to_coord     = indx_to_coord,
        //vxl_at_coord_lerp = vxl_at_coord_lerp,
        is_in_vxl         = is_in_vxl,
        bounds            = bounds
    }
}