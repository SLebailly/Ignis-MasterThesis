/**
 * Marches to the bounds of the next voxel, with the ability to skip voxels when the node is sparse
 */
fn @make_hdda_marcher(origin: Vec3, ndir: Vec3, volume: Volume, _interpolate: bool) -> VolumeMarcher {


    let accessor = volume.access_data();
    let inv_dir = make_vec3(safe_rcp(ndir.x), safe_rcp(ndir.y), safe_rcp(ndir.z)); // inverse direction

    let (vxl_indx_x, vxl_indx_y, vxl_indx_z) = volume.coord_to_indx(origin);
    let dim = 1;//let (_current_props, dim) = accessor.properties_at_indx(vxl_indx_x, vxl_indx_y, vxl_indx_z);
    let (indx_x, indx_y, indx_z) = indx_to_sparse_index((vxl_indx_x, vxl_indx_y, vxl_indx_z), dim);

    let t_0 = 0:f32;

    let (lower_bounds, _upper_bounds) = volume.bounds(indx_x, indx_y, indx_z, dim);
    let offset = vec3_sub(lower_bounds, origin);

    let (step_x, t_max_x) = if (inv_dir.x > flt_eps) {
            (1,  t_0 + (offset.x + (dim as f32 * volume.voxel_dimensions.x)) * inv_dir.x)
        } else if (inv_dir.x < -flt_eps) {
            (-1, t_0 + offset.x * inv_dir.x)
        } else {
            (0, flt_max)
        };
    let (step_y, t_max_y) = if (inv_dir.y > flt_eps) {
            (1,  t_0 + (offset.y + (dim as f32 * volume.voxel_dimensions.y)) * inv_dir.y)
        } else if (inv_dir.y < -flt_eps) {
            (-1, t_0 + offset.y * inv_dir.y)
        } else {
            (0, flt_max)
        };
    let (step_z, t_max_z) = if (inv_dir.z > flt_eps) {
            (1,  t_0 + (offset.z + (dim as f32 * volume.voxel_dimensions.z)) * inv_dir.z)
        } else if (inv_dir.y < -flt_eps) {
            (-1, t_0 + offset.z * inv_dir.z)
        } else {
            (0, flt_max)
        };

    
    let t_delta = vec3_mul(vec3_abs(inv_dir), volume.voxel_dimensions);

    /**
     * Mutable variables that can change at each iteration OR when moving between layers of the tree
     */
    let mut m_dim = dim;
    let mut m_t_0 = t_0;
    let mut m_indx_x = indx_x;
    let mut m_indx_y = indx_y;
    let mut m_indx_z = indx_z;
    let mut m_t_max  = make_vec3(t_max_x, t_max_y, t_max_z); // = "mNext" in OpenVDB's implementation
    let mut m_t_total = 0:f32;

    if (m_t_max.x > 1) {
        print_vec3(offset);
        print_i32(dim);
        print_vec3(volume.voxel_dimensions);
        print_vec3(inv_dir);
        print_vec3(m_t_max);
        print_string("\n");
    }
    // helper
    fn @step_axis(next: f32, delta: f32, current: i32, step: i32) -> (/* new_t_max<axis> */ f32, /* new_current<axis> */ i32) {
        let next_ = if (next < m_t_0) { next + (m_t_0 - 0.999999 * next + 0.000001) } else { next };

        (next_ + (m_dim as f32 * delta), current + (m_dim * step))
    }

    // helper
    fn @step_dimx() -> (/* new_t_max */ Vec3, /* new_current */ (i32, i32, i32)) {
        let (new_t_max_x, new_current_x) = step_axis(m_t_max.x, t_delta.x, m_indx_x, step_x);
        let new_t_max = make_vec3(new_t_max_x, m_t_max.y, m_t_max.z);
        let new_current = (new_current_x, m_indx_y, m_indx_z);
        m_t_0 = new_t_max_x;
        
        (new_t_max, new_current)
    }

    // helper
    fn @step_dimy() -> (/* new_t_max */ Vec3, /* new_current */ (i32, i32, i32)) {
        let (new_t_max_y, new_current_y) = step_axis(m_t_max.y, t_delta.y, m_indx_y, step_y);
        let new_t_max = make_vec3(m_t_max.x, new_t_max_y, m_t_max.z);
        let new_current = (m_indx_x, new_current_y, m_indx_z);
        m_t_0 = new_t_max_y;

        (new_t_max, new_current)
    }

    // helper
    fn @step_dimz() -> (/* new_t_max */ Vec3, /* new_current */ (i32, i32, i32)) {
        let (new_t_max_z, new_current_z) = step_axis(m_t_max.z, t_delta.z, m_indx_z, step_z);
        let new_t_max = make_vec3(m_t_max.x, m_t_max.y, new_t_max_z);
        let new_current = (m_indx_x, m_indx_y, new_current_z);
        m_t_0 = new_t_max_z;

        (new_t_max, new_current)
    }

    // steps to the next node on the selected dimension
    fn @step() -> (/* new_t_max */ Vec3, (/* new_x */ i32, /* new_y */ i32, /* new_z */ i32)) {
        select(m_t_max.x < m_t_max.y,
            // if m_t_max.x < m_t_max.y
            select(m_t_max.x < m_t_max.z,
                // if m_t_max.x < m_t_max.z
                step_dimx(),
                // else
                step_dimz()
            ), 
            // else
            select(m_t_max.y < m_t_max.z,
                // if m_t_max.y < m_t_max.z
                step_dimy(),
                // else
                step_dimz()
            )
        )
    }

    // Updates the HDDA to march with the specified dimension
    fn @update_dimension(current_dist: f32, new_dim: i32) {
        let current_pos = vec3_add(origin, vec3_mulf(ndir, current_dist));
        let (voxel_x, voxel_y, voxel_z) = indx_to_sparse_index(volume.coord_to_indx(origin), new_dim);

        let (lower_bounds, _upper_bounds) = volume.bounds(voxel_x, voxel_y, voxel_z, new_dim);
        let offset = vec3_sub(lower_bounds, current_pos);

        let new_t_max = make_vec3(
            // x-axis
            if (step_x == 0) {
                m_t_max.x
            } else {
                if (step_x > 0) { m_t_0 + (offset.x + (new_dim as f32 * volume.voxel_dimensions.x)) * inv_dir.x } else { m_t_0 + offset.x * inv_dir.x }
            },
            // y-axis
            if (step_y == 0) {
                m_t_max.y
            } else {
                if (step_y > 0) { m_t_0 + (offset.y + (new_dim as f32 * volume.voxel_dimensions.y)) * inv_dir.y } else { m_t_0 + offset.y * inv_dir.y }
            },
            // z-axis
            if (step_z == 0) {
                m_t_max.z
            } else {
                if (step_z > 0) { m_t_0 + (offset.z + (new_dim as f32 * volume.voxel_dimensions.z)) * inv_dir.z } else { m_t_0 + offset.z * inv_dir.z }
            }
        );

        m_dim = new_dim;

        m_t_max = new_t_max;
        m_indx_x  = voxel_x;
        m_indx_y  = voxel_y;
        m_indx_z  = voxel_z;
    }


    VolumeMarcher {
        has_next     = @|| {
            m_indx_x >= 0 && m_indx_x < volume.width && m_indx_y >= 0 && m_indx_y < volume.height && m_indx_z >= 0 && m_indx_z < volume.depth
        },
        next_segment = @|| {
            let (current_props_, current_dim) = accessor.properties_at_indx(m_indx_x, m_indx_y, m_indx_z);
            let current_props = if (current_dim != m_dim) {
                update_dimension(m_t_total, current_dim);
                let (updated_current_props, _updated_dim) = accessor.properties_at_indx(m_indx_x, m_indx_y, m_indx_z);
                updated_current_props
            } else {
                current_props_
            };

            let (new_t_max, (new_x, new_y, new_z)) = step();
            let new_t_total = math_builtins::fmin(m_t_max.x, math_builtins::fmin(m_t_max.y, m_t_max.z));
            let t           = new_t_total - m_t_total;

            let segment = PathSegment {
                distance       = t,
                local_properties = current_props
            };

            m_t_total = new_t_total;
            
            m_t_max   = new_t_max;
            m_indx_x  = new_x;
            m_indx_y  = new_y;
            m_indx_z  = new_z;
        
            // return
            (segment, new_t_total)
        }
    }
}