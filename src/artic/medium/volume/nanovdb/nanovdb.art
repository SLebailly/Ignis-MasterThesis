
fn @make_nvdb_volume_f32(buffer: DeviceBuffer, principled_volume_shader: VolumeShader[PrincipledVolumeValues]) -> Volume {

    let tree = make_nvdb_tree[f32, f32](buffer, 4, 4, @|bf, i| bf.load_f32(i), @|bf, i| bf.load_f32(i));

    let ((x_min, y_min, z_min), (x_max, y_max, z_max)) = tree.access_root_node(tree.access_tree_data().get_node_address_root(true)).get_bounding_box(true);
    let width  = (x_max - x_min) + 1;
    let height = (y_max - y_min) + 1;
    let depth  = (z_max - z_min) + 1;

    fn @clamp_index(i: i32, j: i32, k: i32) -> (i32, i32, i32) {
        //clamp between 0 and width-height-depth
        let is = if i < 0 { 0 } else if i >= width  { width  - 1 } else { i };
        let js = if j < 0 { 0 } else if j >= height { height - 1 } else { j };
        let ks = if k < 0 { 0 } else if k >= depth  { depth  - 1 } else { k };

        //(is, js, ks)
        (is + x_min, js + y_min, ks + z_min)
    }

    fn @make_nvdb_accessor() -> VolumeAccessor {
        
        VolumeAccessor {
            properties_at_indx = @|i, j, k| {
                let value = top_down_get_value(tree, clamp_index(i, j, k));

                principled_volume_shader.volume_properties(make_principled_volume_values(value, 0))
            },
            dimension_at_indx = @|_i, _j, _k| {
                //TODO: implement this
                1
            }
        }

    }

    make_volume(width, height, depth, make_nvdb_accessor)
}
