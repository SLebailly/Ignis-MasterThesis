
// aligns a buffer index to the next 32B-aligned address
fn @align_32(index: i32) -> i32 {
    let offset = (32 - (index % 32));
    let result = if offset == 32 { index } else { index + offset };
    
    result
}

// loads an u64 out of the buffer
fn @buffer_load_u64(buffer: DeviceBuffer, data_address: i32) -> u64 {
    let data_1 = buffer.load_i32(data_address)     as u64;
    let data_2 = buffer.load_i32(data_address + 1) as u64;
    (data_2 << 32 | data_1)
}

// Converts a buffer address to the Ignise Buffer ID (= divide by 4)
fn @convert_address(address: i32) -> i32 {
    (address >> 2) // divide by 4
}
  
fn @check_mask(buffer: DeviceBuffer, mask_address: i32, bit: i32) -> bool {
    // 32 bit word size
    //                                                         bit  / 32
    let word = buffer.load_i32(convert_address(mask_address) + (bit >> 5));
    //                   modulo
    (word & (1:i32 << (bit & 31))) != 0
}

fn @root_indices_to_key(i: i32, j: i32, k: i32) -> u64 {
    let child_total = 12 as u64;
    (bitcast[u32](k) as u64 >> child_total) | ((bitcast[u32](j) as u64 >> child_total) << 21) | ((bitcast[u32](i) as u64 >> child_total) << 42)
}

fn @upper_indices_to_array_index(i: i32, j: i32, k: i32) -> i32 {
    let mask = (1:u64 << (12 as u64)) - 1;
    let log2dim_u64 = 5 as u64; // 4 = lower internal,  5 = upper internal
    let child_total = 7 as u64; // 3 = leaf, 7 = lower internal, 12 = upper internal

    ((((bitcast[u32](i) as u64 & mask) >> child_total) << (2 * log2dim_u64)) | (((bitcast[u32](j) as u64 & mask) >> child_total) << log2dim_u64) | ((bitcast[u32](k) as u64 & mask) >> child_total)) as i32
}

fn @lower_indices_to_array_index(i: i32, j: i32, k: i32) -> i32 {
    let mask = (1:u64 << (7 as u64)) - 1;
    let log2dim_u64 = 4 as u64; // 4 = lower internal,  5 = upper internal
    let child_total = 3 as u64; // 3 = leaf, 7 = lower internal, 12 = upper internal

    ((((bitcast[u32](i) as u64 & mask) >> child_total) << (2 * log2dim_u64)) | (((bitcast[u32](j) as u64 & mask) >> child_total) << log2dim_u64) | ((bitcast[u32](k) as u64 & mask) >> child_total)) as i32
}

fn @leaf_indices_to_array_index(i: i32, j: i32, k: i32) -> i32 {
    let log2dim_u64 = 3 as u64;
    let mask = (1:u64 << log2dim_u64) - 1:u64;

    (((bitcast[u32](i) as u64 & mask) << (2:u64 * log2dim_u64)) | ((bitcast[u32](j) as u64 & mask) << log2dim_u64) | (bitcast[u32](k) as u64 & mask)) as i32
}