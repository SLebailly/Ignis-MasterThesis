struct KeyAddressPair[KeyT] {
    key:     KeyT,
    address: i32,
}

struct AccessPath {
    sparse_dim: i32,
    upper_node: Option[KeyAddressPair[u64]],
    lower_node: Option[KeyAddressPair[i32]],
    leaf_node:  Option[KeyAddressPair[i32]]
}

fn @make_key_address_pair[KeyT](key: KeyT, address: i32) = KeyAddressPair[KeyT] {
    key     = key,
    address = address
};

fn @make_empty_path() = AccessPath {
    sparse_dim = 999999,
    upper_node = Option[KeyAddressPair[u64]]::None,
    lower_node = Option[KeyAddressPair[i32]]::None,
    leaf_node  = Option[KeyAddressPair[i32]]::None
};

fn @make_sparse_upper_path() = AccessPath {
    sparse_dim = 4096,
    upper_node = Option[KeyAddressPair[u64]]::None,
    lower_node = Option[KeyAddressPair[i32]]::None,
    leaf_node  = Option[KeyAddressPair[i32]]::None
};

fn @make_sparse_lower_path(upper_node: KeyAddressPair[u64]) = AccessPath {
    sparse_dim = 128,
    upper_node = Option[KeyAddressPair[u64]]::Some(upper_node),
    lower_node = Option[KeyAddressPair[i32]]::None,
    leaf_node  = Option[KeyAddressPair[i32]]::None
};

fn @make_sparse_leaf_path(upper_node: KeyAddressPair[u64], lower_node: KeyAddressPair[i32]) = AccessPath {
    sparse_dim = 8,
    upper_node = Option[KeyAddressPair[u64]]::Some(upper_node),
    lower_node = Option[KeyAddressPair[i32]]::Some(lower_node),
    leaf_node  = Option[KeyAddressPair[i32]]::None
};

fn @make_voxel_path(upper_node: KeyAddressPair[u64], lower_node: KeyAddressPair[i32], leaf_node: KeyAddressPair[i32]) = AccessPath {
    sparse_dim = 1,
    upper_node = Option[KeyAddressPair[u64]]::Some(upper_node),
    lower_node = Option[KeyAddressPair[i32]]::Some(lower_node),
    leaf_node  = Option[KeyAddressPair[i32]]::Some(leaf_node)
};

fn @get_max_value[ValueT, StatsT](tree: NanoVDBTree[ValueT, StatsT]) -> ValueT {
    let tree_accessor = tree.access_tree_data();

    // =============== Root level ===============
    let root_address       = tree_accessor.get_node_address_root(false);
    let root_node_accessor = tree.access_root_node(root_address);

    root_node_accessor.get_maximum()
}

fn @get_majorant_from_path[ValueT, StatsT](tree: NanoVDBTree[ValueT, StatsT], path: AccessPath) -> ValueT {


    if let Option[KeyAddressPair[i32]]::Some(leaf_node_pair) = path.leaf_node {
        // =============== Leaf Node Level ===============
        let leaf_node_accessor = tree.access_leaf_node(leaf_node_pair.address);
        return(leaf_node_accessor.get_maximum())
    }

    if let Option[KeyAddressPair[i32]]::Some(lower_node_pair) = path.lower_node {
        // =============== Lower Node Level ===============
        let lower_node_accessor = tree.access_lower_node(lower_node_pair.address);
        let bbox = lower_node_accessor.get_bounds();
        print_string("===================== BBox on lower level: ");
        print_vec3(bbox.min);
        print_string(", ");
        print_vec3(bbox.max);
        print_nl();
        return(lower_node_accessor.get_maximum())
    }

    if let Option[KeyAddressPair[u64]]::Some(upper_node_pair) = path.upper_node {
        // =============== Upper Node Level ===============
        let upper_node_accessor = tree.access_upper_node(upper_node_pair.address);
        let bbox = upper_node_accessor.get_bounds();
        print_string("===================== BBox on upper level: ");
        print_vec3(bbox.min);
        print_string(", ");
        print_vec3(bbox.max);
        print_nl();
        return(upper_node_accessor.get_maximum())
    }

    // =============== Root level ===============
    print_string("================= Root level I guess...\n");
    get_max_value(tree)
}

fn @top_down_get_path[ValueT, StatsT](tree: NanoVDBTree[ValueT, StatsT], (i: i32, j: i32, k: i32), min_dim: i32) -> AccessPath {

    if min_dim > 4096 {
        print_string(":::::MIN_DIM > 4096\n");
        return(make_empty_path())
    }

    let tree_accessor = tree.access_tree_data();

    // =============== Root level ===============
    let root_address       = tree_accessor.get_node_address_root(false);
    let root_tiles_amount  = tree_accessor.get_node_count_upper();
    let root_node_accessor = tree.access_root_node(root_address);
    let root_tile_key      = root_indices_to_key(i, j, k);

    // If no root tile was found with the key, return background color
    if let Option[RootTileAccessor[ValueT]]::Some(root_tile_accessor) = root_node_accessor.access_tile_by_key(root_tile_key, root_tiles_amount) { // = 800 (320 Hex)

        if min_dim > 128 {
            print_string(":::::min_dim > 128 => upper path\n");
            return(make_sparse_upper_path())
        }

        if let Option[i32]::Some(upper_node_address) = root_tile_accessor.get_child_address() {
            // =============== Upper Node Level ===============
            let upper_node_accessor = tree.access_upper_node(upper_node_address);
            let upper_tile_index    = upper_indices_to_array_index(i, j, k);
            let upper_node_pair     = make_key_address_pair(root_tile_key, upper_node_address);
            
            // If the upper tile has no children, return the tile value (if it has one) else return the background value
            if !upper_node_accessor.tile_has_children(upper_tile_index) || min_dim > 8 {
                // lower node is sparse
                let path = make_sparse_lower_path(upper_node_pair);
                return(path)
            }
            // =============== Lower Node Level ===============
            let lower_node_address  = upper_node_accessor.access_tile(upper_tile_index).get_child_address();
            let lower_node_accessor = tree.access_lower_node(lower_node_address);
            let lower_tile_index    = lower_indices_to_array_index(i, j, k);
            let lower_node_pair     = make_key_address_pair(upper_tile_index, lower_node_address);
            // If the lower tile has no children, return the tile value (if it has one) else return the background value
            if !lower_node_accessor.tile_has_children(lower_tile_index) || min_dim > 1 {
                // leaf is sparse
                let path = make_sparse_leaf_path(upper_node_pair, lower_node_pair);
                return(path)
            }

            // =============== Leaf Node Level ===============
            let leaf_node_address  = lower_node_accessor.access_tile(lower_tile_index).get_child_address();
            let leaf_node_pair     = make_key_address_pair(lower_tile_index, leaf_node_address);
            // If the vxl has a value, return the voxel value else return the background value
            let path = make_voxel_path(upper_node_pair, lower_node_pair, leaf_node_pair);
            return(path)
        };
        // child offset of root tile was 0 => Upper node was sparse
        return(make_sparse_upper_path())
    };
    print_string(":::::ROot is sPaRsE\n");
    // Root was sparse
    make_empty_path()
}

// traverse the tree from the root to the bottom to find the value of the Voxel
fn @top_down_access[ValueT, StatsT](tree: NanoVDBTree[ValueT, StatsT], (i: i32, j: i32, k: i32), min_dim: i32) -> (GenericNodeAccessor[ValueT], AccessPath) {

    let tree_accessor = tree.access_tree_data();
   
    // =============== Root level ===============
    let root_address       = tree_accessor.get_node_address_root(false);
    let root_tiles_amount  = tree_accessor.get_node_count_upper();
    let root_node_accessor = tree.access_root_node(root_address);
    let root_tile_key      = root_indices_to_key(i, j, k);

    // If no root tile was found with the key, return background color
    if let Option[RootTileAccessor[ValueT]]::Some(root_tile_accessor) = root_node_accessor.access_tile_by_key(root_tile_key, root_tiles_amount) { // = 800 (320 Hex)

        if min_dim > 4096 {
            let accessor = GenericNodeAccessor[ValueT] {
                get_minimum  = root_node_accessor.get_minimum,
                get_maximum  = root_node_accessor.get_maximum,
                get_value    = root_node_accessor.get_background,
                //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                is_sparse    = false,
                dimension    = 999999
            };
            return(accessor, make_sparse_upper_path())
        }

        if let Option[i32]::Some(upper_node_address) = root_tile_accessor.get_child_address() {
            // =============== Upper Node Level ===============
            let upper_node_accessor = tree.access_upper_node(upper_node_address);
            let upper_tile_index    = upper_indices_to_array_index(i, j, k);
            let upper_node_pair     = make_key_address_pair(root_tile_key, upper_node_address);
            let upper_tile_accessor = upper_node_accessor.access_tile(upper_tile_index);
            let lower_node_sparse   = !upper_node_accessor.tile_has_children(upper_tile_index);

            if min_dim > 128 {
                let accessor = GenericNodeAccessor[ValueT] {
                    get_minimum  = upper_node_accessor.get_minimum,
                    get_maximum  = upper_node_accessor.get_maximum,
                    get_value    = root_node_accessor.get_background,
                    //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                    is_sparse    = false,
                    dimension    = 4096
                };
                return(accessor, make_sparse_upper_path())
            }
            
            // return the tile value (if it has one) else return the background value
            if lower_node_sparse {
                let path = make_sparse_lower_path(upper_node_pair);
                if upper_node_accessor.tile_has_value(upper_tile_index) {
                    let accessor = GenericNodeAccessor[ValueT] {
                        get_minimum  = upper_tile_accessor.get_value,
                        get_maximum  = upper_tile_accessor.get_value,
                        get_value    = upper_tile_accessor.get_value,
                        //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                        is_sparse    = lower_node_sparse,
                        dimension    = 128
                    };
                    return(accessor, path)
                } else {
                    let accessor = GenericNodeAccessor[ValueT] {
                        get_minimum  = root_node_accessor.get_background,
                        get_maximum  = root_node_accessor.get_background,
                        get_value    = root_node_accessor.get_background,
                        //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                        is_sparse    = lower_node_sparse,
                        dimension    = 128
                    };
                    return(accessor, path)
                }
            }
            // =============== Lower Node Level ===============
            let lower_node_address  = upper_tile_accessor.get_child_address();
            let lower_node_accessor = tree.access_lower_node(lower_node_address);
            let lower_tile_index    = lower_indices_to_array_index(i, j, k);
            let lower_node_pair     = make_key_address_pair(upper_tile_index, lower_node_address);
            let lower_tile_accessor = lower_node_accessor.access_tile(lower_tile_index);
            let leaf_node_sparse    = !lower_node_accessor.tile_has_children(lower_tile_index);

            if min_dim > 8 {
                let accessor = GenericNodeAccessor[ValueT] {
                    get_minimum  = lower_node_accessor.get_minimum,
                    get_maximum  = lower_node_accessor.get_maximum,
                    get_value    = root_node_accessor.get_background,
                    //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                    is_sparse    = false,
                    dimension    = 128
                };
                return(accessor, make_sparse_leaf_path(upper_node_pair, lower_node_pair))
            }

            // If the lower tile has no children, return the tile value (if it has one) else return the background value
            if leaf_node_sparse {
                // leaf is sparse
                let path = make_sparse_leaf_path(upper_node_pair, lower_node_pair);
                if lower_node_accessor.tile_has_value(lower_tile_index) {
                    let accessor = GenericNodeAccessor[ValueT] {
                        get_minimum  = lower_tile_accessor.get_value,
                        get_maximum  = lower_tile_accessor.get_value,
                        get_value    = lower_tile_accessor.get_value,
                        //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                        is_sparse    = leaf_node_sparse,
                        dimension    = 8
                    };
                    return(accessor, path)
                } else {
                    let accessor = GenericNodeAccessor[ValueT] {
                        get_minimum  = root_node_accessor.get_background,
                        get_maximum  = root_node_accessor.get_background,
                        get_value    = root_node_accessor.get_background,
                        //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                        is_sparse    = leaf_node_sparse,
                        dimension    = 8
                    };
                    return(accessor, path)
                }
            }

            // =============== Leaf Node Level ===============
            let leaf_node_address  = lower_tile_accessor.get_child_address();
            let leaf_node_accessor = tree.access_leaf_node(leaf_node_address);
            let voxel_index        = leaf_indices_to_array_index(i, j, k);
            let leaf_node_pair     = make_key_address_pair(lower_tile_index, leaf_node_address);
            // If the vxl has a value, return the voxel value else return the background value
            let path = make_voxel_path(upper_node_pair, lower_node_pair, leaf_node_pair);
            if leaf_node_accessor.tile_has_value(voxel_index) {
                // return the value of the vxl
                let accessor = GenericNodeAccessor[ValueT] {
                    get_minimum  = @|| leaf_node_accessor.get_value(voxel_index),
                    get_maximum  = @|| leaf_node_accessor.get_value(voxel_index),
                    get_value    = @|| leaf_node_accessor.get_value(voxel_index),
                    //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                    is_sparse    = true,
                    dimension    = 1
                };
                return(accessor, path)
            } else {
                let accessor = GenericNodeAccessor[ValueT] {
                    get_minimum  = root_node_accessor.get_background,
                    get_maximum  = root_node_accessor.get_background,
                    get_value    = root_node_accessor.get_background,
                    //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
                    is_sparse    = true,
                    dimension    = 1
                };
                return(accessor, path)
            }
        };

        // child offset of root tile was 0 => Upper node was sparse
        let accessor = GenericNodeAccessor[ValueT] {
            get_minimum  = root_tile_accessor.get_value,
            get_maximum  = root_tile_accessor.get_value,
            get_value    = root_tile_accessor.get_value,
            //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
            is_sparse    = true,
            dimension    = 4096
        };
        return(accessor, make_sparse_upper_path())
    };
    // Root was sparse
    let accessor = GenericNodeAccessor[ValueT] {
        get_minimum  = root_node_accessor.get_background,
        get_maximum  = root_node_accessor.get_background,
        get_value    = root_node_accessor.get_background,
        //get_bounds   = Option[fn () -> BBox]::Some(upper_tile_accessor.get_bounds),
        is_sparse    = true,
        dimension    = 999999
    };
    return(accessor, make_empty_path())
}

// traverse the tree from the root to the bottom to find the value of the Voxel
fn @top_down_get_value[ValueT, StatsT](tree: NanoVDBTree[ValueT, StatsT], (i: i32, j: i32, k: i32)) -> (ValueT, AccessPath) {

    let tree_accessor = tree.access_tree_data();
    
    // =============== Root level ===============
    let root_address       = tree_accessor.get_node_address_root(false);
    let root_tiles_amount  = tree_accessor.get_node_count_upper();
    let root_node_accessor = tree.access_root_node(root_address);
    let root_tile_key      = root_indices_to_key(i, j, k);

    // If no root tile was found with the key, return background color
    if let Option[RootTileAccessor[ValueT]]::Some(root_tile_accessor) = root_node_accessor.access_tile_by_key(root_tile_key, root_tiles_amount) { // = 800 (320 Hex)
        if let Option[i32]::Some(upper_node_address) = root_tile_accessor.get_child_address() {
            // =============== Upper Node Level ===============
            let upper_node_accessor = tree.access_upper_node(upper_node_address);
            let upper_tile_index    = upper_indices_to_array_index(i, j, k);
            let upper_node_pair     = make_key_address_pair(root_tile_key, upper_node_address);
            
            // If the upper tile has no children, return the tile value (if it has one) else return the background value
            if !upper_node_accessor.tile_has_children(upper_tile_index) {
                // lower node is sparse
                let path = make_sparse_lower_path(upper_node_pair);
                if upper_node_accessor.tile_has_value(upper_tile_index) {
                    return(upper_node_accessor.access_tile(upper_tile_index).get_value(), path)
                } else {
                    return(root_node_accessor.get_background(), path)
                }
            }
            // =============== Lower Node Level ===============
            let lower_node_address  = upper_node_accessor.access_tile(upper_tile_index).get_child_address();
            let lower_node_accessor = tree.access_lower_node(lower_node_address);
            let lower_tile_index    = lower_indices_to_array_index(i, j, k);
            let lower_node_pair     = make_key_address_pair(upper_tile_index, lower_node_address);
            // If the lower tile has no children, return the tile value (if it has one) else return the background value
            if !lower_node_accessor.tile_has_children(lower_tile_index) {
                // leaf is sparse
                let path = make_sparse_leaf_path(upper_node_pair, lower_node_pair);
                if lower_node_accessor.tile_has_value(lower_tile_index) {
                    return(lower_node_accessor.access_tile(lower_tile_index).get_value(), path)
                } else {
                    return(root_node_accessor.get_background(), path)
                }
            }

            // =============== Leaf Node Level ===============
            let leaf_node_address  = lower_node_accessor.access_tile(lower_tile_index).get_child_address();
            let leaf_node_accessor = tree.access_leaf_node(leaf_node_address);
            let voxel_index        = leaf_indices_to_array_index(i, j, k);
            let leaf_node_pair     = make_key_address_pair(lower_tile_index, leaf_node_address);
            // If the vxl has a value, return the voxel value else return the background value
            let path = make_voxel_path(upper_node_pair, lower_node_pair, leaf_node_pair);
            if leaf_node_accessor.tile_has_value(voxel_index) {
                // return the value of the vxl
                return(leaf_node_accessor.get_value(voxel_index), path)
            } else {
                return(root_node_accessor.get_background(), path)
            }
        };
        // child offset of root tile was 0 => Upper node was sparse
        return(root_tile_accessor.get_value(), make_sparse_upper_path())
    };
    // Root was sparse
    (root_node_accessor.get_background(), make_empty_path())
}



//TODO: implement this
// traverse the tree from a previous leaf to the corresponding voxel
fn @bottom_up_get_value[ValueT, StatsT](tree: NanoVDBTree[ValueT, StatsT], (i: i32, j: i32, k: i32), _path: AccessPath) -> (ValueT, AccessPath) {

    let tree_accessor = tree.access_tree_data();

    // =============== Root level ===============
    let root_address       = tree_accessor.get_node_address_root(false);
    let root_tiles_amount  = tree_accessor.get_node_count_upper();
    let root_node_accessor = tree.access_root_node(root_address);
    let root_tile_key      = root_indices_to_key(i, j, k);

    // If no root tile was found with the key, return background color
    if let Option[RootTileAccessor[ValueT]]::Some(root_tile_accessor) = root_node_accessor.access_tile_by_key(root_tile_key, root_tiles_amount) { // = 800 (320 Hex)
        if let Option[i32]::Some(upper_node_address) = root_tile_accessor.get_child_address() {
            // =============== Upper Node Level ===============
            let upper_node_accessor = tree.access_upper_node(upper_node_address);
            let upper_tile_index    = upper_indices_to_array_index(i, j, k);
            let upper_node_pair     = make_key_address_pair(root_tile_key, upper_node_address);
            
            // If the upper tile has no children, return the tile value (if it has one) else return the background value
            if !upper_node_accessor.tile_has_children(upper_tile_index) {
                // lower node is sparse
                let path = make_sparse_lower_path(upper_node_pair);
                if upper_node_accessor.tile_has_value(upper_tile_index) {
                    return(upper_node_accessor.access_tile(upper_tile_index).get_value(), path)
                } else {
                    return(root_node_accessor.get_background(), path)
                }
            }
            // =============== Lower Node Level ===============
            let lower_node_address  = upper_node_accessor.access_tile(upper_tile_index).get_child_address();
            let lower_node_accessor = tree.access_lower_node(lower_node_address);
            let lower_tile_index    = lower_indices_to_array_index(i, j, k);
            let lower_node_pair     = make_key_address_pair(upper_tile_index, lower_node_address);
            // If the lower tile has no children, return the tile value (if it has one) else return the background value
            if !lower_node_accessor.tile_has_children(lower_tile_index) {
                // leaf is sparse
                let path = make_sparse_leaf_path(upper_node_pair, lower_node_pair);
                if lower_node_accessor.tile_has_value(lower_tile_index) {
                    return(lower_node_accessor.access_tile(lower_tile_index).get_value(), path)
                } else {
                    return(root_node_accessor.get_background(), path)
                }
            }

            // =============== Leaf Node Level ===============
            let leaf_node_address  = lower_node_accessor.access_tile(lower_tile_index).get_child_address();
            let leaf_node_accessor = tree.access_leaf_node(leaf_node_address);
            let voxel_index        = leaf_indices_to_array_index(i, j, k);
            let leaf_node_pair     = make_key_address_pair(lower_tile_index, leaf_node_address);
            // If the vxl has a value, return the voxel value else return the background value
            let path = make_voxel_path(upper_node_pair, lower_node_pair, leaf_node_pair);
            if leaf_node_accessor.tile_has_value(voxel_index) {
                // return the value of the vxl
                return(leaf_node_accessor.get_value(voxel_index), path)
            } else {
                return(root_node_accessor.get_background(), path)
            }
        };
        // child offset of root tile was 0 => Upper node was sparse
        return(root_tile_accessor.get_value(), make_sparse_upper_path())
    };
    // Root was sparse
    (root_node_accessor.get_background(), make_empty_path())
}
