/*

struct KeyAddressPair[KeyT] {
    key:     KeyT,
    address: i32,
}

struct AccessPath {
    root:  Option[KeyAddressPair[u64]],
    upper: Option[KeyAddressPair[i32]],
    lower: Option[KeyAddressPair[i32]],
    leaf:  Option[KeyAddressPair[i32]]
}

fn @make_key_address_pair(key: KeyT, address: i32) = KeyAddressPair[KeyT] {
    key     = key,
    address = address
};

fn @make_access_path(root_address: i32, root_key: u64, upper_address: i32, upper_indx: i32, lower_address: i32, lower_indx: i32, leaf_address: i32, leaf_indx: i32) = AccessPath {
    root  = if root_address  != 0 { Option[KeyAddressPair[u64]]::Some(make_key_address_pair(root_key,   root_address))  } else { Option[KeyAddressPair]::None },
    upper = if upper_address != 0 { Option[KeyAddressPair[i32]]::Some(make_key_address_pair(upper_indx, upper_address)) } else { Option[KeyAddressPair]::None },
    lower = if lower_address != 0 { Option[KeyAddressPair[i32]]::Some(make_key_address_pair(lower_indx, lower_address)) } else { Option[KeyAddressPair]::None },
    leaf  = if leaf_address  != 0 { Option[KeyAddressPair[i32]]::Some(make_key_address_pair(leaf_indx,  leaf_address))  } else { Option[KeyAddressPair]::None }
};
*/

 // traverse the tree from the root to the bottom to find the value of the Voxel
 fn @top_down_get_value[ValueT, StatsT](tree: NanoVDBTree[ValueT, StatsT], (i: i32, j: i32, k: i32)) -> ValueT {

    let tree_accessor = tree.access_tree_data();

    // =============== Root level ===============
    let root_address       = tree_accessor.get_node_address_root();
    let root_tiles_amount  = tree_accessor.get_node_count_upper();
    let root_node_accessor = tree.access_root_node(root_address);
    let root_tile_key      = root_indices_to_key(i, j, k);
/*
    print_string("Root Address: ");
    print_i32(root_address);
    print_string("\n");
*/
    // If no tile was found with the key, return background color
    if let Option[RootTileAccessor[ValueT]]::Some(root_tile_accessor) = root_node_accessor.access_tile_by_key(root_tile_key, root_tiles_amount) { // = 800 (320 Hex)#
        /*
        if (i < 0 || j < 0 || k < 0) {
            print_string("Tile was found for key with negative indices\n");
        }
        */
        //print_string("pass root tile\n");
        if let Option[i32]::Some(upper_node_address) = root_tile_accessor.get_child_address() {
            //print_string("pass upper tile\n");
            // =============== Upper Node Level ===============
            let upper_node_accessor = tree.access_upper_node(upper_node_address);
            let upper_tile_index    = upper_indices_to_array_index(i, j, k);
            
            // If the upper tile has no children, return the tile value (if it has one) else return the background value
            if !upper_node_accessor.tile_has_children(upper_tile_index) {
                /*
                //TODO: still sometimes triggers, check in which conditions (boundary index?)
                print_string("upper tile has no children according to map: ");
                print_i32(upper_node_address);
                print_string(" #");
                print_i32(upper_tile_index);
                print_string("\n");
                */
                if upper_node_accessor.tile_has_value(upper_tile_index) {
                    return(upper_node_accessor.access_tile(upper_tile_index).get_value())
                } else {
                    return(root_node_accessor.get_background())
                }
            }
            // =============== Lower Node Level ===============
            let lower_node_address  = upper_node_accessor.access_tile(upper_tile_index).get_child_address();
            let lower_node_accessor = tree.access_lower_node(lower_node_address);
            let lower_tile_index    = lower_indices_to_array_index(i, j, k);
            // If the lower tile has no children, return the tile value (if it has one) else return the background value
            if !lower_node_accessor.tile_has_children(lower_tile_index) {
                /*
                print_string("lower tile has no children according to map: ");
                print_i32(lower_node_address);
                print_string(" #");
                print_i32(lower_tile_index);
                print_string("\n");
                */
                if lower_node_accessor.tile_has_value(lower_tile_index) {
                    return(lower_node_accessor.access_tile(lower_tile_index).get_value())
                } else {
                    return(root_node_accessor.get_background())
                }
            }

            // =============== Leaf Node Level ===============
            let leaf_node_accessor = tree.access_leaf_node(lower_node_accessor.access_tile(lower_tile_index).get_child_address());
            let voxel_index        = leaf_indices_to_array_index(i, j, k);

            //rint_string("leaf address:");
            //print_i32(lower_node_accessor.access_tile(lower_tile_index).get_child_address());

/*
            // ASSERT
            // TODO: remove this for speed up
            let root_max  = to_f32(root_node_accessor.get_maximum());
            let root_min  = to_f32(root_node_accessor.get_minimum());
            let upper_max = to_f32(upper_node_accessor.get_maximum());
            let upper_min = to_f32(upper_node_accessor.get_minimum());
            let lower_max = to_f32(lower_node_accessor.get_maximum());
            let lower_min = to_f32(lower_node_accessor.get_minimum());
            let leaf_max  = to_f32(leaf_node_accessor.get_maximum());
            let leaf_min  = to_f32(leaf_node_accessor.get_minimum());
            if (root_max < upper_max || upper_max < lower_max || lower_max < leaf_max) {
                print_string("[ASSERTION ERROR] Incorrect Maxima: ");
                print_f32(root_max);
                print_string(" > ");
                print_f32(upper_max);
                print_string(" > ");
                print_f32(lower_max);
                print_string(" > ");
                print_f32(leaf_max);
                print_string("\n");
            }
            if (root_min > upper_min || upper_min > lower_min || lower_min > leaf_min) {
                print_string("[ASSERTION ERROR] Incorrect Minima: ");
                print_f32(root_min);
                print_string(" < ");
                print_f32(upper_min);
                print_string(" < ");
                print_f32(lower_min);
                print_string(" < ");
                print_f32(leaf_min);
                print_string(" => ");
                print_i32(root_address);
                print_string(" -> ");
                print_i32(upper_node_address);
                print_string(" -> Tile #");
                print_i32(upper_tile_index);
                print_string(" -> ");
                print_i32(upper_node_accessor.access_tile(upper_tile_index).get_child_address());
                print_string(" -> Tile #");
                print_i32(lower_tile_index);
                print_string(" -> ");
                print_i32(lower_node_accessor.access_tile(lower_tile_index).get_child_address());
                print_string(" -> Voxel #");
                print_i32(voxel_index);
                print_string("\n");
            }
            
            if (upper_node_accessor.access_tile(upper_tile_index).get_child_address() == lower_node_accessor.access_tile(lower_tile_index).get_child_address()) {
                print_i32(root_address);
                print_string(" -> ");
                print_i32(upper_node_address);
                print_string(" -> Tile #");
                print_i32(upper_tile_index);
                print_string(" -> ");
                print_i32(upper_node_accessor.access_tile(upper_tile_index).get_child_address());
                print_string(" -> Tile #");
                print_i32(lower_tile_index);
                print_string(" -> ");
                print_i32(lower_node_accessor.access_tile(lower_tile_index).get_child_address());
                print_string(" -> Voxel #");
                print_i32(voxel_index);
                print_string("\n");
            } else {
                print_string("pass");
            }
*/                    
            // return the value of the leaf node
            return(leaf_node_accessor.get_value(voxel_index))
            
        };
        // child offset of root tile was 0
        //print_string("Warning: Child offset of root tile was 0 or negative\n");
        return(root_tile_accessor.get_value())
    };
    // no root tile matching the computed key was found
    /*
    if (i < 0 || j < 0 || k < 0) {
        print_string("Warning: no matching tile was found for key with negative indices\n");
    } else {
        print_string("Warning: no matching tile was found for key with positive indices\n");
    }
    */
    root_node_accessor.get_background()
}

fn @make_nvdb_voxel_grid_f32(buffer: DeviceBuffer, principled_volume_shader: VolumeShader[PrincipledVolumeValues]) -> VoxelGrid {

    let tree = make_nvdb_tree[f32, f32](buffer, 4, 4, @|bf, i| bf.load_f32(i), @|bf, i| bf.load_f32(i));

    //TODO: make this work on host
    let ((x_min, y_min, z_min), (x_max, y_max, z_max)) = tree.access_root_node(tree.access_tree_data().get_node_address_root()).get_bounding_box();
    let width  = (x_max - x_min) + 1;
    let height = (y_max - y_min) + 1;
    let depth  = (z_max - z_min) + 1;
/*
    print_string("Bounding Box: (");
    print_i32(x_min);
    print_string(", ");
    print_i32(y_min);
    print_string(", ");
    print_i32(z_min);
    print_string(") - (");
    print_i32(x_max);
    print_string(", ");
    print_i32(y_max);
    print_string(", ");
    print_i32(z_max);
    print_string(")\n");
    print_f32(top_down_get_value(tree, (0, 5, 0)));
    print_string(", ");
    print_f32(top_down_get_value(tree, (160, 368, 152)));
    print_string("\n");
*/
/*
    let control_x = width / 2;
    let control_y = height / 2;
    let control_z = depth / 2;
    print_string("Control coordinate ");
    print_i32(control_x);
    print_string(", ");
    print_i32(control_y);
    print_string(", ");
    print_i32(control_z);
    print_string(" with value: ");
    print_f32(top_down_get_value(tree, (control_x, control_y, control_z)));
    print_string("\n");
    print_flush();

    print_string("Control coordinate ");
    print_i32(control_x + 10);
    print_string(", ");
    print_i32(control_y + 10);
    print_string(", ");
    print_i32(control_z + 10);
    print_string(" with value: ");
    print_f32(top_down_get_value(tree, (control_x + 10, control_y + 10, control_z + 10)));
    print_string("\n");
    print_flush();

    print_string("Control coordinate ");
    print_i32(control_x - 10);
    print_string(", ");
    print_i32(control_y - 10);
    print_string(", ");
    print_i32(control_z - 10);
    print_string(" with value: ");
    print_f32(top_down_get_value(tree, (control_x - 10, control_y - 10, control_z - 10)));
    print_string("\n");
    print_flush();
*/
    fn @clamp_index(i: i32, j: i32, k: i32) -> (i32, i32, i32) {
        //clamp between 0 and width-height-depth
        let is = if i < 0 { 0 } else if i >= width  { width  - 1 } else { i };
        let js = if j < 0 { 0 } else if j >= height { height - 1 } else { j };
        let ks = if k < 0 { 0 } else if k >= depth  { depth  - 1 } else { k };

        //(is, js, ks)
        (is + x_min, js + y_min, ks + z_min)
    }

    fn @make_nvdb_accessor() -> VoxelGridAccessor {
        
        //let mut last_path: Option[AccessPath] = Option[AccessPath]::None;
        VoxelGridAccessor {
            vxl_at_indx = @|i, j, k| make_nvdb_voxel(top_down_get_value(tree, clamp_index(i, j, k)), principled_volume_shader)
        }

    }

    make_voxel_grid(width, height, depth, make_nvdb_accessor)

}

fn @make_nvdb_voxel(value: f32, shader: VolumeShader[PrincipledVolumeValues]) -> VolumeVoxel {

    //TODO: right now we use the same value for density and temperature
    let coeffs = shader.volume_coefficients(make_principled_volume_values(value, 0));

    fn @get_extinction() -> Color {
        color_add(coeffs.coeff_absorption, coeffs.coeff_scattering)
    }

    fn @optical_thickness(t: f32) -> Color {
        color_mulf(get_extinction(), t)
    }
    /*
    fn @transmittance(dt: f32) -> Color {
        make_gray_color(1:f32 - (value * dt))
    }
    */

    VolumeVoxel {
        transmittance     = @|t| optical_thickness_to_transmittance(optical_thickness(t)),
        optical_thickness = @|t| optical_thickness(t)
    }
}
