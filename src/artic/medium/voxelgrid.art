struct Voxel {
    sigma_a: Color,
    sigma_s: Color
}

struct VoxelGrid {
  // variables
  buffer: DeviceBuffer,
  buffer_offset: i32,
  width: i32,
  height: i32,
  depth: i32,
  transform: Mat3x4,
  transform_inv: Mat3x4,

  // functions
  get_voxel_at_indices: (x: i32, y: i32, z: i32) -> Voxel,
  get_voxel_at_coordinates: (coord: Vec3) -> Voxel,
  get_voxel_at_local_coordinates: (coord: Vec3) -> Voxel,
  sample_distance: (local_start: Vec3, direction: Vec3, sampled_value: f32) -> (f32, Color), //returns the sampled distance and the sampled transmittance over this distance
}

// >0 if x is greater, <0 if c is greater, =0 if both are equal
fn @compare_optical_thickness(c: Color, x: f32) -> f32 {
  x - color_at(c, vec3_min_index(color_to_vec3(c)))
}

fn @make_voxel_grid(buffer: DeviceBuffer, transform: Mat3x4, transform_inv: Mat3x4) -> VoxelGrid {

  const width  = buffer.load_i32_host(0);
  const height = buffer.load_i32_host(1);
  const depth  = buffer.load_i32_host(2);
  const buffer_offset = 4;


  fn @get_voxel_at_indices(x: i32, y: i32, z: i32) -> Voxel {
    const i = x + (y * width) + (z * width * height);

    // every Voxel consists of 2 Vec3, which each take 4 spots (4th value is discarded)
    Voxel {
      sigma_a = buffer.load_vec3(buffer_offset + (8*i)),
      sigma_s = buffer.load_vec3(buffer_offset + (8*i) + 4)
    }    
  }

  fn @get_voxel_at_local_coordinates(coord: Vec3) -> Voxel {
    const x = math_builtins::floor(coord.x);
    const y = math_builtins::floor(coord.y);
    const z = math_builtins::floor(coord.z);

    get_voxel_at_indices(x, y, z)
  }

  fn @get_voxel_at_coordinates(coord: Vec3) -> Voxel {
    const localCoord = mat3x4_mul(transform_inv, vec3_to_4(coord));

    get_voxel_at_local_coordinates(localCoord)
  }

  //TODO: let this also return the sampled optical thickness
  fn @sample_distance(local_start: Vec3, direction: Vec3, sampled_value: f32) -> (f32, Color) {

    const iterator = make_voxel_iterator(local_start, direction);

    let t: f32 = 0; // the total distance so far
    let accumulated_optical_thickness = make_gray_color(0.0); // the accumulated optical thickness

    let current = iterator.next(iterator);
    while (current.coord.x >= 0 && current.coord.x < width && current.coord.y >= 0 && current.coord.y < height && current.coord.z >= 0 && current.coord.z < depth) { // ensure that we are still within the grid

      const current_voxel = get_voxel_at_local_coordinate(current.coord);
      const extinction_coefficient = color_add(current_voxel.sigma_a, current_voxel.sigma_s);
      const new_accumulated_optical_thickness = color_add(accumulated_optical_thickness, color_mulf(extinction_coefficient, current.t));
      const optical_diff = compare_optical_thickness(new_accumulated_optical_thickness, sampled_value);

      if (optical_diff >= 0) {
        const remaining_t = (optical_diff / sigma_t_p); // compute how far to go in the current voxel before reaching the threshold
        t += remaining_t;
        accumulated_optical_thickness = color_add(accumulated_optical_thickness, color_mulf(extinction_coefficient, remaining_t));

        return((t, accumulated_optical_thickness))
      } else {
        //continue the iteration
        t += current.t;
        current = iterator.next(iterator);
      }
    }

    flt_max
  }

  VoxelGrid {
    buffer        = buffer,
    buffer_offset = 4,
    width         = width,
    height        = height,
    depth         = depth,
    transform     = transform,
    transform_inv = transform_inv

    get_voxel_at_indices            = get_voxel_at_indices,
    get_voxel_at_coordinates        = get_voxel_at_coordinates,
    get_voxel_at_local_coordinates  = get_voxel_at_local_coordinates,
    sample_distance                 = sample_distance,
  }

}


struct VoxelIterator {
  origin: Vec3,
  direction: Vec3,
  current: Vec3, //the current voxel the iterator is in
  t_max: Vec3,
  total_t: f32,

  next: (iterator: VoxelIterator) -> VoxelIteratorResult
}

struct VoxelIteratorResult {
  coord: Vec3, // the coordinate of the voxel
  t: f32       // the distance traveled in this voxel
}

fn @make_voxel_iterator(localOrigin: Vec3, direction: Vec3) -> {
  
  const step_direction = make_vec3(
    math_builtins::copysign(1.0f, direction.x),
    math_builtins::copysign(1.0f, direction.y),
    math_builtins::copysign(1.0f, direction.z)
  );

  const t_delta = make_vec3(
    if direction.x > flt_eps || direction.x < -flt_eps { 1.0 / (direction.x * step_x) } else { flt_max },
    if direction.y > flt_eps || direction.y < -flt_eps { 1.0 / (direction.y * step_y) } else { flt_max },
    if direction.z > flt_eps || direction.z < -flt_eps { 1.0 / (direction.z * step_z) } else { flt_max }
  );

  //iterates through Voxels along the ray, returns a tuple with 
  fn @next(iterator: VoxelIterator) -> VoxelIteratorResult {
  
    const current = Vec3 {
      x = iterator.current.x,
      y = iterator.current.y,
      z = iterator.current.Z
    }
  
    if (iterator.t_max.x < iterator.t_max.y) {
      if (iterator.t_max.x < iterator.t_max.z) {
        iterator.current.x += iterator.step_direction.x;
        iterator.t_max.x += iterator.t_delta.x;
      } else {
        iterator.current.z += iterator.step_direction.z;
        iterator.t_max.z += iterator.t_delta.z;
      }
    } else {
      if (iterator.t_max.y < iterator.t_max.z) {
        iterator.current.y += iterator.step_direction.y;
        iterator.t_max.y += iterator.t_delta.y;
      } else {
        iterator.current.z += iterator.step_direction.z;
        iterator.t_max.z += iterator.t_delta.z;
      }
    }

    const new_total_t = math_builtins::fmin(iterator.t_max.x, math_builtins::fmin(iterator.t_max.y, iterator.t_max.z));
    const t = iterator.total_t - new_total_t;
    iterator.total_t = new_total_t;
  

    VoxelIteratorResult {
      coord = current,
      t = t
    }
  }
  
  
  VoxelIterator {
    origin    = localOrigin,
    direction = direction,
    current   = make_vec3(
      math_builtins::floor(local_start.x),
      math_builtins::floor(local_start.y),
      math_builtins::floor(local_start.z)
    ),
    t_max     = make_vec3(
      if (direction.x > flt_eps || direction.x < -flt_eps) { (x + step_x - local_start.x) / direction.x } else { flt_max },
      if (direction.y > flt_eps || direction.y < -flt_eps) { (y + step_y - local_start.y) / direction.y } else { flt_max },
      if (direction.z > flt_eps || direction.z < -flt_eps) { (z + step_z - local_start.z) / direction.z } else { flt_max }
    ),
    total_t = 0,

    next = next
  }
}
