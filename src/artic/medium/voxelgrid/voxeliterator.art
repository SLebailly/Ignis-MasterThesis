struct VoxelIterator {
    step:    Ind3,
    t_delta: Vec3,
    t_max:   Vec3,

    total_t: f32,
    current_ind: Ind3, // the indices of the current voxel
}

  
struct VoxelIteratorResult {
    vxl_ind: Ind3, // the indices of the voxel
    t:       f32     // the distance traveled in this voxel
}

//iterates through Voxels along the ray, returns a tuple with 
fn @next_vxl_iterator(iterator: VoxelIterator) -> (VoxelIterator, VoxelIteratorResult) {

    let (new_ind, new_t_max) = if iterator.t_max.x < iterator.t_max.y {
        if iterator.t_max.x < iterator.t_max.z {
            (
                ind3_add(iterator.current_ind, make_ind3(iterator.step.x, 0, 0)),
                vec3_add(iterator.t_max,   make_vec3(iterator.t_delta.x, 0, 0))
            )
        } else {
            (
                ind3_add(iterator.current_ind, make_ind3(0, 0, iterator.step.z)),
                vec3_add(iterator.t_max,   make_vec3(0, 0, iterator.t_delta.z))
            )
        }
    } else {
        if iterator.t_max.y < iterator.t_max.z {
            (
                ind3_add(iterator.current_ind, make_ind3(0, iterator.step.y, 0)),
                vec3_add(iterator.t_max,   make_vec3(0, iterator.t_delta.y, 0))
            )
        } else {
            (
                ind3_add(iterator.current_ind, make_ind3(0, 0, iterator.step.z)),
                vec3_add(iterator.t_max,   make_vec3(0, 0, iterator.t_delta.z))
            )
        }
    };

    let ntotal_t = math_builtins::fmin(iterator.t_max.x, math_builtins::fmin(iterator.t_max.y, iterator.t_max.z));
    let t        = ntotal_t - iterator.total_t;

    let new_iterator = VoxelIterator {
        step        = iterator.step,
        t_delta     = iterator.t_delta,
        t_max       = new_t_max,

        current_ind = new_ind,
        total_t     = ntotal_t
    };

    let result = VoxelIteratorResult {
        vxl_ind = iterator.current_ind,
        t = t
    };

    (new_iterator, result)
}

// direction needs to be normalized !!!
fn @make_voxel_iterator(grid: VoxelGrid, local_start: Vec3, direction: Vec3) -> VoxelIterator {
    
    let eps     = 1e-3 : f32;
    let offset_local_start = grid.sanitize_lcoords(local_start, eps);

    // can be negative (depending on direction)
    let step = make_ind3(
        if (direction.x > flt_eps) { 1 } else if (direction.x < flt_eps) { -1 } else { 0 },
        if (direction.y > flt_eps) { 1 } else if (direction.y < flt_eps) { -1 } else { 0 },
        if (direction.z > flt_eps) { 1 } else if (direction.z < flt_eps) { -1 } else { 0 }
    );

    let t_delta = vec3_safediv(grid.vxl_dims, vec3_abs(direction));

    //ASSERT
    if (!grid.lcoords_in_bounds(offset_local_start)) {
        print_string("Assertion failure: creating iterator outside boundaries: ");
        print_vec3(offset_local_start);
        print_string("\n");
    }
    
    let current_ind = grid.to_vxl_indx(offset_local_start);

    let next_vxl_bounds = grid.to_vxl_coords(
        make_ind3(
            if step.x > 0 { current_ind.x + 1 } else { current_ind.x },
            if step.y > 0 { current_ind.y + 1 } else { current_ind.y },
            if step.z > 0 { current_ind.z + 1 } else { current_ind.z }
        )
    );
    
    let t_max = vec3_abs(vec3_safediv(vec3_sub(next_vxl_bounds, local_start), direction));
    

    VoxelIterator {
        step         = step,
        t_delta      = t_delta,
        t_max        = t_max,
        total_t      = 0,
        current_ind  = current_ind
    }
}
