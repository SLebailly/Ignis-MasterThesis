static BUFFER_OFFSET: i32 = 4;


//normalized to 1x1x1
struct VoxelGrid {
    // variables
    width:  i32,
    height: i32,
    depth:  i32,

    // functions
    vxl_at_indx:       fn (/* x */ i32, /* y */ i32, /* z */ i32) -> Voxel,
    vxl_at_coord:      fn (/* coord */ Vec3) -> Voxel,
    vxl_at_coord_lerp: fn (/* coord */ Vec3) -> Voxel,
    coord_to_indx:     fn (/* coord */ Vec3) -> (i32, i32, i32),
    indx_to_coord:     fn (/* x */ i32, /* y */ i32, /* z */ i32) -> Vec3,
    is_in_vxl:         fn (/* coord */ Vec3, /* x */ i32, /* y */ i32, /* z */ i32) -> bool
}

fn @make_voxel_grid(buffer: DeviceBuffer) -> VoxelGrid {
   
    let width  = buffer.load_i32_host(0);
    let height = buffer.load_i32_host(1);
    let depth  = buffer.load_i32_host(2);

    let dimensions = make_vec3(width as f32, height as f32, depth as f32);


    fn @is_in_vxl(coord: Vec3, x: i32, y: i32, z: i32) -> bool {

        let ncoord = vec3_mul(coord, dimensions); // map to coordinate between (0, 0, 0) and (width, height, depth), such that the distance between each voxel is 1
        let lcoord = vec3_sub(ncoord, make_vec3(x as f32, y as f32, z as f32)); // the local coordinate inside the given voxel of the coordinate, between 0 and 1

        (lcoord.x >= 0:f32 && lcoord.x < 1:f32 && lcoord.y >= 0:f32 && lcoord.y < 1:f32 && lcoord.z >= 0:f32 && lcoord.z < 1:f32)
    }


    fn @coord_to_indx(coord: Vec3) -> (i32, i32, i32) {
        
        let x = math_builtins::floor(coord.x) as i32 * width;
        let y = math_builtins::floor(coord.y) as i32 * height;
        let z = math_builtins::floor(coord.z) as i32 * depth;

        (x, y, z)
    }


    fn @indx_to_coord(x: i32, y: i32, z: i32) -> Vec3 {
        vec3_div(make_vec3((x as f32) + 0.5, (y as f32) + 0.5, (z as f32) + 0.5), dimensions)
    }


    fn @vxl_at_indx(x: i32, y: i32, z: i32) -> Voxel {

        if (x < 0 || x >= width || y < 0 || y >= height || z < 0 || z >= depth) {
            
            print_string("WARNING: Accessing out of bounds buffer index\n(");
            print_i32(x);
            print_string(", ");
            print_i32(y);
            print_string(", ");
            print_i32(z);
            print_string(")\n");
            
            return(Voxel {
                sigma_a = make_gray_color(0),
                sigma_s = make_gray_color(0)
            })
        }

        let i = x + (y * width) + (z * width * height);

        // every Voxel consists of 2 Vec3, which each take 4 spots (4th value is discarded)
        Voxel {
            sigma_a = vec3_to_color(buffer.load_vec3(BUFFER_OFFSET + (8*i))),
            sigma_s = vec3_to_color(buffer.load_vec3(BUFFER_OFFSET + (8*i) + 4))
        }   
    }


    fn @vxl_at_coord(coord: Vec3) -> Voxel {

        let (x, y, z) = coord_to_indx(coord);

        vxl_at_indx(x, y, z) 
    }


    fn @vxl_at_coord_lerp(coord: Vec3) -> Voxel {

        let (ind_x, ind_y, ind_z) = coord_to_indx(coord);

        let ncoord = vec3_mul(coord, dimensions); // map to coordinate between (0, 0, 0) and (width, height, depth), such that the distance between each voxel is 1
        let lcoord = vec3_sub(ncoord, make_vec3(ind_x as f32, ind_y as f32, ind_z as f32)); // the local coordinate inside the given voxel of the coordinate, between 0 and 1

        let vxl_00 = vxl_lerp(vxl_at_indx(ind_x, ind_y, ind_z), vxl_at_indx(if (ind_x + 1 < width) { ind_x + 1 } else { ind_x }, ind_y, ind_z), lcoord.x);
        let vxl_01 = vxl_lerp(vxl_at_indx(ind_x, ind_y, ind_z + 1), vxl_at_indx(if (ind_x + 1 < width) { ind_x + 1 } else { ind_x }, ind_y, if (ind_z + 1 < depth) { ind_z + 1 } else { ind_z }), lcoord.x);
        let vxl_10 = vxl_lerp(vxl_at_indx(ind_x, if (ind_y + 1 < height) { ind_y + 1 } else { ind_y }, ind_z), vxl_at_indx(if (ind_x + 1 < width) { ind_x + 1 } else { ind_x }, if (ind_y + 1 < height) { ind_y + 1 } else { ind_y }, ind_z), lcoord.x);
        let vxl_11 = vxl_lerp(vxl_at_indx(ind_x, if (ind_y + 1 < height) { ind_y + 1 } else { ind_y }, ind_z + 1), vxl_at_indx(if (ind_x + 1 < width) { ind_x + 1 } else { ind_x }, if (ind_y + 1 < height) { ind_y + 1 } else { ind_y }, if (ind_z + 1 < depth) { ind_z + 1 } else { ind_z }), lcoord.x);

        let vxl_0 = vxl_lerp(vxl_00, vxl_01, lcoord.y);
        let vxl_1 = vxl_lerp(vxl_10, vxl_11, lcoord.y);

        vxl_lerp(vxl_0, vxl_1, lcoord.z)
    }


    VoxelGrid {
        width  = width,
        height = height,
        depth  = depth,

        coord_to_indx     = coord_to_indx,
        indx_to_coord     = indx_to_coord,
        vxl_at_indx       = vxl_at_indx,
        vxl_at_coord      = vxl_at_coord,
        vxl_at_coord_lerp = vxl_at_coord_lerp,
        is_in_vxl         = is_in_vxl
    }

}