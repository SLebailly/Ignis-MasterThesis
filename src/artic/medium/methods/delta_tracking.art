
// Implementation of the Delta Tracking (Woordcock Tracking, Pseudo Scattering,...) null collision method
// Sample the point of the next light-medium collision along the line of flight:
// 1- determine majorant pdf to make volume homogenenous
// 2- sample a random point along the ray proportionally to said pdf
// 3- at this point, use rejection sampling to determine if the collision is with a real or fictuous particla:
//    a. If fictuous, sample next random point along the ray
//    b. If real, this is the next ray-medium intersection point

// Question 1: How to determine majorant? Is it for the whole medium or for the ray?
//      - Good question! Look for answers in papers
// Question 2: How to determine transmittance at sampled point?
//      - Calculation of transmittance is not defined in this method (at least not necessarily) but CAN be used as a stepwise function: cf. J. Novak - "Residual Ratio Trakcing for Estimating Attenuation in Participating Media" 2.3 Free-flight Sampling & Delta Tracking
fn @make_delta_tracking_medium(_ctx: ShadingContext, pms: PointMapperSet, volume: Volume, phase: PhaseFunction, _interpolate: bool, max_scattering: i32) -> Medium {

    // the values that will be used for clamping the local coordinates
    let loc_min  = vec3_expand(VOLUME_BOUNDS_FLT_MIN);
    let loc_max  = vec3_expand(1 - VOLUME_BOUNDS_FLT_MIN);

    let accessor = volume.access_data(); // storing the accessor at this level to be able to leverage bottom-up traversal for nvdb trees

    /**
     * Evaluates the distance (and corresponding optical thickness) travelled along the ray before reaching the sampled transmittance value in the medium
     */
    fn @next_flight(p_start: Vec3, dir_norm: Vec3, sampled_value_opt: f32) -> (f32, Color, VolumeProperties) {

        fn @next_flight_local(local_start: Vec3, local_dir_norm: Vec3, local_sampled_value_opt: f32) -> (f32, Color, VolumeProperties) {

            let mu_t   = volume.get_majorant_extinction(local_start, local_dir_norm);
            let mu_t_p = vec3_max_value(color_to_vec3(mu_t));
            let sampled_dist = local_sampled_value_opt / mu_t_p;

            let sampled_point = vec3_add(local_start, vec3_mulf(local_dir_norm, sampled_dist));

            let (dist, local_properties) = if volume.is_in_volume(sampled_point) {
                // inside the medium
                let (props, _dim) = accessor.properties_at_indx(volume.coord_to_indx(sampled_point));
                (sampled_dist, props)
            } else {
                // leaving the medium
                (flt_max, make_vacuum_volume_properties())
            };

            (dist, color_mulf(mu_t, sampled_dist), homogenize_nullscattering_properties(local_properties, mu_t))
        }

        let loc_start = vec3_clamp(pms.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end   = vec3_clamp(pms.to_normalized_point(vec3_add(p_start, dir_norm)), loc_min, loc_max);
        let loc_dir   = vec3_sub(loc_end, loc_start);

        let loc_dir_len2 = math_builtins::fmax(flt_eps, vec3_len2(loc_dir));

        // the difference between the normalized vector (length 1) and the vector after transformation to local coordinates is the difference in scale between the distance in local and global coordinates
        let scale_diff          = math_builtins::sqrt(loc_dir_len2);
        let (loc_dist, loc_opt, loc_properties) = if (loc_dir_len2 > flt_eps) {
            next_flight_local(loc_start, vec3_normalize(loc_dir), sampled_value_opt * scale_diff)
        } else {
            (0:f32, make_gray_color(0:f32), make_vacuum_volume_properties())
        };

        //transform the local distance and corresponding optical thickness into global distance/optical thickness
        let dist                = if loc_dist >= flt_max { flt_max } else { loc_dist / scale_diff };
        let opt                 = color_divf(loc_opt, scale_diff);

        (dist, opt, loc_properties)
    }

    /**
     * Evaluates the transmittance between two points in the medium using Ratio Tracking
     */
    fn @eval_tr(rnd: &mut RndState, p_start: Vec3, p_end: Vec3) -> Color {
        let dir_u      = vec3_sub(p_end, p_start);
        let dist       = vec3_len(dir_u);

        let loc_start  = vec3_clamp(pms.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end    = vec3_clamp(pms.to_normalized_point(p_end),   loc_min, loc_max);
        let loc_dir    = vec3_sub(loc_end, loc_start);
        let loc_dist   = vec3_len(loc_dir);
        let loc_dir_norm = vec3_divf(loc_dir, loc_dist);

        let scale_diff = dist / loc_dist;

        let mu_t   = volume.get_majorant_extinction(loc_start, loc_dir_norm);
        let mu_t_p = vec3_max_value(color_to_vec3(mu_t));

        let mut t = 0:f32;
        let mut tr = color_builtins::white;
        let accessor = volume.access_data();

        let mut sampled_dist = sample_dist_proptrans(rnd, mu_t_p) * scale_diff;

        while (t + sampled_dist < loc_dist) {
            let sampled_point = vec3_add(loc_start, vec3_mulf(loc_dir_norm, t));
            let (props, _dim) = accessor.properties_at_indx(volume.coord_to_indx(sampled_point));
            let homogenized_props = homogenize_nullscattering_properties(props, mu_t);
            tr = color_mul(tr, color_div(homogenized_props.coeff_fictional, homogenized_props.coeff_extinction));

            t = t + sampled_dist;
            sampled_dist = sample_dist_proptrans(rnd, mu_t_p) * scale_diff;
        }
        tr
    }


    
    Medium {
        phase = @|_| phase,
        eval  = eval_tr,
        eval_inf = @|_, _| color_builtins::black,
        pdf = |_, _, _| {
            1:f32
        },
        sample = @|rnd, p_start, p_end| {

            // sample value of transmittance (uniformly)
            let sampled_value_tr = sample_transmittance_uniform(rnd);
            // transform the sampled value of transmittance to its corresponding optical thicknes (easier on computation for the iterator)
            let sampled_value_opt = - math_builtins::log(sampled_value_tr); // tr = e^(-opt) <=> opt = - log(tr)


            let dir_u    = vec3_sub(p_end, p_start);
            let max_dist = vec3_len(dir_u);
            let dir_norm = vec3_mulf(dir_u, safe_div(1, max_dist));

            // evaluate the corresponding distance for the sampled value of transmittance
            let (mut dist, opt, props) = next_flight(p_start, dir_norm, sampled_value_opt);
            // clamp the distance to a minimum distance to avoid staying in the same position
            dist = math_builtins::fmax[f32](0.0001, dist);//TODO: potentially lower eps

            // reject samples if the optical thickness is black (no transmittance) or if leaving the medium/hitting another object before interacting with the medium
            if is_black_eps(opt, 1e-3) { return(reject_medium_sample()) }
            if max_dist - dist <= flt_eps { return(reject_medium_sample()) }

            /*
            cf. J. Novak - Monte Carlo Methods for Volumetric Light Transport Simulation (4. Distance Sampling):
            "The distance distribution strictly adheres to the Beer-Lambert law, i.e. it has a PDF proportional to the transmittance along the given ray"
            => pdf = transmittance
            */

            // determine position, transmittance and pdf based on previous calculations
            let pos   = vec3_add(p_start, vec3_mulf(dir_norm, dist));
            let trans = optical_thickness_to_transmittance(opt);
            let pdf   = sampled_value_tr;

            make_medium_sample(pos, pdf, color_divf(trans, pdf), props)
        },
        properties = @|coords| eval_volume_properties(volume, pms, coords),
        is_homogeneous = false,
        max_scattering = max_scattering
    }
}