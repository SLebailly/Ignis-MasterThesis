
// Implementation of Free-path sampling through Regular tracking
// Sample the point of the next light-medium collision along the line of flight:
// 1- compute random sampled value of transmittance between 0 and 1
// 2- sweep along ray and compute the accumulated optical thickness until it first exceeds the sampled value
// 3- coordinates where the accumulated optical thickness exceeds random variable is the sampled point.

fn @make_regular_tracking_medium(ctx: ShadingContext, grid: VoxelGrid, phase: PhaseFunction, interpolate: bool) -> Medium { // check dimensions of matrix, give inverse of Matrix with it

    /**
     * Evaluates the distance (and corresponding optical thickness) travelled along the ray before reaching the sampled transmittance value in the medium
     */
    fn @eval_dist(p_start: Vec3, dir: Vec3, sampled_value_tr: f32) -> (f32, Color) {

        fn @eval_dist_local(local_start: Vec3, direction: Vec3, sampled_value_tr: f32, verbose: bool) -> (f32, Color) {

            let sampled_value_opt = - math_builtins::log(sampled_value_tr);

            let mut dist: f32 = 0; // the total distance so far
            let mut acc_opt_thickness = make_gray_color(0.0);

            let (mut iterator, mut current) = next_vxl_iterator(make_voxel_iterator(grid, local_start, direction));
            
            while (current.ind_x >= 0 && current.ind_x < grid.width && current.ind_y >= 0 && current.ind_y < grid.height && current.ind_z >= 0 && current.ind_z < grid.depth) { // ensure that we are still within the grid

                let current_vxl = if interpolate { grid.vxl_at_coord_lerp(vec3_lerp(current.entry, current.exit, 0.5)) } else { grid.vxl_at_indx(current.ind_x, current.ind_y, current.ind_z) };

                let sigma_t = color_add(current_vxl.sigma_a, current_vxl.sigma_s);
                let opt_thickness_in_vxl = color_mulf(sigma_t, current.t);
    
                let nacc_opt_thickness = color_add(acc_opt_thickness, opt_thickness_in_vxl);

                let min_opt_thickness = vec3_min_value(color_to_vec3(nacc_opt_thickness));

                if (verbose) {
                    print_string("Current indx: (");
                    print_i32(current.ind_x);
                    print_string(", ");
                    print_i32(current.ind_y);
                    print_string(", ");
                    print_i32(current.ind_z);
                    print_string(")\n");
                    print_string("New opt_thickness:\n");
                    print_color(nacc_opt_thickness);
                    print_flush();
                }

                // transmittance goes from 1 (full transparency) down to 0
                if (sampled_value_opt <= min_opt_thickness) {

                    let remaining_opt_thickness_minvalue = sampled_value_opt - vec3_min_value(color_to_vec3(acc_opt_thickness));

                    let min_sigma_t = vec3_min_value(color_to_vec3(sigma_t));
                    if (min_sigma_t < 1e-3 && verbose) {
                        print_string("warning, dividing by zero...\n");
                        print_color(sigma_t);
                        print_color(current_vxl.sigma_a);
                        print_color(current_vxl.sigma_s);
                        print_flush();
                    }
                    let dist_delta = remaining_opt_thickness_minvalue / min_sigma_t; // compute how far to go in the current voxel before reaching the threshold

                    if (verbose) {
                        print_string("Adding distance ");
                        print_f32(dist_delta);
                        print_string(" to total distance ");
                        print_f32(dist);
                        print_string("\n\n");
                        print_flush();
                    }

                    let opt_thickness_delta = color_mulf(sigma_t, dist_delta);

                    acc_opt_thickness = color_add(acc_opt_thickness, opt_thickness_delta);

                    return((dist + dist_delta, acc_opt_thickness))
                } else {
                    //continue the iteration
                    dist += current.t;
                    acc_opt_thickness = nacc_opt_thickness;
                    let (new_iterator, new_current) = next_vxl_iterator(iterator);
                    iterator = new_iterator;
                    current  = new_current;

                    if (verbose) {
                        print_string("Continuing...\n\n");
                        print_flush();
                    }
                }
            }
    
            (flt_max, acc_opt_thickness)
        }

        let loc_start           = ctx.coord.to_normalized_point(p_start);
        let loc_dir             = vec3_sub(ctx.coord.to_normalized_point(vec3_add(p_start, dir)), loc_start);
        let scale_diff          = math_builtins::sqrt(vec3_len2(dir) / vec3_len2(loc_dir));
        let (loc_dist, loc_opt) = eval_dist_local(loc_start, vec3_normalize(loc_dir), sampled_value_tr, false);
        let dist                = loc_dist * scale_diff; //transform the local_distance into global distance
        let opt                 = color_mulf(loc_opt, scale_diff);

        //eval_dist_local(make_vec3(0, 0, 0), make_vec3(1, 0, 0), 0.8, true);

        (dist, opt)
    }


    /**
     * Evaluates the transmittance between two points in the medium
     */
    fn @eval_tr(p_start: Vec3, p_end: Vec3) -> Color {

        fn @eval_opt_local(local_start: Vec3, local_end: Vec3) -> Color {
    
            let dir = vec3_normalize(vec3_sub(local_end, local_start));
            let total_dist = vec3_len(dir);
    
            let mut dist: f32 = 0; // the total distance so far
            let mut acc_opt = make_gray_color(0:f32);

            let (mut iterator, mut current) = next_vxl_iterator(make_voxel_iterator(grid, local_start, dir));

            while (current.ind_x >= 0 && current.ind_x < grid.width && current.ind_y >= 0 && current.ind_y < grid.height && current.ind_z >= 0 && current.ind_z < grid.depth) { // ensure that we are still within the grid
                
                let current_vxl = if interpolate { grid.vxl_at_coord_lerp(vec3_lerp(current.entry, current.exit, 0.5)) } else { grid.vxl_at_indx(current.ind_x, current.ind_y, current.ind_z) };

                let sigma_t = color_add(current_vxl.sigma_a, current_vxl.sigma_s);
    
                let nacc_opt = color_add(acc_opt, color_mulf(sigma_t, current.t));
    
                if (grid.is_in_vxl(local_end, current.ind_x, current.ind_y, current.ind_z)) {
                    let dist_delta = total_dist - dist; // compute how far to go in the current voxel before reaching the threshold
                    let opt_delta = color_mulf(sigma_t, dist_delta);
                    acc_opt = color_add(acc_opt, opt_delta);
    
                    return(acc_opt)
                } else {
                    //continue the iteration
                    dist += current.t;
                    acc_opt = nacc_opt;
                    
                    let (new_iterator, new_current) = next_vxl_iterator(iterator);
                    iterator = new_iterator;
                    current  = new_current;
                }
                
            }
    
            // leaving the grid
            acc_opt
        }


        let loc_start  = ctx.coord.to_normalized_point(p_start);
        let loc_end    = ctx.coord.to_normalized_point(p_end);
        let dir        = vec3_sub(p_end, p_start);
        let ldir       = vec3_sub(loc_end, loc_start);
        let scale_diff = math_builtins::sqrt(vec3_len2(dir) / vec3_len2(ldir));

        let local_opt  = eval_opt_local(loc_start, loc_end);

        optical_thickness_to_transmittance(color_mulf(local_opt, scale_diff))
    }
    
    Medium {
        phase = @|_| phase,
        eval  = @|p_start, p_end| {
            eval_tr(p_start, p_end)
        },
        eval_inf = @|_, _| color_builtins::black,
        pdf = |_, _, _| {
            1:f32
        },
        sample   = @|rnd, p_start, p_end| {
            let dir_u = vec3_sub(p_end, p_start);
            let dist  = vec3_len(dir_u);
            let dir   = vec3_mulf(dir_u, safe_div(1, dist));

            let sampled_value_tr = randf(rnd) * 0.99999;

            let (mut ndist, opt) = eval_dist(p_start, dir, sampled_value_tr);
            ndist = math_builtins::fmin[f32](dist, ndist);

            if (is_black_eps(opt, 1e-3)) { return(reject_medium_sample()) }
            if math_builtins::fabs(dist - ndist) <= flt_eps { return(reject_medium_sample()) }

            let pos = vec3_add(p_start, vec3_mulf(dir, ndist));
            let trans = optical_thickness_to_transmittance(opt);

            let pdf = 1:f32;

            make_medium_sample(pos, pdf, color_divf(trans, pdf))
        },
        is_homogeneous = false
    }
}


