
// Implementation of Free-path sampling through Regular tracking
// Sample the point of the next light-medium collision along the line of flight:
// 1- compute random sampled value of transmittance between 0 and 1
// 2- sweep along ray and compute the accumulated optical thickness until it first exceeds the sampled value
// 3- coordinates where the accumulated optical thickness exceeds random variable is the sampled point.

fn @make_regular_tracking_medium(ctx: ShadingContext, grid: VoxelGrid, phase: PhaseFunction, interpolate: bool) -> Medium {

    // the values that will be used for clamping the local coordinates
    let loc_min = vec3_expand(flt_eps);
    let loc_max = vec3_expand(1-flt_eps);

    /**
     * Evaluates the distance (and corresponding optical thickness) travelled along the ray before reaching the sampled transmittance value in the medium
     */
    fn @eval_dist(p_start: Vec3, dir_norm: Vec3, sampled_value_tr: f32) -> (f32, Color) {

        fn @eval_dist_local(local_start: Vec3, direction: Vec3, sampled_value_tr: f32) -> (f32, Color) {

            // transform the sampled value of transmittance to its corresponding optical thicknes (easier on computation for the iterator)
            let sampled_value_opt = - math_builtins::log(sampled_value_tr); // tr = e^(-opt) <=> opt = - log(tr)

            let mut dist = 0: f32 ; // the total distance so far
            let mut acc_opt_thickness = make_gray_color(0.0); // the accumulated optical thickness

            let (mut iterator, mut current) = next_vxl_iterator(make_voxel_iterator(grid, local_start, direction));
            
            // iterate through the grid
            while (current.ind_x >= 0 && current.ind_x < grid.width && current.ind_y >= 0 && current.ind_y < grid.height && current.ind_z >= 0 && current.ind_z < grid.depth) { // ensure that we are still within the grid

                // get the values at the current position
                let current_vxl = if interpolate {
                    grid.vxl_at_coord_lerp(vec3_lerp(current.entry, current.exit, 0.5)) // if interpolate: the point in the middle between the entry into the voxel and the exit
                } else {
                    grid.vxl_at_indx(current.ind_x, current.ind_y, current.ind_z) // if not interpolate then just the voxel of the index
                };

                // total absorption coefficient in the voxel
                let sigma_t = color_add(current_vxl.sigma_a, current_vxl.sigma_s);
                // corresponding optical thickness (sigma_t * distance in the voxel)
                let opt_thickness_in_vxl = color_mulf(sigma_t, current.t);
                // add the optical thickness to the total
                let new_acc_opt_thickness = color_add(acc_opt_thickness, opt_thickness_in_vxl);
                
                // take the minimum color channel value
                let min_opt_thickness = vec3_min_value(color_to_vec3(new_acc_opt_thickness));

                // optical thickness goes from 0 (full transparency) to sampled value
                if (sampled_value_opt - min_opt_thickness > flt_eps) {
                    //continue the iteration
                    dist += current.t;
                    acc_opt_thickness = new_acc_opt_thickness;
                    let (new_iterator, new_current) = next_vxl_iterator(iterator);
                    iterator = new_iterator;
                    current  = new_current;
                } else {
                    let remaining_opt_thickness_minvalue = sampled_value_opt - vec3_min_value(color_to_vec3(acc_opt_thickness));

                    let min_sigma_t = vec3_min_value(color_to_vec3(sigma_t));
                   
                    let dist_delta = remaining_opt_thickness_minvalue / min_sigma_t; // compute how far to go in the current voxel before reaching the threshold

                    let opt_thickness_delta = color_mulf(sigma_t, dist_delta);

                    acc_opt_thickness = color_add(acc_opt_thickness, opt_thickness_delta);

                    return((dist + dist_delta, acc_opt_thickness))
                }
            }
    
            (flt_max, acc_opt_thickness)
        }

        let loc_start = vec3_clamp(ctx.coord.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end   = vec3_clamp(ctx.coord.to_normalized_point(vec3_add(p_start, dir_norm)), loc_min, loc_max);
        let loc_dir   = vec3_sub(loc_end, loc_start);

        // the difference between the normalized vector (lenght 1) and the vector after transformation to local coordinates is the difference in scale between the distance in local and global coordinates
        let scale_diff          = math_builtins::sqrt(1 / vec3_len2(loc_dir));
        let (loc_dist, loc_opt) = eval_dist_local(loc_start, vec3_normalize(loc_dir), sampled_value_tr);

        //transform the local distance and corresponding optical thickness into global distance/optical thickness
        let dist                = loc_dist * scale_diff;
        let opt                 = color_mulf(loc_opt, scale_diff);

        (dist, opt)
    }

    /**
     * Evaluates the transmittance between two points in the medium
     */
    fn @eval_tr(p_start: Vec3, p_end: Vec3) -> Color {

        let loc_start  = vec3_clamp(ctx.coord.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end    = vec3_clamp(ctx.coord.to_normalized_point(p_end),   loc_min, loc_max);
        let dir_u      = vec3_sub(p_end, p_start);
        let loc_dir    = vec3_sub(loc_end, loc_start);
        let scale_diff = math_builtins::sqrt(vec3_len2(dir_u) / vec3_len2(loc_dir));

        let local_opt  = eval_optical_thickness(grid, loc_start, loc_end, interpolate);

        optical_thickness_to_transmittance(color_mulf(local_opt, scale_diff))
    }

    
    Medium {
        phase = @|_| phase,
        eval  = @|p_start, p_end| {
            eval_tr(p_start, p_end)
        },
        eval_inf = @|_, _| color_builtins::black,
        pdf = |_, _, _| {
            1:f32
        },
        sample = @|rnd, p_start, p_end| {

            // sample value of transmittance (uniformly)
            let sampled_value_tr = randf(rnd) * 0.99999;


            let dir_u    = vec3_sub(p_end, p_start);
            let max_dist = vec3_len(dir_u);
            let dir_norm = vec3_mulf(dir_u, safe_div(1, max_dist));

            // evaluate the corresponding distance for the sampled value of transmittance
            let (mut dist, opt) = eval_dist(p_start, dir_norm, sampled_value_tr);
            // clamp the distance to the maximum distance before hitting an object/leaving the medium
            dist = math_builtins::fmin[f32](max_dist, dist);

            // reject samples if the optical thickness is black (no transmittance) or if leaving the medium/hitting another object before interacting with the medium
            if is_black_eps(opt, 1e-3) { return(reject_medium_sample()) }
            if math_builtins::fabs(max_dist - dist) <= flt_eps { return(reject_medium_sample()) }


            /*
            cf. J. Novak - Monte Carlo Methods for Volumetric Light Transport Simulation (4. Distance Sampling):
            "The distance distribution strictly adheres to the Beer-Lambert law, i.e. it has a PDF proportional to the transmittance along the given ray"
            => pdf = transmittance
            */

            // determine position, transmittance and pdf based on previous calculations
            let pos   = vec3_add(p_start, vec3_mulf(dir_norm, dist));
            let trans = optical_thickness_to_transmittance(opt);
            let pdf   = sampled_value_tr;

            make_medium_sample(pos, pdf, color_divf(trans, pdf))
        },
        is_homogeneous = false
    }
}


