
// Implementation of Free-path sampling through Regular tracking
// Sample the point of the next light-medium collision along the line of flight:
// 1- compute random sampled value of transmittance between 0 and 1
// 2- sweep along ray and compute the accumulated optical thickness until it first exceeds the sampled value
// 3- coordinates where the accumulated optical thickness exceeds random variable is the sampled point.

fn @make_regular_tracking_medium(buffer: DeviceBuffer, phase: PhaseFunction, transform: Mat3x4, transform_inv: Mat3x4) -> Medium { // check dimensions of matrix, give inverse of Matrix with it

    let voxel_grid = make_voxel_grid(buffer, transform, transform_inv);

    /**
     * Evaluates the distance (and corresponding optical thickness) travelled along the ray before reaching the sampled transmittance value in the medium
     */
    fn @eval_dist(grid: VoxelGrid, p_start: Vec3, dir: Vec3, sampled_value_tr: f32) -> (f32, Color) {
        fn @eval_dist_local(local_start: Vec3, direction: Vec3, sampled_value_tr: f32, verbose: bool) -> (f32, Color) {

            let sampled_value_opt = - math_builtins::log(sampled_value_tr);

            let mut dist: f32 = 0; // the total distance so far
            let mut acc_opt_thickness = make_gray_color(0.0);

            let (mut iterator, mut current) = next_vxl_iterator(make_voxel_iterator(grid, local_start, direction));
            
            while (grid.lcoords_in_bounds(grid.to_vxl_coords(current.vxl_ind))) { // ensure that we are still within the grid

                let current_vxl = grid.vxl_at_indx(current.vxl_ind);

                let sigma_t = color_add(current_vxl.sigma_a, current_vxl.sigma_s);
                let opt_thickness_in_vxl = color_mulf(sigma_t, current.t);
    
                let nacc_opt_thickness = color_add(acc_opt_thickness, opt_thickness_in_vxl);

                let min_opt_thickness = vec3_min_value(color_to_vec3(nacc_opt_thickness));

                if (verbose) {
                    print_string("New opt_thickness:\n");
                    print_color(nacc_opt_thickness);
                    print_flush();
                }

                // transmittance goes from 1 (full transparency) down to 0
                if (sampled_value_opt <= min_opt_thickness) {

                    let remaining_opt_thickness_minvalue = sampled_value_opt - vec3_min_value(color_to_vec3(acc_opt_thickness));

                    let min_sigma_t = vec3_min_value(color_to_vec3(sigma_t));
                    if (min_sigma_t < 1e-3 && verbose) {
                        print_string("warning, dividing by zero...\n");
                        print_color(sigma_t);
                        print_color(current_vxl.sigma_a);
                        print_color(current_vxl.sigma_s);
                        print_flush();
                    }
                    let dist_delta = remaining_opt_thickness_minvalue / min_sigma_t; // compute how far to go in the current voxel before reaching the threshold

                    if (verbose) {
                        print_string("Adding distance ");
                        print_f32(dist_delta);
                        print_string(" to total distance ");
                        print_f32(dist);
                        print_string("\n\n");
                        print_flush();
                    }

                    let opt_thickness_delta = color_mulf(sigma_t, dist_delta);

                    acc_opt_thickness = color_add(acc_opt_thickness, opt_thickness_delta);

                    return((dist + dist_delta, acc_opt_thickness))
                } else {
                    //continue the iteration
                    dist += current.t;
                    acc_opt_thickness = nacc_opt_thickness;
                    let (new_iterator, new_current) = next_vxl_iterator(iterator);
                    iterator = new_iterator;
                    current  = new_current;

                    if (verbose) {
                        print_string("Continuing...\n\n");
                        print_flush();
                    }
                }
            }
    
            (flt_max, acc_opt_thickness)
        }

        let loc_start           = grid.to_local_point(p_start);
        let loc_dir             = grid.to_local_dir(dir);
        let scale_diff          = math_builtins::sqrt(vec3_len2(dir) / vec3_len2(loc_dir));
        let (loc_dist, loc_opt) = eval_dist_local(loc_start, vec3_normalize(loc_dir), sampled_value_tr, false);
        let dist                = loc_dist * scale_diff; //transform the local_distance into global distance
        let opt                 = color_mulf(loc_opt, scale_diff);

        (dist, opt)
    }


    /**
     * Evaluates the transmittance between two points in the medium
     */
    fn @eval_tr(grid: VoxelGrid, p_start: Vec3, p_end: Vec3) -> Color {

        fn @eval_opt_local(local_start: Vec3, local_end: Vec3) -> Color {
    
            let dir = vec3_normalize(vec3_sub(local_end, local_start));
            let total_dist = vec3_len(dir);
    
            let mut dist: f32 = 0; // the total distance so far
            let mut acc_opt = make_gray_color(0:f32);

            let (mut iterator, mut current) = next_vxl_iterator(make_voxel_iterator(grid, local_start, dir));

            while (grid.lcoords_in_bounds(grid.to_vxl_coords(current.vxl_ind))) { // ensure that we are still within the grid
                let current_vxl = grid.vxl_at_indx(current.vxl_ind);

                let sigma_t = color_add(current_vxl.sigma_a, current_vxl.sigma_s);
    
                let nacc_opt = color_add(acc_opt, color_mulf(sigma_t, current.t));
    
                if (grid.is_in_voxel(local_end, current.vxl_ind)) {
                    let dist_delta = total_dist - dist; // compute how far to go in the current voxel before reaching the threshold
                    let opt_delta = color_mulf(sigma_t, dist_delta);
                    acc_opt = color_add(acc_opt, opt_delta);
    
                    return(acc_opt)
                } else {
                    //continue the iteration
                    dist += current.t;
                    acc_opt = nacc_opt;
                    
                    let (new_iterator, new_current) = next_vxl_iterator(iterator);
                    iterator = new_iterator;
                    current  = new_current;
                }
                
            }
    
            // leaving the grid
            acc_opt
        }


        let loc_start  = grid.to_local_point(p_start);
        let loc_end    = grid.to_local_point(p_end);
        let dir        = vec3_sub(p_end, p_start);
        let ldir       = vec3_sub(loc_end, loc_start);
        let scale_diff = math_builtins::sqrt(vec3_len2(dir) / vec3_len2(ldir));

        let local_opt  = eval_opt_local(loc_start, loc_end);

        optical_thickness_to_transmittance(color_mulf(local_opt, scale_diff))
    }
    
    Medium {
        phase = @|_| phase,
        eval  = @|p_start, p_end| {
            eval_tr(voxel_grid, p_start, p_end)
        },
        eval_inf = @|_, _| color_builtins::black,
        pdf = |_, _, _| {
            1:f32 //TODO: is this correct?
        },
        sample   = @|rnd, p_start, p_end| {
            let dir_u = vec3_sub(p_end, p_start);
            let dist  = vec3_len(dir_u);
            let dir   = vec3_mulf(dir_u, safe_div(1, dist));

            let sampled_value_tr = randf(rnd) * 0.99999;

            let (mut ndist, opt) = eval_dist(voxel_grid, p_start, dir, sampled_value_tr);
            ndist = math_builtins::fmin[f32](dist, ndist);

            if (is_black_eps(opt, 1e-3)) { return(reject_medium_sample()) }
            if math_builtins::fabs(dist - ndist) <= flt_eps { return(reject_medium_sample()) }

            let pos = vec3_add(p_start, vec3_mulf(dir, ndist));
            let trans = optical_thickness_to_transmittance(opt);

            //let sigma_t = transmittance_to_optical_thickness(trans);
            //let sigma_ind = vec3_min_index(color_to_vec3(sigma_t));
            let pdf = 1:f32;//color_at(trans, sigma_ind) * color_at(sigma_t, sigma_ind);// c.f. homogeneous.art (1 = uniform)

            make_medium_sample(pos, pdf, color_divf(trans, pdf))
        },
        is_homogeneous = false
    }
}


