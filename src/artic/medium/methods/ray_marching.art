// Implementation of a Ray Marching transmittance estimator
// marches along the ray in fixed distance and integrates transmittance
fn @make_ray_marching_medium(_ctx: ShadingContext, pms: PointMapperSet, volume: Volume, phase: PhaseFunction, interpolate: bool, max_scattering: i32, step_distance: f32) -> Medium {

    // the values that will be used for clamping the local coordinates
    let loc_min = vec3_expand(VOLUME_BOUNDS_FLT_MIN);
    let loc_max = vec3_expand(1 - VOLUME_BOUNDS_FLT_MIN);

    /**
     * Evaluates the distance (and corresponding optical thickness) travelled along the ray before reaching the sampled transmittance value in the medium
     */
    fn @next_flight(p_start: Vec3, dir_norm: Vec3, sampled_value_tr: f32) -> (f32, Color, VolumeProperties) {

        fn @next_flight_local(local_start: Vec3, local_dir_norm: Vec3, sampled_value_opt: f32) -> (f32, Color, VolumeProperties) {
            
            let mut acc_opt = make_gray_color(0:f32);

            let volume_marcher  = make_fixed_distance_marcher(local_start, local_dir_norm, volume, step_distance, interpolate); //TODO: ensure that origin is within the volume (max 0.9999)
            while (volume_marcher.has_next()) { // ensure that we are still within the volume
                
                // get the values at the current position
                let (current_segment, current_dist) = volume_marcher.next_segment();

                // total absorption coefficient in the voxel
                // corresponding optical thickness (sigma_t * distance in the voxel)
                let opt_thickness_in_vxl = current_segment.local_properties.optical_thickness(current_segment.distance);

                // add the optical thickness to the total
                let new_acc_opt = color_add(acc_opt, opt_thickness_in_vxl);

                // take the minimum color channel value
                let min_opt_thickness = vec3_min_value(color_to_vec3(new_acc_opt));

                // optical thickness goes from 0 (full transparency) to sampled value
                if (sampled_value_opt - min_opt_thickness > flt_eps) {
                    //continue the iteration
                    acc_opt = new_acc_opt;
                } else {
                    
                    let remaining_opt_thickness_minvalue = sampled_value_opt - vec3_min_value(color_to_vec3(acc_opt));

                    let min_opt = vec3_min_value(color_to_vec3(current_segment.local_properties.coeff_extinction));
                   
                    // min_opt is not zero (tested)
                    let dist_delta = remaining_opt_thickness_minvalue / min_opt; // compute how far to go in the current voxel before reaching the threshold

                    let opt_thickness_delta = current_segment.local_properties.optical_thickness(dist_delta);

                    acc_opt = color_add(acc_opt, opt_thickness_delta);

                    return((current_dist - current_segment.distance + dist_delta, acc_opt, current_segment.local_properties))
                } 
            }
            //TODO: verify if flt_max is accurate here
            (flt_max, acc_opt, make_vacuum_volume_properties())
        }

        let loc_start = vec3_clamp(pms.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end   = vec3_clamp(pms.to_normalized_point(vec3_add(p_start, dir_norm)), loc_min, loc_max);
        let loc_dir   = vec3_sub(loc_end, loc_start);

        let sampled_opt = - math_builtins::log(sampled_value_tr); // tr = e^(-opt) <=> opt = - log(tr)

        let loc_dir_len2 = math_builtins::fmax(flt_eps, vec3_len2(loc_dir));

        // the difference between the normalized vector (length 1) and the vector after transformation to local coordinates is the difference in scale between the distance in local and global coordinates
        let scale_diff          = math_builtins::sqrt(loc_dir_len2);
        let (loc_dist, loc_opt, loc_properties) = if (loc_dir_len2 > flt_eps) { next_flight_local(loc_start, vec3_normalize(loc_dir), sampled_opt * scale_diff) } else { (0:f32, make_gray_color(0:f32), make_vacuum_volume_properties()) };

        //transform the local distance and corresponding optical thickness into global distance/optical thickness
        let dist                = if loc_dist >= flt_max { flt_max } else { loc_dist / scale_diff };
        let opt                 = color_divf(loc_opt, scale_diff);

        (dist, opt, loc_properties)
    }

    /**
     * Evaluates the transmittance between two points in the medium
     */
    fn @eval_tr(p_start: Vec3, p_end: Vec3) -> Color {


        let loc_start  = vec3_clamp(pms.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end    = vec3_clamp(pms.to_normalized_point(p_end),   loc_min, loc_max);
        let dir_u      = vec3_sub(p_end, p_start);
        let loc_dir    = vec3_sub(loc_end, loc_start);
        let scale_diff = math_builtins::sqrt(vec3_len2(dir_u) / math_builtins::fmax(flt_eps, vec3_len2(loc_dir)));

        let local_opt  = eval_optical_thickness(volume, loc_start, loc_end, false);

        optical_thickness_to_transmittance(color_mulf(local_opt, scale_diff))
    }


    
    Medium {
        phase = @|_| phase,
        eval  = @|_, p_start, p_end| {
            eval_tr(p_start, p_end)
        },
        eval_inf = @|_, _| color_builtins::black,
        pdf = |_, _, _| {
            1:f32
        },
        sample = @|rnd, p_start, p_end| {

            // sample value of transmittance (uniformly)
            let sampled_value_tr = randf(rnd) * 0.99999;


            let dir_u    = vec3_sub(p_end, p_start);
            let max_dist = vec3_len(dir_u);
            let dir_norm = vec3_mulf(dir_u, safe_div(1, max_dist));

            // evaluate the corresponding distance for the sampled value of transmittance
            let (mut dist, opt, props) = next_flight(p_start, dir_norm, sampled_value_tr);
            // clamp the distance to a minimum distance to avoid staying in the same position
            dist = math_builtins::fmax[f32](0.0001, dist);//TODO: potentially lower eps

            // reject samples if the optical thickness is black (no transmittance) or if leaving the medium/hitting another object before interacting with the medium
            if is_black_eps(opt, 1e-3) { return(reject_medium_sample()) }
            if max_dist - dist <= flt_eps { return(reject_medium_sample()) }


            /*
            cf. J. Novak - Monte Carlo Methods for Volumetric Light Transport Simulation (4. Distance Sampling):
            "The distance distribution strictly adheres to the Beer-Lambert law, i.e. it has a PDF proportional to the transmittance along the given ray"
            => pdf = transmittance
            */

            // determine position, transmittance and pdf based on previous calculations
            let pos   = vec3_add(p_start, vec3_mulf(dir_norm, dist));
            let trans = optical_thickness_to_transmittance(opt);
            let pdf   = sampled_value_tr;

            make_medium_sample(pos, pdf, color_divf(trans, pdf), props)
        },
        properties = @|coords| eval_volume_properties(volume, pms, coords),
        is_homogeneous = false,
        max_scattering = max_scattering
    }
}


