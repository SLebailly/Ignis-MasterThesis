// Implementation of a Ray Marching transmittance estimator
// marches along the ray in fixed distance and integrates transmittance
fn @make_ray_marching_medium(ctx: ShadingContext, volume: Volume, phase: PhaseFunction, interpolate: bool, step_distance: f32) -> Medium {

    // the values that will be used for clamping the local coordinates
    let loc_min = vec3_expand(flt_eps);
    let loc_max = vec3_expand(1-flt_eps);

    /**
     * Evaluates the distance (and corresponding optical thickness) travelled along the ray before reaching the sampled transmittance value in the medium
     */
    fn @eval_dist(p_start: Vec3, dir_norm: Vec3, sampled_value_tr: f32) -> (f32, Color) {

        fn @eval_dist_local(local_start: Vec3, local_dir_norm: Vec3, sampled_value_tr: f32) -> (f32, Color) {

            // transform the sampled value of transmittance to its corresponding optical thicknes (easier on computation for the iterator)
            let sampled_value_opt = - math_builtins::log(sampled_value_tr); // tr = e^(-opt) <=> opt = - log(tr)
            
            let mut acc_opt = make_gray_color(0:f32);

            let volume_marcher  = make_fixed_distance_marcher(local_start, local_dir_norm, volume, step_distance, interpolate); //TODO: ensure that origin is within the volume (max 0.9999)
            while (volume_marcher.has_next()) { // ensure that we are still within the volume
                
                // get the values at the current position
                let (current_segment, current_dist) = volume_marcher.next_segment();

                // total absorption coefficient in the voxel
                // corresponding optical thickness (sigma_t * distance in the voxel)
                let opt_thickness_in_vxl = current_segment.local_properties.optical_thickness(current_segment.distance);

                // add the optical thickness to the total
                let new_acc_opt = color_add(acc_opt, opt_thickness_in_vxl);

                // take the minimum color channel value
                let min_opt_thickness = vec3_min_value(color_to_vec3(new_acc_opt));

                // optical thickness goes from 0 (full transparency) to sampled value
                if (sampled_value_opt - min_opt_thickness > flt_eps) {
                    //continue the iteration
                    acc_opt = new_acc_opt;
                } else {
                    
                    let remaining_opt_thickness_minvalue = sampled_value_opt - vec3_min_value(color_to_vec3(acc_opt));

                    let min_opt = vec3_min_value(color_to_vec3(current_segment.local_properties.coeff_extinction));
                   
                    let dist_delta = remaining_opt_thickness_minvalue / min_opt; // compute how far to go in the current voxel before reaching the threshold

                    let opt_thickness_delta = current_segment.local_properties.optical_thickness(dist_delta);

                    acc_opt = color_add(acc_opt, opt_thickness_delta);

                    return((current_dist - current_segment.distance + dist_delta, acc_opt))
                } 
            }

            (flt_max, acc_opt)
        }

        let loc_start = vec3_clamp(ctx.coord.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end   = vec3_clamp(ctx.coord.to_normalized_point(vec3_add(p_start, dir_norm)), loc_min, loc_max);
        let loc_dir   = vec3_sub(loc_end, loc_start);

        // the difference between the normalized vector (lenght 1) and the vector after transformation to local coordinates is the difference in scale between the distance in local and global coordinates
        let scale_diff          = math_builtins::sqrt(1 / vec3_len2(loc_dir));
        let (loc_dist, loc_opt) = eval_dist_local(loc_start, vec3_normalize(loc_dir), sampled_value_tr);

        //transform the local distance and corresponding optical thickness into global distance/optical thickness
        let dist                = loc_dist * scale_diff;
        let opt                 = color_mulf(loc_opt, scale_diff);

        (dist, opt)
    }


    /**
     * Evaluates the transmittance between two points in the medium
     */
    fn @eval_tr(p_start: Vec3, p_end: Vec3) -> Color {

        let volume_accessor = volume.access_data();

        fn @eval_tr_local(local_start: Vec3, local_end: Vec3) -> Color {
            let dir_u      = vec3_sub(local_end, local_start);
            let total_dist = vec3_len(dir_u);
            let dir_norm   = vec3_map(dir_u, @|x| safe_div(x, total_dist));
        
            let ray_dt     = vec3_mulf(dir_norm, step_distance);
            let mut acc_trans   = make_gray_color(1:f32);
            let mut current_pos = local_start;
            let mut current_dist = 0:f32;

            //TODO: replace with actual volume_marcher
            while (current_dist < total_dist) { // ensure that we are still within the volume
                let properties = volume_accessor.properties_at_indx(volume.coord_to_indx(current_pos));
                
                let tr = optical_thickness_to_transmittance(properties.optical_thickness(step_distance));
                acc_trans = color_mul(acc_trans, tr);
        
                let remaining_dist = total_dist - current_dist;
                if (remaining_dist < step_distance) {
                    let last_properties = volume_accessor.properties_at_indx(volume.coord_to_indx(local_end));
                    let last_tr = optical_thickness_to_transmittance(last_properties.optical_thickness(remaining_dist));

                    acc_trans = color_mul(acc_trans, last_tr);
                    return(acc_trans)
                } else {
                    //continue the iteration
                    current_dist += step_distance;
                    current_pos = vec3_add(current_pos, ray_dt);
                }
                
            }
        
            // leaving the volume
            acc_trans
        }

        let loc_start  = vec3_clamp(ctx.coord.to_normalized_point(p_start), loc_min, loc_max);
        let loc_end    = vec3_clamp(ctx.coord.to_normalized_point(p_end),   loc_min, loc_max);
        let dir_u      = vec3_sub(p_end, p_start);
        let loc_dir    = vec3_sub(loc_end, loc_start);
        let scale_diff = math_builtins::sqrt(vec3_len2(dir_u) / vec3_len2(loc_dir));

        let local_tr  = eval_tr_local(loc_start, loc_end);

        color_mulf(local_tr, scale_diff)
    }

    
    Medium {
        phase = @|_| phase,
        eval  = @|p_start, p_end| {
            eval_tr(p_start, p_end)
        },
        eval_inf = @|_, _| color_builtins::black,
        pdf = |_, _, _| {
            1:f32
        },
        sample = @|rnd, p_start, p_end| {
            // sample value of transmittance (uniformly)
            let sampled_value_tr = randf(rnd) * 0.99999;

            let dir_u    = vec3_sub(p_end, p_start);
            let max_dist = vec3_len(dir_u);
            let dir_norm = vec3_mulf(dir_u, safe_div(1, max_dist));

            // evaluate the corresponding distance for the sampled value of transmittance
            let (mut dist, opt) = eval_dist(p_start, dir_norm, sampled_value_tr);
            // clamp the distance to the maximum distance before hitting an object/leaving the medium
            dist = math_builtins::fmin[f32](max_dist, dist);

            // reject samples if the optical thickness is black (no transmittance) or if leaving the medium/hitting another object before interacting with the medium
            if is_black_eps(opt, 1e-3) { return(reject_medium_sample()) }
            if math_builtins::fabs(max_dist - dist) <= flt_eps { return(reject_medium_sample()) }

            /*
            cf. J. Novak - Monte Carlo Methods for Volumetric Light Transport Simulation (4. Distance Sampling):
            "The distance distribution strictly adheres to the Beer-Lambert law, i.e. it has a PDF proportional to the transmittance along the given ray"
            => pdf = transmittance
            */

            // determine position, transmittance and pdf based on previous calculations
            let pos   = vec3_add(p_start, vec3_mulf(dir_norm, dist));
            let trans = optical_thickness_to_transmittance(opt);
            let pdf   = sampled_value_tr;

            make_medium_sample(pos, pdf, color_divf(trans, pdf))
        },
        is_homogeneous = false
    }
}


