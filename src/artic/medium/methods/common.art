fn @eval_optical_thickness(volume: Volume, local_start: Vec3, local_end: Vec3, interpolate: bool) -> Color {
    
    let dir_u      = vec3_sub(local_end, local_start);
    let total_dist = vec3_len(dir_u);
    let dir_norm   = vec3_map(dir_u, @|x| safe_div(x, total_dist));

    let mut acc_opt = make_gray_color(0:f32);
    let mut test_dist = 0:f32;

    let volume_marcher  = make_dda_marcher(local_start, dir_norm, volume, interpolate); //TODO: ensure that origin is within the volume (max 0.9999)
    while (volume_marcher.has_next()) { // ensure that we are still within the volume
        
        let (current_segment, current_dist) = volume_marcher.next_segment();
        test_dist = current_dist;

        if current_dist + VOLUME_BOUNDS_FLT_MIN >= total_dist {
            let segment_dist = current_segment.distance - (current_dist - total_dist);
            return(color_add(acc_opt, current_segment.local_properties.optical_thickness(segment_dist)))
        } else {
            acc_opt = color_add(acc_opt, current_segment.local_properties.optical_thickness(current_segment.distance));
        }        
    }
    acc_opt
}

fn @eval_volume_properties(volume: Volume, pms: PointMapperSet, global_coords: Vec3) -> VolumeProperties {
    let accessor     = volume.access_data();
    let local_coords = pms.to_normalized_point(global_coords);
    make_option(accessor.properties_at_indx(volume.coord_to_indx(sampled_point)))
}


/**
 * Uniform transmittance sampling
 */
fn @sample_transmittance_uniform(rnd: &mut RndState) -> f32 {
    1:f32 - (randf(rnd) * 0.99999)
}

/**
 * Samples a distance with pdf proportional to transmittance (with transmittance uniformly distributed)
 */
fn @sample_dist_proptrans(rnd: &mut RndState, mu_t: f32) -> f32 {
    let trans = sample_transmittance_uniform(rnd);
    (-math_builtins::log(trans)/mu_t)
}