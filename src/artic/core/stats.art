// These functions only work on CPU host code

#[import(cc = "C")] fn ignis_stats_begin_section(i32) -> ();
#[import(cc = "C")] fn ignis_stats_end_section(i32) -> ();
#[import(cc = "C")] fn ignis_stats_add(i32, i32) -> ();


mod stats {

enum Quantity {
    CameraRayCount,
    ShadowRayCount,
    BounceRayCount,
    TraversalSteps,
    TraversalDimensionUpdates,
    VolumeScatter,
    VolumeAbsorption,
    VolumeNullCollision,
    VolumeTreeTraversal,
    VolumeValueSample
}

enum Section {
    GPUSortPrimary,
    GPUSortSecondary,
    GPUCompactPrimary,
    GPUSortPrimaryReset,
    GPUSortPrimaryCount,
    GPUSortPrimaryScan,
    GPUSortPrimarySort,
    GPUSortPrimaryCollapse,
    // TODO: Same depth for secondary and compact?
    ImageInfoPercentile,
    ImageInfoError,
    ImageInfoHistogram,
}

fn @section_id(sec: Section) = match sec {
    // Should match numbers in runtime/Statistics.h
    Section::GPUSortPrimary            => 0,
    Section::GPUSortSecondary          => 1,
    Section::GPUCompactPrimary         => 2,
    Section::GPUSortPrimaryReset       => 3, 
    Section::GPUSortPrimaryCount       => 4, 
    Section::GPUSortPrimaryScan        => 5, 
    Section::GPUSortPrimarySort        => 6, 
    Section::GPUSortPrimaryCollapse    => 7,
    // TODO: Add for CPU as well (vectorization kinda gets in the way though)
    Section::ImageInfoPercentile       => 10, 
    Section::ImageInfoError            => 11, 
    Section::ImageInfoHistogram        => 12,
};

fn @begin_section(sec: Section) -> () {
    super::ignis_stats_begin_section(section_id(sec));
} 

fn @end_section(sec: Section) -> () {
    super::ignis_stats_end_section(section_id(sec));
} 

fn @section(sec: Section, func: fn () -> ()) {
    begin_section(sec);
    func();
    end_section(sec);
}

fn @add_quantity(q: Quantity, value: i32) -> () {
    match q {
        Quantity::CameraRayCount => super::ignis_stats_add(0, value),
        Quantity::ShadowRayCount => super::ignis_stats_add(1, value),
        Quantity::BounceRayCount => super::ignis_stats_add(2, value),
        Quantity::TraversalSteps => super::ignis_stats_add(3, value),
        Quantity::TraversalDimensionUpdates => super::ignis_stats_add(4, value),
        Quantity::VolumeScatter       => super::ignis_stats_add(5, value),
        Quantity::VolumeAbsorption    => super::ignis_stats_add(6, value),
        Quantity::VolumeNullCollision => super::ignis_stats_add(7, value),
        Quantity::VolumeTreeTraversal => super::ignis_stats_add(8, value),
        Quantity::VolumeValueSample   => super::ignis_stats_add(9, value),
    }
}

}