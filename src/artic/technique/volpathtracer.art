struct VPTRayPayload {
    inv_pdf:  f32,
    contrib:  Color,
    depth:    i32,
    eta:      f32,
    medium:   i32,
    voldepth: i32,
    is_nee:   i32 // 0: it is a normal ray, 1: it is a shadow ray
}

fn @write_vptraypayload(payload: RayPayload, vpt: VPTRayPayload) -> () {
    payload.set(0, vpt.inv_pdf);
    payload.set(1, vpt.contrib.r);
    payload.set(2, vpt.contrib.g);
    payload.set(3, vpt.contrib.b);
    payload.set(4, vpt.depth as f32);
    payload.set(5, vpt.eta);
    payload.set(6, vpt.medium as f32);
    payload.set(7, vpt.voldepth as f32);
    payload.set(8, vpt.is_nee as f32);
}

fn @unwrap_vptraypayload(payload: RayPayload) = VPTRayPayload {
    inv_pdf  = payload.get(0),
    contrib  = make_color(payload.get(1), payload.get(2), payload.get(3), 1),
    depth    = payload.get(4) as i32,
    eta      = payload.get(5),
    medium   = payload.get(6) as i32,
    voldepth = payload.get(7) as i32,
    is_nee   = payload.get(8) as i32
};

fn @init_vpt_raypayload(payload: RayPayload) = write_vptraypayload(payload, VPTRayPayload {
    inv_pdf  = 0,
    contrib  = color_builtins::white,
    depth    = 1,
    eta      = 1,
    medium   = -1,
    voldepth = 0,
    is_nee   = 0
});

/**
 * Helper function for sampling the volume ONLY if max_scattering has not been reached yet
 */
fn @sample_volume(medium: Medium, vol_depth: i32, rnd: &mut RndState, start_pos: Vec3, end_pos: Vec3) -> Option[MediumSample] {
    if vol_depth + 1 > medium.max_scattering {
        reject_medium_sample()
    } else {
        medium.sample(rnd, start_pos, end_pos)
    }
}

/**
 * Helper function that either produces a NEE direction or a random phase function sample
 */
fn @sample_phase_nee(rnd: &mut RndState, rr_prob_nee: f32, phase: PhaseFunction, pos: Vec3, out_dir: Vec3, light_selector: LightSelector) -> (PhaseSample, bool) {

    if randf(rnd) < rr_prob_nee {
        let (light, light_select_pdf) = light_selector.sample(rnd, pos);
        
        let sample_direct = light.sample_direct;
        let light_sample  = @sample_direct(rnd, make_particle_surface_element(pos));
    
        let pdf_l_s = light_sample.pdf.as_solid(math_builtins::fabs(light_sample.cos), light_sample.dist * light_sample.dist) * light_select_pdf;
    
        // NEE sample
        (make_phase_sample(light_sample.dir, pdf_l_s, phase.eval(out_dir, light_sample.dir) / (pdf_l_s * rr_prob_nee)), true)
    } else {
        // Phase function sample
        let sample = phase.sample(rnd, out_dir);
        (make_phase_sample(sample.in_dir, sample.pdf, sample.weight / (1:f32 - rr_prob_nee)), false)
    }
}

struct NeeBounceSample[SampleType] {
    is_nee: bool,
    sample: SampleType
}
/**
 * Helper function that either produces a NEE direction or a random bsdf sample
 */
fn @sample_bsdf_nee(rnd: &mut RndState, rr_prob_nee: f32, bsdf: Bsdf, surf: SurfaceElement, out_dir: Vec3, light_selector: LightSelector) -> Option[NeeBounceSample[BsdfSample]] {

    let (light, light_select_pdf) = light_selector.sample(rnd, surf.point);
        
    let sample_direct = light.sample_direct;
    let light_sample  = @sample_direct(rnd, surf);

    let pdf_l_s = light_sample.pdf.as_solid(math_builtins::fabs(light_sample.cos), light_sample.dist * light_sample.dist) * light_select_pdf;

    let actual_rr_prob_nee = if pdf_l_s > flt_eps { rr_prob_nee } else { 0:f32 };
    
    if randf(rnd) < actual_rr_prob_nee {
        // NEE sample
        make_option(NeeBounceSample[BsdfSample] {
            is_nee = true,
            sample = BsdfSample {
                in_dir = light_sample.dir,  // Sampled direction
                pdf    = pdf_l_s,           // BSDF value for the sample
                color  = color_mulf(bsdf.eval(out_dir, vec3_neg(light_sample.dir)), 1:f32 / (pdf_l_s * actual_rr_prob_nee)), // Color of the sample, with cosine and pdf already applied
                eta    = 1:f32              // Eta on the sampled direction
            }
        })
    } else {
        // BSDF sample
        if let Option[BsdfSample]::Some(bsdf_sample) = bsdf.sample(rnd, out_dir, false) {
            make_option(NeeBounceSample[BsdfSample] {
                is_nee = false,
                sample = BsdfSample {
                    in_dir = bsdf_sample.in_dir,  // Sampled direction
                    pdf    = bsdf_sample.pdf,     // BSDF value for the sample
                    color  = color_divf(bsdf_sample.color, (1:f32 - actual_rr_prob_nee)), // Color of the sample, with cosine and pdf already applied
                    eta    = bsdf_sample.eta      // Eta on the sampled direction
                }
            })
        } else {
            Option[NeeBounceSample[BsdfSample]]::None
        }
    }
}

// TODO: Implement "A null-scattering path integral formulation of light transport", (Miller et. al, 2019)
fn @make_volume_path_renderer(max_path_len: i32, light_selector: LightSelector, media: MediaTable, framebuffer: AOVImage, clamp_value: f32, enable_nee: bool) -> Technique {
    let offset : f32 = 0.001;

    let handle_color = if clamp_value > 0 {
        @|c: Color| color_saturate(c, clamp_value)
    } else {
        @|c: Color| c
    };

    fn @get_medium(ctx: ShadingContext, id: i32) -> Medium {
        let gen = @media(id);
        gen(ctx)
    }

    fn @on_shadow( ctx: ShadingContext
                 , rnd: &mut RndState
                 , payload: RayPayload
                 , _: RayPayload
                 , mat: Material
                 ) -> ShadowRay {
                    

        if !enable_nee {
            return(ShadowRay::None)
        }
        // No shadow rays for specular materials
        if mat.bsdf.is_specular || light_selector.count == 0 {
            return(ShadowRay::None)
        }
        
        let pt = unwrap_vptraypayload(payload);
        if pt.depth + 1 > max_path_len {
            return(ShadowRay::None)
        }

        let (light, light_select_pdf) = light_selector.sample(rnd, ctx.surf.point);
        
        let sample_direct = light.sample_direct;
        let light_sample  = @sample_direct(rnd, ctx.surf);
        
        let was_medium_interaction = math_builtins::signbit(pt.inv_pdf);
        let medium = get_medium(ctx, pt.medium);
        let hitvol = medium.eval(rnd, ctx.ray.org, ctx.surf.point); // Volume transmittance from ray origin to this hit point

        let pdf_l_s = light_sample.pdf.as_solid(light_sample.cos, light_sample.dist * light_sample.dist) * light_select_pdf;
        if pdf_l_s <= flt_eps {
            return(ShadowRay::None)
        }

        let in_dir  = light_sample.dir;
        let out_dir = vec3_neg(ctx.ray.dir);
        let dot     = vec3_dot(in_dir, ctx.surf.local.col(2));

        // TODO: Secondary rays do not take "passthrough" surface + media into account. Would be useful to add transmittance into account...
        if dot > flt_eps && light_sample.cos > flt_eps {
            let mis = if light.delta || was_medium_interaction { 
                1:f32
            } else {
                let pdf_e_s = mat.bsdf.pdf(in_dir, out_dir); // Pdf to sample the light based on bsdf
                1 / (1 + pdf_e_s / pdf_l_s)
            };

            // The intensity is already divided by the pdf, adapt to the (possible) change of domain
            let factor = light_sample.pdf.value / pdf_l_s;

            let contrib = handle_color(color_mulf(
                color_mul(light_sample.intensity, color_mul(pt.contrib, mat.bsdf.eval(in_dir, out_dir))), mis * factor));

            if light.infinite {
                let vol = color_mul(hitvol, medium.eval_inf(ctx.surf.point, in_dir));
                return(make_simple_shadow_ray(
                    make_ray(ctx.surf.point, in_dir, offset, flt_max, ray_flag_shadow),
                    color_mul(contrib, vol)
                ))
            } else {
                let ld  = vec3_sub(light_sample.pos, ctx.surf.point);
                let vol = color_mul(hitvol, medium.eval(rnd, ctx.surf.point, light_sample.pos));
                return(make_simple_shadow_ray(
                    make_ray(ctx.surf.point, ld, offset, 1 - offset, ray_flag_shadow),
                    color_mul(contrib, vol)
                ))
            }
        }   
        ShadowRay::None
    }

    fn @on_hit( ctx: ShadingContext
              , payload: RayPayload
              , mat: Material
              ) -> Option[Color] {
        let pt = unwrap_vptraypayload(payload);
        
        // Hits on a light source
        if mat.is_emissive && ctx.surf.is_entering/* && pt.depth == 1*/ {
            let medium = get_medium(ctx, pt.medium);
            let dot    = -vec3_dot(ctx.ray.dir, ctx.surf.local.col(2));
            if dot > flt_eps { // Only contribute proper aligned directions
                let emit     = mat.emission(ctx);
                let inv_pdf  = math_builtins::fmax[f32](0/*Ignore medium interactions*/, pt.inv_pdf);
                let pdf_s    = emit.pdf.as_solid(dot, ctx.hit.distance * ctx.hit.distance);
                let mis      = if enable_nee { 1 / (1 + inv_pdf * light_selector.pdf(mat.light, ctx.ray.org) * pdf_s) } else { 1:f32 };

                let mut hash = fnv_init();
                hash = fnv_hash(hash, ctx.ray.org.x as u32);
                hash = fnv_hash(hash, ctx.ray.org.y as u32);
                hash = fnv_hash(hash, ctx.ray.org.z as u32);
                hash = fnv_hash(hash, ctx.surf.point.x as u32);
                hash = fnv_hash(hash, ctx.surf.point.y as u32);
                hash = fnv_hash(hash, ctx.surf.point.z as u32);

                let vol      = medium.eval(hash, ctx.ray.org, ctx.surf.point);
                let contrib  = handle_color(color_mulf(color_mul(pt.contrib, color_mul(emit.intensity, vol)), mis));
                
                return(make_option(contrib))
            }
        }
        Option[Color]::None
    }

    fn @on_miss( ray: Ray
               , pixel: PixelCoord
               , payload: RayPayload) -> Option[Color] {

        let mut inflights = 0;
        let mut color     = color_builtins::black;
        
        let pt     = unwrap_vptraypayload(payload);
        let ctx    = make_miss_shading_context(pixel, ray);
        let medium = get_medium(ctx, pt.medium);
        
        if pt.depth == 1 {
            return(Option[Color]::None)
        }

        for light_id in safe_unroll(0, light_selector.infinites.count) {
            let light = light_selector.infinites.get(light_id);
            // Do not include delta lights or finite lights
            if light.infinite && !light.delta {
                inflights += 1;

                let emit  = light.emission(ctx);
                let pdf   = light.pdf_direct(ray, make_invalid_surface_element());
                let pdf_s = pdf.as_solid(1, 1/* We assume infinite lights are always given in solid angle measure */);
                let mis   = if enable_nee { 1 / (1 + math_builtins::fmax[f32](0/*Ignore medium interactions*/, pt.inv_pdf) * light_selector.pdf(light, ray.org) * pdf_s) } else { 1:f32 };
                let vol   = medium.eval_inf(ray.org, ray.dir);
                color     = color_add(color, handle_color(color_mulf(color_mul(pt.contrib, color_mul(emit, vol)), mis)));
            }
        }

        if inflights > 0 {
            make_option(color)
        } else {
            Option[Color]::None
        }
    }

    fn @on_bounce( ctx: ShadingContext
                 , rnd: &mut RndState
                 , payload: RayPayload
                 , mat: Material
                 ) -> Option[Ray] {
        let pt      = unwrap_vptraypayload(payload);
        let medium  = get_medium(ctx, pt.medium);
        let out_dir = vec3_neg(ctx.ray.dir);

        
        if pt.depth + 1 > max_path_len {
            return(Option[Ray]::None)
        }


        // Try sampling the medium
        if let Option[MediumSample]::Some(medium_sample) = sample_volume(medium, if (pt.is_nee == 1) { medium.max_scattering } else { pt.voldepth }, rnd, ctx.ray.org, ctx.surf.point) { // differentiate if max-bounces was reached

            let mu_t   = medium_sample.properties.coeff_extinction;
            let mu_a   = medium_sample.properties.coeff_absorption;
            let mu_s   = medium_sample.properties.coeff_scattering;
            let mu_f   = medium_sample.properties.coeff_fictional;
            let mu_ind = vec3_max_index(color_to_vec3(mu_t));
            let mu_t_p = color_at(mu_t, mu_ind);
            let mu_a_p = color_at(mu_a, mu_ind);
            let mu_s_p = color_at(mu_s, mu_ind);

            // max. extinction coeff is assumed to not be 0 here (as probability of collision with particle is 0 if ext. is 0)
            let p_a = if mu_a_p <= flt_eps { 0:f32 } else { mu_a_p / mu_t_p };
            let p_s = if mu_s_p <= flt_eps { 0:f32 } else { mu_s_p / mu_t_p };
            let p_f = 1 - p_a - p_s;

            let r = randf(rnd);
            let weighted_ft = medium_sample.color; // corresponds to ft / p(t) in "A null-scattering path integral formulation of light transport", (Miller et. al, 2019).
            
            if r < p_a {
                // Absorption event
                let albedo        = color_div(mu_a, mu_t);
                let emission      = color_mul(albedo, medium_sample.properties.emitted_radiance); 
                let new_contrib   = color_divf(color_mul(weighted_ft, emission), p_a); /* weighted with Pdf of emission event!*/

                framebuffer.splat(ctx.pixel, color_mul(new_contrib, pt.contrib));
                Option[Ray]::None
            } else if r < p_a + p_s {
                // Scattering event
                let rr_prob_nee = if enable_nee { 0:f32 } else { 0.5:f32 };
                let albedo        = color_div(mu_s, mu_t);
                let (phase_sample, is_nee)  = sample_phase_nee(rnd, rr_prob_nee, medium.phase(medium_sample.pos), medium_sample.pos, out_dir, light_selector); // sample new direction
                let weighted_lS   = color_mul(albedo, color_mulf(pt.contrib, phase_sample.weight / p_s)); // weight by phase function scatter direction pdf AND pdf of picking a scatter event
                let contrib       = color_mul(weighted_ft, weighted_lS); 

                let rr_prob      = russian_roulette_pbrt(color_mulf(contrib, pt.eta * pt.eta), 0.95);
    
                if randf(rnd) >= rr_prob {
                    Option[Ray]::None
                } else {
                    let new_contrib = color_mulf(contrib, 1 / rr_prob);
                    // Notify other parts that the last interaction was a medium
                    let inv_pdf     = -1:f32; // 1 / (medium_sample.pdf * phase_sample.pdf); // TODO
                    write_vptraypayload(payload, VPTRayPayload {
                        inv_pdf  = inv_pdf,
                        contrib  = new_contrib,
                        depth    = pt.depth,
                        eta      = pt.eta,
                        medium   = pt.medium,
                        voldepth = if is_nee { medium.max_scattering } else { pt.voldepth + 1 },
                        is_nee   = if is_nee { 1:i32 } else { pt.is_nee }
                    });
                    make_option(
                        make_ray(medium_sample.pos, phase_sample.in_dir, 0, flt_max, ray_flag_bounce)
                    )
                }
            } else {
                // null-scattering event
                let albedo        = color_div(mu_f, mu_t); // = 1 in vacuum
                let ls            = color_mul(albedo, pt.contrib);
                let contrib       = color_divf(color_mul(weighted_ft, ls), p_f); // weight by  pdf

                let inv_pdf     = -1:f32; // 1 / (medium_sample.pdf * phase_sample.pdf); // TODO

                write_vptraypayload(payload, VPTRayPayload {
                    inv_pdf  = inv_pdf,
                    contrib  = contrib,
                    depth    = pt.depth,
                    eta      = pt.eta,
                    medium   = pt.medium,
                    voldepth = pt.voldepth,
                    is_nee   = pt.is_nee
                });
                make_option(
                    make_ray(medium_sample.pos, ctx.ray.dir, 0, flt_max, ray_flag_bounce) // continue in the same direction
                )
            }

        } else {
            // Bounce on surface
            let rr_prob_nee = if enable_nee { 0:f32 } else { 0:f32 };
            if let Option[NeeBounceSample[BsdfSample]]::Some(bsdf_sample_nee) = sample_bsdf_nee(rnd, rr_prob_nee, mat.bsdf, ctx.surf, out_dir, light_selector) {//mat.bsdf.sample(rnd, out_dir, false) {
                let bsdf_sample = bsdf_sample_nee.sample;
                let trans       = medium.eval(rnd, ctx.ray.org, ctx.surf.point); // this is (1, 1, 1) in vacuum
                let vol_contrib = color_mul(trans, pt.contrib);
                let contrib     = color_mul(vol_contrib, bsdf_sample.color/* Pdf and cosine are already applied!*/);
                let rr_prob     = russian_roulette_pbrt(color_mulf(contrib, pt.eta * pt.eta), 0.95);
                
                if randf(rnd) >= rr_prob {
                    Option[Ray]::None
                } else {
                    let inv_pdf     = if mat.bsdf.is_specular { 0 } else { 1:f32 / bsdf_sample.pdf };
                    let new_contrib = color_divf(contrib, rr_prob);
                    
                    let is_transmission = math_builtins::signbit(vec3_dot(ctx.surf.local.col(2), bsdf_sample.in_dir));
                    let (new_medium, new_voldepth) = if is_transmission { (mat.interface.pick(ctx.surf.is_entering), 0) } else { (pt.medium, pt.voldepth) };

                    write_vptraypayload(payload, VPTRayPayload {
                        inv_pdf  = inv_pdf,
                        contrib  = new_contrib,
                        depth    = pt.depth + 1,
                        eta      = pt.eta * bsdf_sample.eta,
                        medium   = new_medium,
                        voldepth = new_voldepth,
                        is_nee   = if bsdf_sample_nee.is_nee { 1:i32 } else { pt.is_nee }
                    });
                    make_option(
                        make_ray(ctx.surf.point, bsdf_sample.in_dir, offset, flt_max, ray_flag_bounce)
                    )
                }
            } else {
                Option[Ray]::None
            }
        }
    }

    Technique {
        on_hit         = on_hit,
        on_miss        = on_miss,
        on_shadow      = on_shadow,
        on_bounce      = on_bounce,
        on_shadow_hit  = TechniqueNoShadowHitFunction,
        on_shadow_miss = TechniqueNoShadowMissFunction,
    }
}
